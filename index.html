<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LT-Calculateur-de-volet-roulant</title>
    <!-- xlsx.js for data reading -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- ExcelJS for image extraction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
    <!-- Papa Parse for CSV importing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f4f9; color: #333; display: flex; justify-content: center;
            align-items: flex-start; min-height: 100vh; margin: 0; padding: 2em;
        }
        #logo-image {
            position: absolute; top: 2em; right: 2em; width: 10vw; max-width: 150px; height: auto; z-index: 10;
        }
        /* INCREASED MAX WIDTH TO 1400px */
        .container {
            background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 100%; max-width: 1400px; display: flex; flex-direction: row; align-items: stretch;
        }
        .content-area {
            padding: 2em; flex-grow: 1; border-left: 1px solid #dee2e6;
        }
        h1 { color: #1a1a1a; margin-bottom: 0.5em; }
        .header-controls {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5em; border-bottom: 1px solid #eee; padding-bottom: 1em;
        }
        .form-group { margin-bottom: 1.5em; }
        .form-row { display: flex; gap: 1.5em; }
        .form-col { flex: 1; }
        label { display: block; margin-bottom: 0.5em; font-weight: 600; }
        input[type="number"], input[type="file"], select, input[type="checkbox"], input[type="text"] {
            width: 100%; padding: 0.8em; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;
        }
        input[type="checkbox"] { width: auto; }
        input[type="file"] { padding: 0.5em; }
        .radio-group label { display: inline-block; margin-right: 15px; font-weight: 500;}
        .radio-group input[type="radio"] { margin-right: 5px; }
        .results {
            margin-top: 1.5em; background-color: #f8f9fa; padding: 1.5em; border-radius: 6px; border-left: 5px solid #007bff;
        }
        .results h3 { margin-top: 0; color: #0056b3; }
        .results h4 { margin-top: 1em; margin-bottom: 0.5em; color: #495057;}
        .results p { font-size: 1.1em; margin: 0.5em 0; line-height: 1.5; }
        .results span { font-weight: bold; color: #1a1a1a; }
        #import-status { margin-top: 0.5em; font-style: italic; color: #555; }
        
        .tabs {
            display: flex; flex-direction: column; background-color: #f1f3f5; flex-shrink: 0; width: 55px;
            border-top-left-radius: 8px; border-bottom-left-radius: 8px;
        }
        .tab-button {
            height: 120px; padding: 0.5em; border: none; cursor: pointer; font-size: 1em; font-weight: 600; color: #555;
            border-left: 5px solid transparent; transition: all 0.2s ease-in-out; writing-mode: vertical-rl;
            transform: rotate(180deg); text-align: center;
        }
        .tab-button:hover { filter: brightness(75%); }
        .tab-button.active { font-weight: 700; color: #000; border-left-color: #0d6efd; }
        .tab-button:nth-child(1) { background-color: #e3f2fd; }
        .tab-button:nth-child(2) { background-color: #e8f5e9; }
        .tab-button:nth-child(3) { background-color: #fff3e0; }
        .tab-button:nth-child(4) { background-color: #fce4ec; }
        .tab-button:nth-child(5) { background-color: #ede7f6; }
        .tab-button:nth-child(6) { background-color: #e0f7fa; }
        .tab-button:nth-child(7) { background-color: #fff8e1; }
        .tab-button:nth-child(8) { background-color: #e9ecef; }
        .tab-button.sloping-tab { background-color: #ffebee; }
        .tab-button.sloping-tab.active { background-color: #ffcdd2; border-left-color: #d32f2f; }
        
        .tab-button.active:nth-child(1) { background-color: #cce5ff; }
        .tab-button.active:nth-child(2) { background-color: #d1e7dd; }
        .tab-button.active:nth-child(3) { background-color: #ffe5b4; }
        .tab-button.active:nth-child(4) { background-color: #f8d7da; }
        .tab-button.active:nth-child(5) { background-color: #dcd0ff; }
        .tab-button.active:nth-child(6) { background-color: #b2ebf2; }
        .tab-button.active:nth-child(7) { background-color: #ffecb3; }
        .tab-button.active:nth-child(8) { background-color: #ced4da; }
        
        .tab-pane { display: block; }
        .tab-pane:not(.active) { display: none; }
        .tab-pane.active { display: block; padding-bottom: 2em; }
        .warning-text, p .warning-text, span.warning-text { color: #d93025 !important; font-weight: bold; }
        
        .width-validation-warning {
            color: #d93025; font-weight: 500; font-size: 0.9em; margin-top: 0.5em; display: none;
        }

        #recommendation-box {
            display: none; margin-top: 1em; padding: 1em; background-color: #fffbe6;
            border: 1px solid #ffe58f; border-radius: 4px; color: #d46b08; font-weight: bold;
        }
        
        /* Updated Graphic Containers to be Full Width on Inputs Page */
        .graph-container { margin-top: 1.5em; width: 100%; }
        
        /* Specific override for the main shutter graphics to allow full width */
        #shutter-graphic-container, #width-graphic-container {
            width: 100%; 
            max-width: 100%; /* Removing the 450px restriction */
            margin-left: auto; margin-right: auto;
            border: 1px solid #e9ecef; border-radius: 4px; background-color: #f8f9fa;
            overflow: hidden; /* Contains the SVG */
        }
        
        /* Other smaller graphs can stay restrained */
        #axle-cross-section-container, #torque-graph-container, #deflection-graphic-container {
            width: 100%; max-width: 900px; margin-left: 0; margin-right: auto;
        }
        #endplate-graphic-container, #chain-graphic-container {
            min-width: 450px; max-width: 550px; margin-left: auto; margin-right: auto;
        }

        .calculation-explainer {
            margin-top: 2em; padding: 1em; background-color: #e9ecef; border: 1px solid #ced4da;
            border-radius: 6px; font-family: monospace; font-size: 0.9em; line-height: 1.6;
        }
        
        /* SVG Styles */
        .beam-path { stroke: #adb5bd; stroke-width: 2; fill: none; }
        .deflected-path { stroke: #007bff; stroke-width: 4; fill: none; }
        .deflected-path.warning { stroke: #d93025; }
        .graph-text { font-family: sans-serif; font-size: 12px; fill: #343a40; text-anchor: middle; }
        .axis-line { stroke: #ced4da; stroke-width: 1; }
        .torque-bar { fill: #007bff; transition: all 0.2s ease-out; }
        .torque-bar:hover { fill: #0056b3; }
        .graph-data-label { font-size: 10px; text-anchor: middle; fill: #495057; }
        
        .support-symbol { fill: #868e96; stroke: #495057; stroke-width: 1; }
        .coil-wrap-graphic { fill: none; stroke: #adb5bd; stroke-width: 0.5; }
        .force-text { font-family: sans-serif; font-size: 11px; text-anchor: middle; }
        .force-text.red { fill: #d93025; font-weight: bold;}
        .force-text.blue { fill: #007bff; font-weight: bold;}
        .dim-text-force-diagram { font-family: sans-serif; font-size: 10px; fill: #343a40; text-anchor: middle;}

        .option-pass { color: #1e8e3e; font-weight: bold; }
        .option-fail { color: #d93025; }

        /* Graphic Element Styles */
        .sprocket-wheel { fill: #e9ecef; stroke: #495057; stroke-width: 1; }
        .sprocket-tooth { fill: #6c757d; }
        .chain-path { fill: none; stroke: #343a40; stroke-width: 6; stroke-dasharray: 6,4; stroke-linecap: round; }
        .chain-path-bg { fill: none; stroke: #adb5bd; stroke-width: 7; }
        .chain-pitch-circle { fill: none; stroke: #d93025; stroke-width: 0.5; stroke-dasharray: 4,2; }
        .chain-driveshaft { fill: #e9ecef; stroke: #495057; stroke-width: 2; }

        .shutter-axle-graphic { fill: #6c757d; stroke: #495057; stroke-width: 0.5; }
        .shutter-lath-graphic { fill: #e9ecef; stroke: #adb5bd; stroke-width: 0.5; }
        .shutter-bottomlath-graphic { fill: #ced4da; stroke: #495057; stroke-width: 0.5; }
        .wicket-door-graphic { fill: #a5d6a7; stroke: #388e3c; stroke-width: 1; }
        .shutter-vision-lath-graphic { fill: #a7d8f0; stroke: #6bafd2; stroke-width: 0.5; }
        .endlock-graphic { fill: #000000; }
        .wind-endlock-graphic { fill: #555555; } 
        .endplate-box-graphic {
            fill: rgba(255, 193, 7, 0.2); stroke: #ffc107; stroke-width: 1; stroke-dasharray: 4, 2;
        }
        .axle-centerline-graphic { stroke: #d93025; stroke-width: 1; stroke-dasharray: 4, 2; }
        .dimension-line { stroke: #343a40; stroke-width: 1; }
        .leader-line { stroke: #343a40; stroke-width: 0.5; stroke-dasharray: 2,2; }
        .dimension-text { font-family: sans-serif; font-size: 5px; fill: #343a40; text-anchor: middle; }
        .large-dimension-text { font-family: sans-serif; font-size: 10px; fill: #343a40; text-anchor: middle; }
        .width-graphic-label { font-family: sans-serif; font-size: 14px; fill: #343a40; text-anchor: middle; }
        .width-graphic-value { font-family: sans-serif; font-size: 10px; fill: #555; text-anchor: middle; }
        .dimension-tick { stroke: #343a40; stroke-width: 1; }
        
        .sloping-graphic-container {
             width: 100%; border: 1px solid #e9ecef; border-radius: 4px; background-color: #fff; margin-bottom: 2em;
        }

        .print-container { display: flex; gap: 10px; }
        #printButton, #dxfButton {
            padding: 0.8em 1.5em; font-size: 0.9em; font-weight: 600; color: white;
            border: none; border-radius: 5px; cursor: pointer;
        }
        #printButton { background-color: #007bff; }
        #printButton:hover { background-color: #0056b3; }
        #dxfButton { background-color: #28a745; }
        #dxfButton:hover { background-color: #218838; }

        /* Zoom Controls */
        .zoom-controls {
            display: flex; gap: 10px; justify-content: center; margin-bottom: 10px; align-items: center;
        }
        .zoom-btn {
            background: #e9ecef; border: 1px solid #ced4da; padding: 5px 15px; cursor: pointer; font-weight: bold; border-radius: 4px;
        }
        .zoom-btn:hover { background: #dee2e6; }

        /* Admin Page Styles */
        .admin-section {
            margin-bottom: 2em; padding: 1.5em; border: 1px solid #dee2e6; border-radius: 6px;
        }
        .admin-section h3 {
            margin-top: 0; border-bottom: 2px solid #007bff; padding-bottom: 0.5em;
        }
        .admin-section h4 {
            margin-top: 1.5em; margin-bottom: 0.5em; color: #495057;
        }
        .admin-controls, .report-filter-container {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1em; margin-top: 1em;
        }
        .admin-control-item label {
            font-weight: 500; display: flex; align-items: center; gap: 8px; cursor: pointer;
        }
        .admin-button-group {
            display: flex; gap: 1em; margin-bottom: 1.5em;
        }
        .admin-button-group button, #importCsvButton, #generateCsvButton {
            padding: 0.5em 1em; font-size: 0.8em; font-weight: 500; color: #fff;
            background-color: #6c757d; border: none; border-radius: 4px; cursor: pointer;
        }
        .admin-button-group button:hover, #importCsvButton:hover, #generateCsvButton:hover {
            background-color: #5a6268;
        }
        #importCsvButton { background-color: #28a745; }
        #importCsvButton:hover { background-color: #218838; }
        #generateCsvButton { background-color: #007bff; font-size: 0.9em; padding: 0.8em 1.2em; }
        #generateCsvButton:hover { background-color: #0056b3; }

        .report-controls-grid {
            display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1em; margin-bottom: 1.5em;
        }
        .report-filter-container {
             max-height: 200px; overflow-y: auto; padding: 1em; border: 1px solid #dee2e6; border-radius: 4px;
        }

        .shape-toggle {
            display: flex; border: 1px solid #ccc; border-radius: 4px; overflow: hidden;
        }
        .shape-toggle input[type="radio"] { display: none; }
        .shape-toggle label {
            flex: 1; text-align: center; padding: 0.8em; margin: 0; cursor: pointer;
            background-color: #f8f9fa; color: #495057; transition: background-color 0.2s; font-weight: 500;
        }
        .shape-toggle input[type="radio"]:checked + label {
            background-color: #007bff; color: white; font-weight: 600;
        }

        /* Ensure the summary is hidden on the live web screen */
        .print-only-section { display: none; }

        @media print {
            body { font-family: Arial, sans-serif; background-color: #fff; padding: 0 !important; margin: 0 !important; }
            @page { size: A4; margin: 15mm; }
            
            /* Show the Summary on Page 1 */
            .print-only-section { display: block !important; margin-bottom: 30px; }
            #print-header-summary { display: block !important; }

            /* Hide Navigation and UI */
            .tabs, .form-group, .form-row, .print-container, .zoom-controls, .calculation-explainer, 
            hr, #import-status, #recommendation-box, #admin-content, #logo-image, 
            button { 
                display: none !important; 
            }

            .container { display: block; box-shadow: none; border: none; width: 100%; max-width: 100%; }
            .content-area { padding: 0; border: none; }
            .tab-pane { 
                display: block !important; 
                page-break-after: always; 
                visibility: visible !important; 
                margin-top: 20px;
            }

            body.hide-wicket-print #wicket-content { display: none !important; }
            body.hide-slope-print #slope-content { display: none !important; }

            .results { border: 1px solid #ccc; page-break-inside: avoid; padding: 15px; }
            svg { width: 100% !important; max-height: 900px; page-break-inside: avoid; }
            h1 { font-size: 20pt; text-align: center; }
            h2 { font-size: 15pt; border-bottom: 2px solid #ccc; padding-bottom: 4px; margin-top: 1.5em; margin-bottom: 1em; }
            
            /* Ensure graphics expand on print */
            #shutter-graphic-container, #width-graphic-container {
                width: 100% !important;
                max-width: 100% !important;
            }
        }
    </style>
</head>

<body>
    <img src="https://raw.githubusercontent.com/rob-hyrons/SWS_logic_calculator/main/swslogo.svg" alt="SWS Logo" id="logo-image">
    <div class="container">
        <div class="tabs">
            <button class="tab-button active" data-tab="inputs-content">Inputs</button>
            <button class="tab-button" data-tab="axle-content">Axle</button>
            <button class="tab-button" data-tab="motor-content">Motor</button>
            <button class="tab-button" data-tab="endplate-content">Endplate</button>
            <button class="tab-button" data-tab="safety-brake-content">Safety Brake</button>
            <button class="tab-button" data-tab="wicket-content">Wicket Door</button>
            <button class="tab-button" data-tab="chain-content">Chain</button>
            <button class="tab-button sloping-tab" data-tab="slope-content" style="display:none;" id="slope-tab-btn">Sloping Bottom</button>
            <button class="tab-button" data-tab="admin-content">Admin</button>
        </div>
        <div class="content-area">
            
            <div class="header-controls">
                <h1>Complete Shutter Calculator</h1>
                <!-- Explicit Buttons for PDF and DXF -->
                <div class="print-container">
                     <button id="dxfButton">Download DXF</button>
                     <button id="printButton">Print / Save PDF</button>
                </div>
            </div>
            
            <!-- This section only appears in the PDF/Print -->
            <div id="print-header-summary" class="print-only-section">
                <h2 style="text-align: center; border-bottom: 2px solid #333; padding-bottom: 10px;">Project Specification Summary</h2>
                <div class="results" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; border-left: 8px solid #28a745; background: #fff;">
                    <p><strong>Input Width:</strong> <span id="p-width">0</span> mm</p>
                    <p><strong>Width Type:</strong> <span id="p-width-type">-</span></p>
                    <p><strong>Curtain Height:</strong> <span id="p-height">0</span> mm</p>
                    <p><strong>Lath Type:</strong> <span id="p-lath">-</span></p>
                    <p><strong>Bottom Lath:</strong> <span id="p-bottom-lath">-</span></p>
                    <p><strong>Guide Type:</strong> <span id="p-guide">-</span></p>
                    <p><strong>Axle Shape:</strong> <span id="p-axle-shape">-</span></p>
                    <p><strong>Powder Coated:</strong> <span id="p-pc">No</span></p>
                    <p id="p-slope-row" style="display:none; grid-column: span 2;"><strong>Sloping Bottom Lath:</strong> Yes (<span id="p-slope-weight">0</span> kg)</p>
                </div>
            </div>

            <div class="tab-content">
                <!-- Inputs Tab -->
                <div id="inputs-content" class="tab-pane active">
                    <h2>Shutter Specification</h2>
                    <div class="form-group" data-admin-label="File Import Status">
                         <div id="import-status">Attempting to load data from repository...</div>
                    </div>
                    
                    <!-- Row 1: Width & Width Type -->
                    <div class="form-row">
                        <div class="form-group form-col" data-admin-label="Input Width">
                            <label for="width">Input Width (mm)</label>
                            <input type="number" id="width" placeholder="e.g., 3000">
                            <div id="width-warning" class="width-validation-warning"></div>
                        </div>
                        <div class="form-group form-col" data-admin-label="Width Type">
                            <label for="widthType">Width Type</label>
                            <select id="widthType">
                                <option value="clearOpening">Clear Opening</option>
                                <option value="curtainWidth" selected>Curtain Width</option>
                                <option value="overall">Overall (Reveal)</option>
                            </select>
                        </div>
                    </div>

                    <!-- Row 2: Lath Type and Curtain Height -->
                    <div class="form-row">
                        <div class="form-group form-col" data-admin-label="Lath Type">
                            <label for="lathType">Lath Type</label>
                            <select id="lathType" disabled>
                                <option value="">-- Waiting for file import --</option>
                            </select>
                        </div>
                        <div class="form-group form-col" data-admin-label="Curtain Height">
                            <label for="height">Curtain Height (Floor to Axle Centre, mm)</label>
                            <input type="number" id="height" placeholder="e.g., 4000">
                        </div>
                    </div>

                    <div id="lath-image-container" style="margin-top: 1em; margin-bottom: 1.5em; text-align: center; display: none;">
                        <img id="lathImageDisplay" src="" alt="Lath Image" style="max-width: 100%; max-height: 100px; border-radius: 4px; border: 1px solid #ccc;">
                    </div>

                    <!-- Row 3: Guide Type and Endlock Type -->
                    <div class="form-row">
                        <div class="form-group form-col" data-admin-label="Guide Type">
                            <label for="guideType">Guide Type</label>
                            <select id="guideType" disabled>
                                <option value="">-- Waiting for file import --</option>
                            </select>
                        </div>
                        <div class="form-group form-col" data-admin-label="Endlock Type">
                            <label for="endlockType">Endlock Type</label>
                            <select id="endlockType" disabled>
                                <option value="">-- Waiting for file import --</option>
                            </select>
                        </div>
                    </div>

                    <!-- Row 4: Bottom Lath Type (Above checkboxes) -->
                    <div class="form-group" data-admin-label="Bottom Lath Type">
                        <label for="bottomLathType">Bottom Lath Type</label>
                        <select id="bottomLathType" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>

                    <!-- Row 5: Checkboxes for Custom Lath & Powder Coated -->
                    <div class="form-row">
                        <div class="form-group form-col" data-admin-label="Custom Lath Option">
                            <label for="useCustomLath" style="display: inline-block; font-weight: 500; cursor: pointer;">
                                <input type="checkbox" id="useCustomLath" style="width: auto; margin-right: 8px; vertical-align: middle;">Use Custom Lath
                            </label>
                        </div>
                        <div class="form-group form-col" data-admin-label="Powder Coated Option">
                            <label for="powderCoated" style="display: inline-block; font-weight: 500; cursor: pointer;">
                                <input type="checkbox" id="powderCoated" style="width: auto; margin-right: 8px; vertical-align: middle;">Powder Coated (+0.5 kg/m²)
                            </label>
                        </div>
                    </div>

                    <!-- Custom Lath Hidden Options -->
                    <div id="custom-lath-options" data-admin-label="Custom Lath Weight" style="display: none; padding-left: 20px; border-left: 3px solid #e9ecef; margin-bottom: 1.5em; margin-top: -1em;">
                        <div class="form-group">
                            <label for="customLathWeight">Custom Lath Weight (kg/m²)</label>
                            <input type="number" id="customLathWeight" placeholder="e.g., 9.5">
                            <small style="font-size: 0.8em; color: #555;">Note: Other properties (thickness, height) will be based on the lath selected above.</small>
                        </div>
                        <div class="form-group">
                            <label for="customTorqueWeight">Custom Curtain Weight for Lift (kg)</label>
                            <input type="number" id="customTorqueWeight" placeholder="e.g., 150.5">
                            <small style="font-size: 0.8em; color: #555;">If a value is entered here, it will override the calculated 'Curtain Weight (for Torque)'.</small>
                        </div>
                    </div>
                    
                    <!-- Row 6: Checkboxes for Sloping Bottom & Add Vision -->
                    <div class="form-row">
                        <div class="form-group form-col" data-admin-label="Sloping Bottom Lath Option">
                            <label for="isSlopingBottomLath" style="display: inline-block; font-weight: 500; cursor: pointer;">
                                <input type="checkbox" id="isSlopingBottomLath" style="width: auto; margin-right: 8px; vertical-align: middle;">Sloping Bottom Lath
                            </label>
                        </div>
                        <div class="form-group form-col" data-admin-label="Add Vision Slats Option">
                            <label for="addVision" style="display: inline-block; font-weight: 500; cursor: pointer;">
                                <input type="checkbox" id="addVision" style="width: auto; margin-right: 8px; vertical-align: middle;">Add Vision Slats
                            </label>
                        </div>
                    </div>

                    <!-- Vision Slat Hidden Options -->
                    <div id="vision-slat-options" data-admin-label="Vision Slat Details" style="display: none; padding-left: 20px; border-left: 3px solid #e9ecef; margin-bottom: 1.5em; margin-top: -1em;">
                        <div class="form-group">
                            <label for="visionLathType">Vision Lath Type</label>
                            <select id="visionLathType" disabled>
                                <option value="">-- Waiting for file import --</option>
                            </select>
                        </div>
                        <div id="vision-lath-image-container" style="margin-top: 1em; margin-bottom: 1.5em; text-align: center; display: none;">
                            <img id="visionLathImageDisplay" src="" alt="Vision Lath Image" style="max-width: 100%; max-height: 100px; border-radius: 4px; border: 1px solid #ccc;">
                        </div>
                        <div class="form-group">
                            <label for="visionStartHeight">Height to Vision Start (from floor, mm)</label>
                            <input type="number" id="visionStartHeight" placeholder="e.g., 1000">
                            <small style="font-size: 0.8em; color: #555;">This will be adjusted to the nearest lath.</small>
                        </div>
                        <div class="form-group">
                            <label for="visionPanelHeight">Vision Panel Height (mm)</label>
                            <input type="number" id="visionPanelHeight" placeholder="e.g., 500">
                            <small style="font-size: 0.8em; color: #555;">This will be adjusted to the nearest lath.</small>
                        </div>
                    </div>

                    <!-- Row 7: Additional Axle Width (Below Checkboxes) -->
                    <div class="form-group" data-admin-label="Additional Axle Width">
                        <label for="additionalLength">Additional Axle Width (Total, mm)</label>
                        <input type="number" id="additionalLength" placeholder="e.g., 100" value="20">
                    </div>

                    <div class="results">
                        <h3>Shutter Details</h3>
                        <p>Curtain Width (Calculated): <span id="calculated-curtain-width">0</span> mm</p>
                        <p>Clear Opening (Calculated): <span id="calculated-clear-opening">0</span> mm</p>
                        <p>Overall Width (Calculated): <span id="calculated-overall-width">0</span> mm</p>
                        <hr>
                        <p>Total Shutter Weight: <span id="weight-kg">0.00</span> kgs</p>
                        <p>Curtain Weight (for Torque): <span id="torque-weight-kg">0.00</span> kgs</p>
                        <p>Total Endlock Weight: <span id="endlock-weight">0.00</span> kgs</p>
                        <p>Total Curtain Area (Material): <span id="curtain-area">0.00</span> m²</p>
                        <p>Curtain Area to Lift (Coverage): <span id="lifted-curtain-area">0.00</span> m²</p>
                        <p>Total Applied Friction: <span id="total-applied-friction">0</span> %</p>
                        <p id="vision-area-m2-para" style="display: none;">Total Vision Area: <span id="vision-area-m2">0.00</span> m²</p>
                        <p id="vision-percentage-para" style="display: none;">Overall Vision Percentage: <span id="vision-percentage">0.00</span> %</p>
                        <p>Total Number of Laths: <span id="lath-count">0</span></p>
                        <p>Laths to Lift: <span id="laths-to-lift">0</span></p>
                        <p>Uncompressed Curtain Height: <span id="curtain-height-extended">0</span> mm</p>
                        <p>Compressed Curtain Height: <span id="curtain-height-compressed">0</span> mm</p>
                        <h4 style="margin-top: 1em; margin-bottom: 0.5em; color: #495057;">Motor Recommendation</h4>
                        <p>Max Required Torque: <span id="max-torque-inputs">0.0</span> Nm</p>
                        <p>Selected Motor: <span id="motor-name-inputs">N/A</span></p>
                        <p id="motor-torque-line-inputs">Motor Torque Range: <span id="motor-torque-inputs">0</span> Nm</p>
                    </div>

                    <!-- Zoom Controls for Graphic -->
                    <div class="zoom-controls">
                        <label>Graphic Scale: </label>
                        <button class="zoom-btn" onclick="adjustZoom(-10)">-</button>
                        <button class="zoom-btn" onclick="adjustZoom(10)">+</button>
                        <span id="zoom-level-text">100%</span>
                    </div>

                    <div id="shutter-graphic-container"></div>
                    <div id="width-graphic-container" class="graph-container"></div>
                </div>

                <!-- Axle Analysis Tab -->
                <div id="axle-content" class="tab-pane">
                    <h2>Axle Deflection Analysis</h2>
                    
                    <div class="form-group" data-admin-label="Axle Shape">
                        <label>Axle Shape</label>
                        <div class="shape-toggle">
                            <input type="radio" id="shapeCircular" name="axleShape" value="circular" checked>
                            <label for="shapeCircular">Circular</label>
                            <input type="radio" id="shapeOctagonal" name="axleShape" value="octagonal">
                            <label for="shapeOctagonal">Octagonal</label>
                        </div>
                    </div>
                    
                    <div class="form-group" data-admin-label="Axle Type Selector">
                        <label for="axleType">Axle Section (Auto-Selected)</label>
                        <select id="axleType" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    
                    <div class="form-group" id="collar-size-group" data-admin-label="Collar Size" style="display: none;">
                        <label for="collarSize">Collar Size (mm)</label>
                        <input type="number" id="collarSize" placeholder="e.g., 150" value="0">
                    </div>

                    <div id="deflection-graphic-container" class="graph-container" style="height: 150px;"></div>
                    <div id="axle-cross-section-container" class="graph-container" style="height: 350px; margin-top: 2.5em;"></div>
                    <div class="results">
                        <h3>Axle Performance</h3>
                        <p>Total Axle Length: <span id="total-axle-length">0</span> mm</p>
                        <p>Axle Weight: <span id="axle-weight">0.00</span> kgs</p>
                        <p>Total Weight (for Deflection): <span id="total-deflection-weight">0.00</span> kgs</p>
                        <p>Material Grade: <span id="axle-material-grade">N/A</span></p>
                        <p>Moment of Inertia (I): <span id="moment-of-inertia">0.00</span> mm⁴</p>
                        <p>Calculated Deflection: <span id="axle-deflection">0.00</span> mm</p>
                        <p id="ratio-paragraph">Deflection Ratio: <span id="deflection-ratio">N/A</span></p>
                        <p>Safety Factor: <span id="axle-safety-factor">N/A</span></p>
                        <hr>
                        <h4>Bearing Selection</h4>
                        <p>Selected Bearing: <span id="bearing-name">N/A</span></p>
                        <p>Bearing Capacity: <span id="bearing-capacity">N/A</span></p>
                        <p id="bearing-warning" style="display:none; color: #d93025; font-weight: bold; margin-top:5px;">⚠️ Warning: Load exceeds bearing capacity!</p>
                    </div>
                    <div id="recommendation-box"></div> 
                    <div id="weld-check-container" class="results" style="margin-top: 2em; border-left-color: #e83e8c;">
                        <h3 style="color: #c92a7a;">Axle Shaft Weld Strength</h3>
                        <div class="form-row">
                            <div class="form-group form-col">
                                <label>Smallest Shaft Diameter</label>
                                <input type="text" id="weld-shaft-dia" readonly style="background-color: #e9ecef; font-weight: bold;" value="0 mm">
                                <small style="color: #555;">(Worst case of Motor, Brake, or Bearing)</small>
                            </div>
                            <div class="form-group form-col">
                                <label>Endplate Disc Thickness</label>
                                <input type="text" id="weld-plate-thickness" readonly style="background-color: #e9ecef; font-weight: bold;" value="0 mm">
                                <small style="color: #555;">5mm (≤139mm OD) or 8mm (>139mm OD)</small>
                            </div>
                        </div>
                        
                        <div class="form-row">
                            <div class="form-group form-col">
                                <label>Operating Torque (Max)</label>
                                <input type="text" id="weld-applied-torque" readonly style="background-color: #e9ecef;" value="0 Nm">
                            </div>
                            <div class="form-group form-col">
                                <label>Weld Torque Capacity</label>
                                <input type="text" id="weld-capacity-torque" readonly style="background-color: #e9ecef;" value="0 Nm">
                            </div>
                        </div>

                        <p>Weld Perimeter: <span id="weld-perimeter">0.0</span> mm</p>
                        <p>Max Tangential Force (Shear): <span id="weld-max-force">0</span> N</p>
                        <p>Weld Status: <span id="weld-status" style="font-weight: bold;">N/A</span></p>

                        <div id="weld-graphic-container" class="graph-container" style="height: 500px; border: 1px solid #e9ecef; border-radius: 4px; background-color: white; margin-top: 1em;"></div>
                    </div>

                </div>

                
				<!-- Motor Tab -->
                <div id="motor-content" class="tab-pane">
                    <h2>Motor & Torque Analysis</h2>
                    
                    <!-- Moved to be the first dropdown -->
                    <div class="form-group" data-admin-label="Motor Mounting Type">
                        <label for="motorMountingType">Motor Mounting Type</label>
                        <select id="motorMountingType" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    
                    <div class="form-group" data-admin-label="Motor Usage Type">
                        <label for="motorUsageFilter">Motor Usage Type</label>
                        <select id="motorUsageFilter" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="form-group" data-admin-label="Motor Manufacturer">
                        <label for="motorManufacturerFilter">Motor Manufacturer</label>
                        <select id="motorManufacturerFilter" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="form-group" data-admin-label="Motor Voltage">
                        <label for="motorVoltageFilter">Motor Voltage</label>
                        <select id="motorVoltageFilter" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="form-group" data-admin-label="Manual Override">
                        <label for="motorManualOverrideFilter">Manual Override</label>
                        <select id="motorManualOverrideFilter" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="form-group" data-admin-label="Lath Friction Allowance">
                        <label for="friction">Lath Baseline Friction Allowance (%)</label>
                        <input type="number" id="friction" value="10" title="Automatically updated from Lath data. Can be overridden.">
                    </div>
                    
                    <div id="torque-graph-container" class="graph-container" style="height: 280px;"></div>
                    
                    <div class="results">
                        <h3>Torque Calculation</h3>
                        <p>Max Required Torque: <span id="max-torque">0.0</span> Nm</p>
                        <p>Total Revolutions: <span id="total-revolutions">0.0</span></p>
                        <hr>
                        <div class="form-group" data-admin-label="Motor Selector">
                            <label for="motorSelector">Select Motor</label>
                            <select id="motorSelector" disabled>
                                <option>-- First select a mounting type --</option>
                            </select>
                        </div>
                        <h3>Selected Motor Details</h3>
                        <div id="motor-image-container" style="margin-top: 1em; margin-bottom: 1.5em; text-align: center; display: none;">
                            <img id="motorImageDisplay" src="" alt="Motor Image" style="max-width: 100%; max-height: 150px; border-radius: 4px; border: 1px solid #ccc;">
                        </div>
                        <p>Motor Name: <span id="motor-name">N/A</span></p>
                        <p id="motor-torque-line">Motor Torque Range: <span id="motor-torque">0</span> Nm</p>
                        <p>Motor Speed: <span id="motor-rpm">0</span> RPM</p>
                        <p>Driveshaft Diameter: <span id="motor-driveshaft-dia">N/A</span></p>
                        <p>Cycles Per Hour: <span id="motor-cycles-per-hour">N/A</span></p>
                        <p>Opening Time: <span id="opening-time">0</span> seconds</p>
                        <p>Power Consumed per Cycle: <span id="power-consumed">0.0000</span> kWh</p>
                        <p>Motor Limit Turns: <span id="motor-limit-turns">N/A</span></p>
                        <p id="motor-limit-warning" style="display:none; color: #d93025; font-weight: bold;">⚠️ Warning: Required revolutions exceed motor limit.</p>
                    </div>
                </div>
                
                <div id="endplate-content" class="tab-pane page-break-before-print">
                    <h2>Endplate Selection</h2>
                     <div class="form-group" data-admin-label="Endplate Material">
                        <label>Endplate Material</label>
                        <div class="radio-group">
                            <input type="radio" id="matSteel" name="material" value="Steel" checked>
                            <label for="matSteel">Steel</label>
                            <input type="radio" id="matAluminium" name="material" value="Aluminium">
                            <label for="matAluminium">Aluminium</label>
                        </div>
                    </div>
                    <div class="form-group" data-admin-label="Include Deflection in Sizing">
                        <label for="includeDeflectionInSizing" style="display: inline-block; font-weight: 500; cursor: pointer;">
                            <input type="checkbox" id="includeDeflectionInSizing" style="width: auto; margin-right: 8px; vertical-align: middle;">Include Axle Deflection in Coil Sizing
                        </label>
                    </div>
                    <div class="form-group" data-admin-label="Endplate Selector">
                        <label for="endplateSelector">Select Endplate (Auto-Selected)</label>
                        <select id="endplateSelector" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="results" style="border-left-color: #ffc107;">
                        <h3 style="color: #c79100;">Sizing Details</h3>
                        <p>Maximum Coil Diameter: <span id="max-coil-diameter">0.0</span> mm</p>
                        <p id="effective-coil-para" style="display: none;">Effective Sizing Diameter (inc. deflection): <span id="effective-coil-diameter">0.0</span> mm</p>
                        <hr>
                        <h3>Selected Endplate</h3>
                        <p>Name: <span id="endplate-name">N/A</span></p>
                        <p>Size: <span id="endplate-size">0</span> mm</p>
                        <p>Material: <span id="endplate-material">N/A</span></p>
                        <hr>
                        <h4>Curtain Height Limits by Endplate</h4>
                        <p>For Next Size Down (<span id="prev-endplate-name">N/A</span>): <span id="prev-endplate-height">N/A</span> mm</p>
                        <p>For Next Size Up (<span id="next-endplate-name">N/A</span>): <span id="next-endplate-height">N/A</span> mm</p>
                    </div>
                    <div id="endplate-graphic-container" class="graph-container"></div>
                    <div class="results page-break-before-print" style="border-left-color: #6f42c1; margin-top: 2em;">
                        <h3 style="color: #5a32a3;">Fixing Forces Analysis (Per Endplate, inc. 20% Safety Factor)</h3>
                        <p>Total Downward Shear Force: <span id="endplate-downward-force">0</span> N</p>
                        <p>Resultant Pull-out Force (on top fixing): <span id="endplate-pullout-force">0</span> N</p>
                    </div>
                    <div id="endplate-force-diagram-container" class="graph-container" style="height: 450px; margin-top: 1.5em;"></div>
                </div>

                <!-- Safety Brake Tab -->
                <div id="safety-brake-content" class="tab-pane">
                    <h2>Safety Brake Selection</h2>
                    
                    <div class="form-group" data-admin-label="Safety Brake Selector">
                        <label for="safetyBrakeSelector">Available Safety Brakes (Auto-Selected based on Operating Torque)</label>
                        <select id="safetyBrakeSelector" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    
                    <div id="safety-brake-image-container" style="margin-top: 1em; margin-bottom: 1.5em; text-align: center; display: none;">
                        <img id="safetyBrakeImageDisplay" src="" alt="Safety Brake Image" style="max-width: 100%; max-height: 100px; border-radius: 4px; border: 1px solid #ccc;">
                    </div>

                    <div class="results" style="border-left-color: #d93025;">
                        <h3 style="color: #d93025;">Selected Brake</h3>
                        <p>Selected Safety Brake: <span id="safety-brake-name">N/A</span></p>
                        <p>Brake Operating Torque Rating: <span id="safety-brake-capacity">N/A</span> Nm</p>
                        <p>Required Motor Torque (Max): <span id="safety-brake-motor-torque">N/A</span> Nm</p>
                        <p>Brake Shaft Diameter: <span id="safety-brake-driveshaft">N/A</span></p>
                        <hr>
                        <p>Max Locking Speed (Brake Limit): <span id="safety-brake-max-speed">N/A</span></p>
                        <p>Calculated Barrel Speed: <span id="actual-barrel-speed">N/A</span></p>
                        <p id="safety-brake-speed-warning" style="display:none; color: #d93025; font-weight: bold; margin-top:5px;">⚠️ Warning: Barrel speed exceeds Safety Brake limit!</p>
                    </div>

                    <div class="calculation-explainer">
                        <h4>Selection Logic Explained</h4>
                        This safety brake is selected by comparing the <strong>Max Motor Torque</strong> against the <strong>Operating Torque (Nm)</strong> column in the SafetyB data sheet. The first available brake with an Operating Torque greater than the motor torque is selected.
                    </div>
                </div>
                
                <div id="wicket-content" class="tab-pane">
                    <h2>Wicket Door Selection</h2>
                    <div class="form-group" data-admin-label="Wicket Door Selector">
                        <label for="wicketDoorSelector">Available Wicket Doors</label>
                        <select id="wicketDoorSelector" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="results" style="border-left-color: #00bcd4;">
                        <h3 style="color: #00838f;">Selected Wicket Door</h3>
                        <p>Name: <span id="wicket-door-name">N/A</span></p>
                        <p>Height: <span id="wicket-door-height">0</span> mm</p>
                        <p>Width: <span id="wicket-door-width">0</span> mm</p>
                        <hr>
                        <p>Laths Level with Wicket Door: <span id="laths-at-wicket">0</span></p>
                        <p>Height to Top of Wicket Laths: <span id="wicket-lath-height">0</span> mm</p>
                        <h3 style="margin-top: 1.5em;">Adjusted Motor Torque</h3>
                        <p>Max Required Torque (with Wicket): <span id="wicket-max-torque">0.0</span> Nm</p>
                    </div>
                    <div id="wicket-graphic-container"></div>
                    <div id="wicket-torque-graph-container" class="graph-container" style="height: 280px;"></div>
                </div>

                <!-- Chain Drive Tab -->
                <div id="chain-content" class="tab-pane">
                    <h2>Chain Drive Calculation</h2>
                    <div class="form-group" data-admin-label="Chain Type">
                        <label>Chain Size / Type</label>
                        <input type="text" id="chainSizeDisplay" readonly placeholder="Auto-selected based on motor" style="background-color: #e9ecef;">
                    </div>
                    <div class="form-row">
                        <div class="form-group form-col" data-admin-label="Motor Sprocket">
                            <label for="motorTeeth">Motor Sprocket Teeth</label>
                            <input type="number" id="motorTeeth" placeholder="-" readonly style="background-color: #e9ecef;">
                        </div>
                        <div class="form-group form-col" data-admin-label="Plate Wheel">
                            <label for="barrelTeeth">Barrel Plate Wheel Teeth</label>
                            <input type="number" id="barrelTeeth" placeholder="-" readonly style="background-color: #e9ecef;">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group form-col" data-admin-label="Sprocket Diameter">
                            <label>Sprocket Diameter (mm)</label>
                            <input type="number" id="sprocketDiameter" placeholder="-" readonly style="background-color: #e9ecef;">
                        </div>
                        <div class="form-group form-col" data-admin-label="Plate Wheel Diameter">
                            <label>Plate Wheel Diameter (mm)</label>
                            <input type="number" id="plateWheelDiameter" placeholder="-" readonly style="background-color: #e9ecef;">
                        </div>
                    </div>
                    <div class="form-group" data-admin-label="Chain Pitch">
                        <label for="chainPitch">Chain Pitch (mm)</label>
                        <input type="number" id="chainPitch" value="12.7" placeholder="e.g., 12.7 for 08B/1/2 inch">
                        <small style="font-size: 0.8em; color: #555;">Used for graphic sizing.</small>
                    </div>
                    
                    <div class="results" style="border-left-color: #ffc107;">
                        <h3 style="color: #c79100;">Gear Ratio & Strain Analysis</h3>
                        <p>Gear Ratio: <span id="chain-ratio">1 : 1.0</span></p>
                        <p>Torque Required at Barrel: <span id="chain-torque-barrel">0.0</span> Nm</p>
                        <p>Torque Required at Motor: <span id="chain-torque-motor">0.0</span> Nm</p>
                        <hr>
                        <p>Calculated Chain Tension: <span id="chain-tension-n">0.0</span> N (<span id="chain-tension">0.0</span> kgf)</p>
                        <p>Chain Breaking Strain: <span id="chain-breaking-load-n">0.0</span> N</p>
                        <p>Safety Factor (Target > 6.0): <span id="chain-safety-factor">N/A</span></p>
                    </div>
                    
                    <div id="chain-graphic-container" class="graph-container" style="height: 300px; border: 1px solid #e9ecef; border-radius: 4px; background-color: white;"></div>
                </div>

                <!-- Sloping Bottom Lath Tab -->
                <div id="slope-content" class="tab-pane">
                    <h2>Sloping Bottom Lath Design</h2>
                    
                    <div class="form-row">
                         <div class="form-group form-col">
                            <label for="slopeMaterial">Material</label>
                            <select id="slopeMaterial">
                                <option value="7850" selected>Steel (7850 kg/m³)</option>
                                <option value="2700">Aluminium (2700 kg/m³)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-row">
                         <div class="form-group form-col">
                            <label for="slopeLeftHeight">Left Height (mm)</label>
                            <input type="number" id="slopeLeftHeight" min="69" max="400" value="100">
                        </div>
                        <div class="form-group form-col">
                            <label for="slopeRightHeight">Right Height (mm)</label>
                            <input type="number" id="slopeRightHeight" min="69" max="400" value="200">
                        </div>
                    </div>
                     <div class="form-row">
                         <div class="form-group form-col">
                            <label for="slopeFoldLength">Fold Length (mm)</label>
                            <input type="number" id="slopeFoldLength" min="25" value="30">
                            <small>Top & Bottom folds (Default 30mm, Min 25mm)</small>
                        </div>
                        <div class="form-group form-col">
                             <label for="slopeThickness">Sheet Thickness (mm)</label>
                            <input type="number" id="slopeThickness" value="1.5" step="0.1">
                        </div>
                    </div>

                    <div class="results" style="border-left-color: #dc3545; margin-bottom: 1.5em;">
                        <h3 style="color: #dc3545;">Section Details</h3>
                        <p>Calculated Weight: <span id="slope-weight" style="font-weight: bold; font-size: 1.2em;">0.00</span> kg</p>
                        <p style="font-size: 0.9em; color: #555;">(This dead weight is automatically added to the bottom of the curtain for torque/lift calculations)</p>
                    </div>

                    <h3>Front View</h3>
                    <div id="slope-front-view" class="sloping-graphic-container" style="height: 300px;"></div>
                    
                    <h3>Section View (End Profile)</h3>
                    <div id="slope-section-view" class="sloping-graphic-container" style="height: 300px;"></div>

                    <h3>Unfolded Plan View (Manufacturing)</h3>
                    <div id="slope-unfolded-view" class="sloping-graphic-container" style="height: 350px;"></div>
                </div>

                <!-- Admin Tab -->
                <div id="admin-content" class="tab-pane">
                    <h2>Admin Controls</h2>
                    
                    <div class="admin-section">
                        <h3>Import from CSV</h3>
                        <div class="form-group" style="display: flex; align-items: center; gap: 1em;">
                            <input type="file" id="csvFileInput" accept=".csv" style="flex-grow: 1;">
                            <button id="importCsvButton">Import</button>
                        </div>
                        <div id="import-status-admin" style="font-style: italic; color: #555;"></div>
                    </div>

                    <div class="admin-section">
                        <h3>Tab Visibility</h3>
                        <div class="admin-button-group">
                            <button id="tabsSelectAll">Select All</button>
                            <button id="tabsDeselectAll">Deselect All</button>
                        </div>
                        <div id="tab-controls-container" class="admin-controls"></div>
                    </div>

                    <div class="admin-section">
                        <h3>Input Option Visibility</h3>
                         <div class="admin-button-group">
                            <button id="inputsSelectAll">Select All</button>
                            <button id="inputsDeselectAll">Deselect All</button>
                        </div>
                        <div id="input-controls-container" class="admin-controls"></div>
                    </div>

                    <div class="admin-section">
                        <h3>Axle Calculation Settings</h3>
                        <div class="form-group">
                            <label for="axleFixity">Axle Support Condition (%)</label>
                            <input type="number" id="axleFixity" min="0" max="100" value="20">
                            <small style="color: #555; display: block; margin-top: 0.5em;">
                                0% = Simply Supported Beam (Standard, uses 5/384)<br>
                                100% = Fully Fixed/Built-in Beam (Rigid, uses 1/384)<br>
                                Values in between will interpolate the calculation coefficient.
                            </small>
                        </div>
                    </div>

                    <!-- REPORT GENERATION -->
                    <div id="csv-report-section" class="admin-section">
                        <h3>Generate Sizing Report</h3>
                        <p>Configure the report parameters below.</p>
                        
                        <h4>1. Define Size Range (mm)</h4>
                        <div class="report-controls-grid">
                            <div class="form-group">
                                <label for="reportMinWidth">Min Width</label>
                                <input type="number" id="reportMinWidth" value="1000">
                            </div>
                            <div class="form-group">
                                <label for="reportMaxWidth">Max Width</label>
                                <input type="number" id="reportMaxWidth" value="10000">
                            </div>
                             <div class="form-group">
                                <label for="reportInterval">Interval</label>
                                <input type="number" id="reportInterval" value="100">
                            </div>
                            <div class="form-group">
                                <label for="reportMinHeight">Min Height</label>
                                <input type="number" id="reportMinHeight" value="1000">
                            </div>
                            <div class="form-group">
                                <label for="reportMaxHeight">Max Height</label>
                                <input type="number" id="reportMaxHeight" value="10000">
                            </div>
                        </div>

                        <h4>2. Select Shutter Configuration</h4>
                        <div class="form-row">
                            <div class="form-group form-col">
                                <label for="reportLathType">Primary Lath Type</label>
                                <select id="reportLathType">
                                    <option value="">-- Loading... --</option>
                                </select>
                                <small style="color:#666;">Used up to the width limit below.</small>
                            </div>
                            <div class="form-group form-col">
                                <label for="reportLathLimit">Switch Width (mm)</label>
                                <input type="number" id="reportLathLimit" placeholder="e.g. 4000">
                                <small style="color:#666;">Width to switch to Secondary Lath.</small>
                            </div>
                            <div class="form-group form-col">
                                <label for="reportLathType2">Secondary Lath Type</label>
                                <select id="reportLathType2">
                                    <option value="">-- None (Use Primary) --</option>
                                </select>
                                <small style="color:#666;">Used when Width > Switch Width.</small>
                            </div>
                        </div>
                        
                        <div class="form-group" style="margin-bottom: 1em;">
                            <label for="reportPowderCoated" style="display: inline-block; font-weight: 500; cursor: pointer;">
                                <input type="checkbox" id="reportPowderCoated" style="width: auto; margin-right: 8px; vertical-align: middle;">
                                Include Powder Coating (+0.5 kg/m²)
                            </label>
                        </div>

                        <div class="form-row">
                            <div class="form-group form-col">
                                <label for="reportEndlockType">Endlock Type</label>
                                <select id="reportEndlockType">
                                    <option value="">-- Loading... --</option>
                                </select>
                            </div>
                            <div class="form-group form-col">
                                <label for="reportBottomLathType">Bottom Lath Type</label>
                                <select id="reportBottomLathType">
                                    <option value="">-- Loading... --</option>
                                </select>
                            </div>
                        </div>

                        <h4>Optional: Axle Collar Specific Override</h4>
                        <div class="form-row" style="background-color: #f8f9fa; padding: 10px; border-radius: 4px; border: 1px solid #e9ecef;">
                            <div class="form-group form-col">
                                <label for="reportAxleMatch">Axle Diameter to Match (mm)</label>
                                <input type="number" id="reportAxleMatch" placeholder="e.g. 101.6">
                                <small style="color:#666;">Apply collar only to axles of this size.</small>
                            </div>
                            <div class="form-group form-col">
                                <label for="reportCollarOverride">Collar Diameter (mm)</label>
                                <input type="number" id="reportCollarOverride" placeholder="e.g. 120">
                                <small style="color:#666;">Used for Torque calculation instead of Axle Dia.</small>
                            </div>
                        </div>

                        <h4>3. Select Motor Usage Types</h4>
                        <div class="admin-button-group">
                            <button id="reportUsageSelectAll">Select All</button>
                            <button id="reportUsageDeselectAll">Deselect All</button>
                        </div>
                        <div id="report-motor-usage-filter-container" class="report-filter-container">
                            <p>Loading motor data...</p>
                        </div>

                        <h4>4. Select Motor Manufacturers to Include</h4>
                        <div class="admin-button-group">
                            <button id="reportMotorSelectAll">Select All</button>
                            <button id="reportMotorDeselectAll">Deselect All</button>
                        </div>
                        <div id="report-motor-filter-container" class="report-filter-container">
                            <p>Loading motor data...</p>
                        </div>
                        
                        <h4>5. Select Motor Voltages to Include</h4>
                        <div class="admin-button-group">
                            <button id="reportVoltageSelectAll">Select All</button>
                            <button id="reportVoltageDeselectAll">Deselect All</button>
                        </div>
                        <div id="report-motor-voltage-filter-container" class="report-filter-container">
                            <p>Loading motor data...</p>
                        </div>

                        <h4>6. Select Motor Mounting Types to Include</h4>
                        <div class="admin-button-group">
                            <button id="reportMountingSelectAll">Select All</button>
                            <button id="reportMountingDeselectAll">Deselect All</button>
                        </div>
                        <div id="report-motor-mounting-filter-container" class="report-filter-container">
                            <p>Loading motor data...</p>
                        </div>

                        <div class="admin-button-group" style="margin-top: 1.5em;">
                            <button id="generateCsvButton">Generate and Download CSV Report</button>
                        </div>
                        <div id="csv-generation-status" style="font-style: italic; color: #555;"></div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    
    <script>
        let lathData = [], axleData = [], motorData = [], bottomLathData = [], safetyBrakeData = [], endplateData = [], wicketData = [], endlockData = [], guideData = [], chainDriveData = [], bearingData = [];
        let lathImageMap = new Map();
        let safetyBrakeImageMap = new Map();
        let motorImageMap = new Map();
        let currentFilteredMotors = [], currentFilteredEndplates = [];
        let calculatedRotations = 0, maxCoilDiameter = 0;
        let lastTorqueProfile = [];
        let userSelectedAxleIndex = null;
        let visionCalcs = null; 
        
const dom = {};
        [
            'width', 'widthType', 'guideType', 'additionalLength', 'height', 'lathType', 'bottomLathType', 'friction', 'import-status',
            'total-axle-length', 'weight-kg', 'axle-deflection', 'deflection-ratio', 'ratio-paragraph',
            'recommendation-box', 'deflection-graphic-container', 'torque-graph-container', 'lath-count', 'laths-to-lift',
            'max-torque', 'total-revolutions', 'motorMountingType', 'motorVoltageFilter', 'motorManufacturerFilter', 'motorUsageFilter', 'motorManualOverrideFilter', 'motorSelector', 'motor-name', 'motor-torque', 'motor-rpm',
            'motor-driveshaft-dia', 'motor-cycles-per-hour', 'axleType', // axleType now correctly mapped
            'opening-time', 'motor-torque-line', 'axle-weight', 'axle-material-grade', 'moment-of-inertia', 'total-deflection-weight',
            'safety-brake-torque', 'safety-brake-name', 'safety-brake-motor-torque',
            'safetyBrakeSelector', 'shutter-graphic-container', 'safety-brake-driveshaft',
            'curtain-height-extended', 'curtain-height-compressed', 'endplateSelector', 'matSteel', 'matAluminium', 'endplate-name', 'endplate-size',
            'endplate-material', 'max-coil-diameter', 'prev-endplate-name', 'prev-endplate-height', 'next-endplate-name', 'next-endplate-height',
            'width-warning', 'curtain-area', 'lifted-curtain-area', 'printButton', 'dxfButton', 'wicketDoorSelector', 'wicket-door-name', 'wicket-door-height', 'wicket-door-width',
            'wicket-graphic-container', 'laths-at-wicket', 'wicket-lath-height', 'wicket-max-torque', 'wicket-torque-graph-container',
            'addVision', 'vision-slat-options', 'visionLathType', 'visionStartHeight', 'visionPanelHeight', 'axle-safety-factor', 'power-consumed',
            'powderCoated', 'axle-cross-section-container', 'visionLathImageDisplay', 'safety-brake-capacity',
            'safety-brake-image-container', 'safetyBrakeImageDisplay', 'endplate-graphic-container', 'endplate-downward-force',
            'endplate-pullout-force', 'endplate-force-diagram-container', 'includeDeflectionInSizing', 'effective-coil-para', 'effective-coil-diameter', 'collarSize',
            'vision-percentage', 'vision-percentage-para', 'vision-area-m2', 'vision-area-m2-para', 'endlockType', 'endlock-weight',
            'admin-content', 'tab-content', 'importCsvButton', 'shapeCircular', 'shapeOctagonal', 'collar-size-group', 'torque-weight-kg',
            'useCustomLath', 'custom-lath-options', 'customLathWeight', 'customTorqueWeight', 'max-torque-inputs', 'motor-name-inputs', 'motor-torque-inputs', 'motor-torque-line-inputs',
            'width-graphic-container', 'calculated-curtain-width', 'calculated-clear-opening', 'calculated-overall-width', 'axleFixity',
            'reportLathType', 'reportLathLimit', 'reportLathType2', 'chainSizeDisplay', 'motorTeeth', 'barrelTeeth', 'chainPitch',
            'chain-ratio', 'chain-torque-barrel', 'chain-torque-motor', 'chain-tension', 'chain-breaking-load', 'chain-safety-factor', 'chain-graphic-container',
            'sprocketDiameter', 'plateWheelDiameter', 'chain-tension-n', 'chain-breaking-load-n', 'total-applied-friction',
            'motor-image-container', 'motorImageDisplay', 'motor-limit-turns', 'motor-limit-warning',
            'bearing-name', 'bearing-capacity', 'bearing-warning',
            'safety-brake-max-speed', 'actual-barrel-speed', 'safety-brake-speed-warning', 'weld-shaft-dia', 'weld-plate-thickness', 'weld-applied-torque', 'weld-capacity-torque', 'weld-perimeter', 'weld-max-force', 'weld-status', 'weld-graphic-container',
            'isSlopingBottomLath', 'slope-tab-btn', 'slope-content',
            'slopeLeftHeight', 'slopeRightHeight', 'slopeFoldLength', 'slopeThickness',
            'slope-front-view', 'slope-section-view', 'slope-unfolded-view', 'slopeMaterial', 'slope-weight'
        ].forEach(id => {
            const el = document.getElementById(id);
            if (el) dom[id] = el;
        });

        const tabButtons = document.querySelectorAll('.tab-button');
        tabButtons.forEach(button => {
            button.addEventListener('click', () => switchTab(button.dataset.tab));
        });

        // ZOOM LOGIC FOR INPUTS GRAPHIC
        let currentZoom = 100;
        function adjustZoom(amount) {
            currentZoom += amount;
            if (currentZoom < 30) currentZoom = 30; // Minimum zoom
            if (currentZoom > 200) currentZoom = 200; // Maximum zoom
            
            // Adjust Shutter Graphic Container
            const shutterContainer = document.getElementById('shutter-graphic-container');
            const widthContainer = document.getElementById('width-graphic-container');
            const zoomText = document.getElementById('zoom-level-text');

            if(shutterContainer) shutterContainer.style.width = currentZoom + "%";
            if(widthContainer) widthContainer.style.width = currentZoom + "%";
            if(zoomText) zoomText.innerText = currentZoom + "%";
        }

        // --- MAIN INPUT LISTENER ---
        [
            'width', 'widthType', 'guideType', 'additionalLength', 'height', 'friction', 
            'motorMountingType', 'motorVoltageFilter', 'motorManufacturerFilter', 
            'motorUsageFilter', 'motorManualOverrideFilter', 'bottomLathType', 'lathType', 
            'matSteel', 'matAluminium', 'visionLathType', 'visionStartHeight', 
            'visionPanelHeight', 'powderCoated', 'includeDeflectionInSizing', 'collarSize', 
            'endlockType', 'useCustomLath', 'customLathWeight', 'customTorqueWeight', 
            'axleFixity', 'chainPitch', 'slopeLeftHeight', 'slopeRightHeight', 
            'slopeFoldLength', 'slopeThickness', 'slopeMaterial', 'shapeCircular', 'shapeOctagonal'
        ].forEach(id => {
            if (dom[id]) {
                dom[id].addEventListener('input', () => {
                    // Reset manual axle ONLY if shape or weight-bearing dimensions change
                    if (['width', 'height', 'widthType', 'lathType', 'bottomLathType', 'shapeCircular', 'shapeOctagonal', 'powderCoated', 'useCustomLath', 'customLathWeight'].includes(id)) {
                        userSelectedAxleIndex = null;
                    }

                    if (id === 'useCustomLath') {
                        dom['custom-lath-options'].style.display = dom.useCustomLath.checked ? 'block' : 'none';
                        dom.lathType.disabled = dom.useCustomLath.checked;
                    }
                    
                    if (id === 'lathType' && lathData.length > 0) {
                        const selectedLath = lathData[dom.lathType.value];
                        if (selectedLath && selectedLath['Friction %'] !== undefined) {
                            dom.friction.value = selectedLath['Friction %'];
                        }
                    }
                    updateAllCalculations();
                });
            }
        });

// --- MANUAL AXLE OVERRIDE LISTENER ---
if (dom.axleType) {
    dom.axleType.addEventListener('change', (e) => {
        if (e.target.value !== "") {
            userSelectedAxleIndex = parseInt(e.target.value, 10);
            updateAllCalculations();
        }
    });
}

// --- ADD THIS NEW SECTION HERE: MANUAL ENDPLATE OVERRIDE LISTENER ---
if (dom.endplateSelector) {
    dom.endplateSelector.addEventListener('change', () => {
        // This ensures the Inputs page widths and plan graphic 
        // update when you pick a different endplate size/offset
        updateAllCalculations();
    });
}
        
// Sloping Lath Toggle
if (dom.isSlopingBottomLath) {
    dom.isSlopingBottomLath.addEventListener('change', () => {
         const showSlope = dom.isSlopingBottomLath.checked;
         if (dom['slope-tab-btn']) {
             // We use removeProperty to let CSS control the display (flex) or set explicit none
             if (showSlope) {
                 dom['slope-tab-btn'].style.display = 'block'; 
             } else {
                 dom['slope-tab-btn'].style.display = 'none';
             }
         }
         // If we hide the tab while we are on it, switch back to inputs
         if (!showSlope && document.getElementById('slope-content').classList.contains('active')) {
             switchTab('inputs-content');
         }
         updateAllCalculations();
    });
}
// Add Vision Slats Toggle
if (dom.addVision) {
    dom.addVision.addEventListener('change', () => {
        // Show or hide the input options
        dom['vision-slat-options'].style.display = dom.addVision.checked ? 'block' : 'none';
        // Trigger a recalculation
        updateAllCalculations();
    });
}

// Print to PDF Button Logic
if (dom.printButton) {
    dom.printButton.addEventListener('click', () => {
        // 1. Force a sync of data to the summary labels
        syncSummaryForPrint();

        // 2. Check logic for conditional pages
        const wicketActive = dom.wicketDoorSelector.value !== "";
        const slopeActive = dom.isSlopingBottomLath.checked;

        // 3. Apply classes to body for CSS visibility control
        document.body.classList.toggle('hide-wicket-print', !wicketActive);
        document.body.classList.toggle('hide-slope-print', !slopeActive);

        // 4. Trigger print
        window.print(); 
    });
}

// DXF Button Logic
if (dom.dxfButton) {
    dom.dxfButton.addEventListener('click', () => {
        downloadDXF();
    });
}

        function updatePrintStyles() {
            document.querySelectorAll('.tab-pane').forEach(pane => {
                const tabButton = document.querySelector(`.tab-button[data-tab="${pane.id}"]`);
                if (tabButton && tabButton.style.display === 'none') {
                    pane.classList.add('hide-in-print');
                } else {
                    pane.classList.remove('hide-in-print');
                }
            });
        }

        function initializeAdminControls() {
            const tabContainer = document.getElementById('tab-controls-container');
            const inputContainer = document.getElementById('input-controls-container');
            tabContainer.innerHTML = '';
            inputContainer.innerHTML = '';

            document.querySelectorAll('.tab-button').forEach(tab => {
                const tabId = tab.dataset.tab;
                const labelText = tab.textContent.trim();
                const controlItem = document.createElement('div');
                controlItem.className = 'admin-control-item';
                const isChecked = tab.style.display !== 'none';
                controlItem.innerHTML = `<label><input type="checkbox" data-target-tab="${tabId}" ${isChecked ? 'checked' : ''}>${labelText}</label>`;
                tabContainer.appendChild(controlItem);
                controlItem.querySelector('input').addEventListener('change', (e) => {
                    tab.style.display = e.target.checked ? '' : 'none';
                    updatePrintStyles();
                });
            });

            document.querySelectorAll('[data-admin-label]').forEach((inputGroup, index) => {
                const labelText = inputGroup.dataset.adminLabel;
                const groupId = `admin-input-${index}`;
                inputGroup.id = groupId;
                const controlItem = document.createElement('div');
                controlItem.className = 'admin-control-item';
                controlItem.innerHTML = `<label><input type="checkbox" data-target-input="${groupId}" checked>${labelText}</label>`;
                inputContainer.appendChild(controlItem);
                 controlItem.querySelector('input').addEventListener('change', (e) => {
                    inputGroup.style.display = e.target.checked ? '' : 'none';
                });
            });

            const setupBulkActions = (selectAllId, deselectAllId, containerId) => {
                document.getElementById(selectAllId).addEventListener('click', () => {
                    document.querySelectorAll(`#${containerId} input[type="checkbox"]`).forEach(cb => {
                        if (!cb.checked) {
                            cb.checked = true;
                            cb.dispatchEvent(new Event('change'));
                        }
                    });
                });
                document.getElementById(deselectAllId).addEventListener('click', () => {
                    document.querySelectorAll(`#${containerId} input[type="checkbox"]`).forEach(cb => {
                        if (cb.checked) {
                            cb.checked = false;
                            cb.dispatchEvent(new Event('change'));
                        }
                    });
                });
            };

            setupBulkActions('tabsSelectAll', 'tabsDeselectAll', 'tab-controls-container');
            setupBulkActions('inputsSelectAll', 'inputsDeselectAll', 'input-controls-container');
            updatePrintStyles();
        }

        function handleShapeChange() {
            const selectedShape = document.querySelector('input[name="axleShape"]:checked').value;
            const collarGroup = dom['collar-size-group'];
            
            collarGroup.style.display = 'block';
            
            userSelectedAxleIndex = null;
            updateAllCalculations();
        }

// 1. Manually add axleType to the dom object so the listener can find it
        dom.axleType = document.getElementById('axleType');
        
        // 2. Attach the listener directly (Removed the uncalled function wrapper)
        if (dom.axleType) {
            dom.axleType.addEventListener('change', () => {
                if (dom.axleType.value !== "") {
                    userSelectedAxleIndex = dom.axleType.value;
                    updateAllCalculations();
                }
            });
        }
        
        async function processExcelFile(fileData) {
            userSelectedAxleIndex = null; 
            try {
                const workbook = XLSX.read(new Uint8Array(fileData), { type: 'array' });
                const required = {
                    'Lath': ['Name', 'Kgs/ m2', 'Thickness', 'Compressed lath height', 'uncompressed lath height', 'Friction %', 'Max Width', 'Lath image', 'Moment of inertia iy', 'Allowable Bending Stress (MPa)', 'vision percentage', 'min axle diameter'],
                    'Bottom lath': ['Bottom lath name', 'BLath height'],
                    'Axles': ['Name', 'Diameter', 'Wall Thickness', 'Material grade', "Density (kg/m3)", 'Shape'],
                    'Motors': ['Name', 'Torque (Nm) min', 'Torque (Nm) max', 'RPM', 'Mounting type', 'Wattage', 'Voltage', 'Manufacturer', 'Usage type', 'Manual override', 'Motor image', 'Limit turn', 'Driveshaft diameter mm'],
                    'SafetyB': ['Name', 'Max Safety Torque (Nm)', 'Operating Torque (Nm)', 'Driveshaft diameter mm', 'Stop distance', 'SB image', 'Max Locking Speed (RPM)'],
                    'Endplate': ['Name', 'Size', 'Material', 'Fixing holes'],
                    'Wicket doors': ['Name', 'Height', 'Width'],
                    'Endlock': ['Description', 'Weight in grams', 'end lock offset'],
                    'Guides': ['Name', 'Width', 'Penetration'],
                    'Chaindrive': ['Motor Description', 'Sprocket teeth', 'Plate wheel', 'Chain size', 'Chain Breaking Strain in newtons', 'Sprocket diameter', 'Platewheel Diameter'],
                    'Bearings': ['Shaft size in mm', 'Bearing name', 'load capacity in kgs']
                };

                for (const sheetName in required) {
                    if (!workbook.Sheets[sheetName]) {
                        if (sheetName === 'Wicket doors' || sheetName === 'Endlock') {
                            if(sheetName === 'Wicket doors') wicketData = [];
                            if(sheetName === 'Endlock') endlockData = [];
                            continue;
                        }
                        throw new Error(`Required sheet "${sheetName}" not found or is empty in the Excel file.`);
                    }
                    const objectData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
                    switch (sheetName) {
                        case 'Lath': lathData = objectData; break;
                        case 'Bottom lath': bottomLathData = objectData; break;
                        case 'Axles': axleData = objectData; break;
                        case 'Motors': motorData = objectData; break;
                        case 'SafetyB': safetyBrakeData = objectData; break;
                        case 'Endplate': endplateData = objectData; break;
                        case 'Wicket doors': wicketData = objectData; break;
                        case 'Endlock': endlockData = objectData; break;
                        case 'Guides': guideData = objectData; break;
                        case 'Chaindrive': chainDriveData = objectData; break;
                        case 'Bearings': bearingData = objectData; break;
                    }
                }

                lathImageMap.clear(); safetyBrakeImageMap.clear(); motorImageMap.clear();
                const exceljsWorkbook = new ExcelJS.Workbook();
                await exceljsWorkbook.xlsx.load(fileData);

                const lathSheet = exceljsWorkbook.getWorksheet('Lath');
                if (lathSheet) await extractImagesFromSheet(exceljsWorkbook, lathSheet, 'name', 'lath image', lathImageMap);
                
                const safetyBrakeSheet = exceljsWorkbook.getWorksheet('SafetyB');
                if (safetyBrakeSheet) await extractImagesFromSheet(exceljsWorkbook, safetyBrakeSheet, 'name', 'sb image', safetyBrakeImageMap);
                
                const motorSheet = exceljsWorkbook.getWorksheet('Motors');
                if (motorSheet) await extractImagesFromSheet(exceljsWorkbook, motorSheet, 'name', 'motor image', motorImageMap);

                populateDropdown(dom.lathType, lathData, 'Name');
                populateDropdown(dom.guideType, guideData, 'Name');
                const visionSelect = dom.visionLathType;
                visionSelect.innerHTML = `<option value="">-- Select a vision lath --</option>`;
                lathData.forEach((item, index) => {
                    const visionKey = Object.keys(item).find(k => k.toLowerCase().trim() === 'vision percentage');
                    const visionValue = visionKey ? (parseFloat(item[visionKey]) || 0) : 0;
                    if (visionValue > 0) {
                        const option = document.createElement('option');
                        option.value = index;
                        const nameKey = Object.keys(item).find(k => k.toLowerCase().trim() === 'name');
                        option.textContent = item[nameKey];
                        visionSelect.appendChild(option);
                    }
                });
                populateDropdown(dom.bottomLathType, bottomLathData, 'Bottom lath name');
                populateDropdown(dom.endlockType, endlockData, 'Description');
                populateMotorMountingTypes();
                populateMotorVoltageFilter();
                populateMotorManufacturerFilter();
                populateMotorUsageFilter();
                populateMotorManualOverrideFilter();
                populateDropdown(dom.wicketDoorSelector, wicketData, 'Name');

                ['lathType', 'guideType', 'bottomLathType', 'visionLathType', 'motorMountingType', 'motorVoltageFilter', 'motorManufacturerFilter', 'motorUsageFilter', 'motorManualOverrideFilter', 'safetyBrakeSelector', 'axleType', 'endplateSelector', 'wicketDoorSelector', 'endlockType'].forEach(id => {
                    if(dom[id]) dom[id].disabled = false;
                });

                updateSelectedWicketInfo(); 
                dom['import-status'].textContent = 'Successfully loaded data from repository.';
                dom['import-status'].style.color = 'green';
                updateAllCalculations();
                setupReportFilters();

            } catch (error) {
                dom['import-status'].textContent = `Error processing Excel file: ${error.message}`;
                dom['import-status'].style.color = 'red';
                alert(`Error Reading File: ${error.message}`);
                lathData = []; axleData = []; motorData = []; bottomLathData = []; safetyBrakeData = []; endplateData = []; wicketData = []; endlockData = []; guideData = []; chainDriveData = []; bearingData = [];
            }
        }

        function handleCsvImport() {
            const csvFileInput = document.getElementById('csvFileInput');
            const statusDiv = document.getElementById('import-status-admin');
            
            if (!csvFileInput.files || csvFileInput.files.length === 0) {
                statusDiv.textContent = 'Please select a CSV file first.';
                statusDiv.style.color = 'red';
                return;
            }
            const file = csvFileInput.files[0];
            statusDiv.textContent = 'Importing...';
            statusDiv.style.color = '#555';

            Papa.parse(file, {
                header: true, skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        statusDiv.textContent = `Error parsing CSV: ${results.errors[0].message}`;
                        statusDiv.style.color = 'red';
                        return;
                    }
                    if (results.data.length === 0) {
                        statusDiv.textContent = 'CSV file is empty or contains only headers.';
                        statusDiv.style.color = 'red';
                        return;
                    }
                    populateFieldsFromCsv(results.data[0]);
                    statusDiv.textContent = `Successfully imported data for "${results.data[0].Calculation_ID || 'N/A'}".`;
                    statusDiv.style.color = 'green';
                },
                error: function(err) {
                     statusDiv.textContent = `An error occurred: ${err}`;
                     statusDiv.style.color = 'red';
                }
            });
        }

        function populateFieldsFromCsv(data) {
            const getVal = (key) => (data[key] || '').trim();
            const mappings = {
                'Curtain_Width_mm': { id: 'width', type: 'number' },
                'Curtain_Height_mm': { id: 'height', type: 'number' },
                'Additional_Axle_Width_mm': { id: 'additionalLength', type: 'number' },
                'Collar_Size_mm': { id: 'collarSize', type: 'number' },
                'Friction_Allowance_Percent': { id: 'friction', type: 'number' },
                'Vision_Start_Height_mm': { id: 'visionStartHeight', type: 'number' },
                'Vision_Panel_Height_mm': { id: 'visionPanelHeight', type: 'number' },
                'Is_Powder_Coated': { id: 'powderCoated', type: 'checkbox' },
                'Has_Vision_Slats': { id: 'addVision', type: 'checkbox' },
                'Include_Deflection_In_Sizing': { id: 'includeDeflectionInSizing', type: 'checkbox' },
                'Lath_Type_Name': { id: 'lathType', type: 'select' },
                'Endlock_Type_Name': { id: 'endlockType', type: 'select' },
                'Bottom_Lath_Name': { id: 'bottomLathType', type: 'select' },
                'Vision_Lath_Name': { id: 'visionLathType', type: 'select' },
                'Motor_Mounting_Type': { id: 'motorMountingType', type: 'select' },
                'Wicket_Door_Name': { id: 'wicketDoorSelector', type: 'select' },
                'Endplate_Material': { name: 'material', type: 'radio' },
            };

            for (const key in mappings) {
                const value = getVal(key);
                if (value === '') continue;
                const config = mappings[key];
                switch (config.type) {
                    case 'number':
                        const numEl = document.getElementById(config.id);
                        if (numEl) numEl.value = value;
                        break;
                    case 'checkbox':
                        const checkEl = document.getElementById(config.id);
                        if (checkEl) checkEl.checked = (value.toLowerCase() === 'true');
                        break;
                    case 'select':
                        const selectEl = document.getElementById(config.id);
                        if (selectEl) {
                            for (let i = 0; i < selectEl.options.length; i++) {
                                if (selectEl.options[i].text.trim() === value.trim()) {
                                    selectEl.value = selectEl.options[i].value;
                                    break;
                                }
                            }
                        }
                        break;
                    case 'radio':
                        const radioEl = document.querySelector(`input[name="${config.name}"][value="${value}"]`);
                        if (radioEl) radioEl.checked = true;
                        break;
                }
            }
            dom.addVision.dispatchEvent(new Event('change'));
            updateAllCalculations();
            switchTab('inputs-content');
        }

        async function extractImagesFromSheet(workbook, sheet, nameColHeader, imageColHeader, imageMap) {
            let nameCol = -1, imageCol = -1;
            const headerRow = sheet.getRow(1);
            headerRow.eachCell((cell, colNumber) => {
                const headerText = cell.value ? cell.value.toString().toLowerCase().trim() : '';
                if (headerText === nameColHeader) nameCol = colNumber;
                if (headerText === imageColHeader) imageCol = colNumber;
            });

            if (nameCol > 0 && imageCol > 0) {
                const images = sheet.getImages();
                images.forEach(image => {
                    const imageRowNumber = image.range.tl.row + 1;
                    const nameCell = sheet.getCell(imageRowNumber, nameCol);
                    if (nameCell && nameCell.value) {
                        const name = nameCell.value.toString();
                        const imgData = workbook.getImage(image.imageId);
                        const base64Image = btoa(new Uint8Array(imgData.buffer).reduce((data, byte) => data + String.fromCharCode(byte), ''));
                        const imageSrc = `data:image/${imgData.extension};base64,${base64Image}`;
                        imageMap.set(name, imageSrc);
                    }
                });
            }
        }

        function populateMotorMountingTypes() {
            const mountingTypes = [...new Set(motorData.map(motor => motor['Mounting type']))];
            const select = dom.motorMountingType;
            select.innerHTML = '<option value="">-- All Types --</option>';
            mountingTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type; option.textContent = type; select.appendChild(option);
            });
        }
        
        function populateMotorVoltageFilter() {
            let voltageKey = '';
            if (motorData.length > 0) {
                voltageKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'voltage');
            }
            if (!voltageKey) { dom.motorVoltageFilter.parentElement.style.display = 'none'; return; }
            
            const allVoltages = motorData.map(motor => String(motor[voltageKey] || ''))
                                         .join('/')
                                         .split('/')
                                         .map(v => v.trim())
                                         .filter(v => v);
            
            const uniqueVoltageTypes = [...new Set(allVoltages)];
            const select = dom.motorVoltageFilter;
            select.innerHTML = '<option value="">-- All Voltages --</option>';
            uniqueVoltageTypes.sort().forEach(type => {
                const option = document.createElement('option');
                option.value = type; option.textContent = type; select.appendChild(option);
            });
            dom.motorVoltageFilter.parentElement.style.display = 'block';
        }

        function populateMotorManufacturerFilter() {
            let manufacturerKey = '';
            if (motorData.length > 0) {
                manufacturerKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'manufacturer');
            }
            if (!manufacturerKey) { dom.motorManufacturerFilter.parentElement.style.display = 'none'; return; }
            const manufacturers = [...new Set(motorData.map(motor => motor[manufacturerKey]).filter(m => m))];
            const select = dom.motorManufacturerFilter;
            select.innerHTML = '<option value="">-- All Manufacturers --</option>';
            manufacturers.sort().forEach(type => {
                const option = document.createElement('option');
                option.value = type; option.textContent = type; select.appendChild(option);
            });
            dom.motorManufacturerFilter.parentElement.style.display = 'block';
        }

        function populateMotorUsageFilter() {
            let usageKey = '';
            if (motorData.length > 0) {
                usageKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'usage type');
            }
            if (!usageKey) { dom.motorUsageFilter.parentElement.style.display = 'none'; return; }
            const usageTypes = [...new Set(motorData.map(motor => motor[usageKey]).filter(m => m))];
            const select = dom.motorUsageFilter;
            select.innerHTML = '<option value="">-- All Usage Types --</option>';
            usageTypes.sort().forEach(type => {
                const option = document.createElement('option');
                option.value = type; option.textContent = type; select.appendChild(option);
            });
            dom.motorUsageFilter.parentElement.style.display = 'block';
        }

        function populateMotorManualOverrideFilter() {
            let moKey = '';
            if (motorData.length > 0) {
                moKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'manual override');
            }
            if (!moKey) { dom.motorManualOverrideFilter.parentElement.style.display = 'none'; return; }
            const moValues = [...new Set(motorData.map(motor => motor[moKey]).filter(v => v))];
            const select = dom.motorManualOverrideFilter;
            select.innerHTML = '<option value="">-- All --</option>';
            moValues.sort().forEach(val => {
                const option = document.createElement('option');
                option.value = val;
                option.textContent = val;
                select.appendChild(option);
            });
            dom.motorManualOverrideFilter.parentElement.style.display = 'block';
        }

        function getLathWithCustomWeight() {
            let selectedLath = lathData[dom.lathType.value];
            if (!selectedLath) return null;
            if (dom.useCustomLath.checked) {
                const customWeight = parseFloat(dom.customLathWeight.value);
                if (!isNaN(customWeight) && customWeight > 0) {
                    let customLath = { ...selectedLath };
                    const weightKey = Object.keys(customLath).find(k => k.toLowerCase().trim() === 'kgs/ m2');
                    if (weightKey) { customLath[weightKey] = customWeight; } else { customLath['Kgs/ m2'] = customWeight; }
                    return customLath;
                }
            }
            return selectedLath;
        }

function getCalculatedWidths() {
    const inputWidth = parseFloat(dom.width.value) || 0;
    const widthType = dom.widthType.value;
    const selectedGuideIndex = dom.guideType.value;
    const selectedEndplateIndex = dom.endplateSelector.value;
    
    let curtainWidth = 0, clearOpening = 0, overallWidth = 0;
    let epOffset = 0;
    let epSize = 0;

    // 1. Get Endplate Specs (Offset and Size) from current selection
    if (selectedEndplateIndex !== "" && currentFilteredEndplates[selectedEndplateIndex]) {
        const ep = currentFilteredEndplates[selectedEndplateIndex];
        const offsetKey = Object.keys(ep).find(k => k.toLowerCase().trim() === 'offset');
        const sizeKey = Object.keys(ep).find(k => k.toLowerCase().trim() === 'size');
        epOffset = offsetKey ? (parseFloat(ep[offsetKey]) || 0) : 0;
        epSize = sizeKey ? (parseFloat(ep[sizeKey]) || 0) : 0;
    }

    if (selectedGuideIndex !== "" && guideData[selectedGuideIndex]) {
        const guide = guideData[selectedGuideIndex];
        const penetrationKey = Object.keys(guide).find(k => k.toLowerCase().trim() === 'penetration');
        const widthKey = Object.keys(guide).find(k => k.toLowerCase().trim() === 'width');
        const guidePenetration = parseFloat(guide[penetrationKey]) || 0;
        const guideWidth = parseFloat(guide[widthKey]) || 0;

        // Logic based on Width Type selection
        if (widthType === 'overall') {
            overallWidth = inputWidth;
            clearOpening = overallWidth - (2 * guideWidth) - (2 * epOffset);
            curtainWidth = clearOpening + (2 * guidePenetration);
        } else if (widthType === 'clearOpening') {
            clearOpening = inputWidth;
            overallWidth = clearOpening + (2 * guideWidth) + (2 * epOffset);
            curtainWidth = clearOpening + (2 * guidePenetration);
        } else if (widthType === 'curtainWidth') {
            curtainWidth = inputWidth;
            clearOpening = curtainWidth - (2 * guidePenetration);
            overallWidth = clearOpening + (2 * guideWidth) + (2 * epOffset);
        }
    } else {
        curtainWidth = inputWidth; clearOpening = inputWidth; overallWidth = inputWidth;
    }

    dom['calculated-curtain-width'].textContent = curtainWidth.toFixed(0);
    dom['calculated-clear-opening'].textContent = clearOpening.toFixed(0);
    dom['calculated-overall-width'].textContent = overallWidth.toFixed(0);
    
    return { curtainWidth, clearOpening, overallWidth, epOffset, epSize };
}
		
		function syncSummaryForPrint() {
    // Helper to get text from a dropdown safely
    const getSelText = (el) => (el && el.selectedIndex >= 0) ? el.options[el.selectedIndex].text : "Not Selected";

    // Standard Inputs
    document.getElementById('p-width').textContent = dom.width.value || "0";
    document.getElementById('p-width-type').textContent = getSelText(dom.widthType);
    document.getElementById('p-height').textContent = dom.height.value || "0";
    document.getElementById('p-lath').textContent = dom.useCustomLath.checked ? "Custom Weight" : getSelText(dom.lathType);
    document.getElementById('p-bottom-lath').textContent = getSelText(dom.bottomLathType);
    document.getElementById('p-guide').textContent = getSelText(dom.guideType);
    
    // Axle Shape
    const shape = document.querySelector('input[name="axleShape"]:checked');
    document.getElementById('p-axle-shape').textContent = shape ? (shape.value.charAt(0).toUpperCase() + shape.value.slice(1)) : "Circular";
    
    // Powder Coating
    document.getElementById('p-pc').textContent = dom.powderCoated.checked ? "Yes (+0.5 kg/m²)" : "No";

    // Sloping Lath Row
    const slopeRow = document.getElementById('p-slope-row');
    if (dom.isSlopingBottomLath.checked) {
        slopeRow.style.display = "block";
        document.getElementById('p-slope-weight').textContent = document.getElementById('slope-weight').textContent;
    } else {
        slopeRow.style.display = "none";
    }
}

// this will filter the Dropdown of lath type based on the max with allowed for the lath type.


function filterLathDropdownByWidth(curtainWidth) {
    if (!dom.lathType || lathData.length === 0) return;
    
    let currentlySelectedValue = dom.lathType.value;
    let previousSelectedName = "";
    
    if (currentlySelectedValue !== "" && lathData[currentlySelectedValue]) {
        const nameKey = Object.keys(lathData[currentlySelectedValue]).find(k => k.toLowerCase().trim() === 'name') || 'Name';
        previousSelectedName = lathData[currentlySelectedValue][nameKey];
    }

    dom.lathType.innerHTML = '<option value="">-- Select an option --</option>';

    lathData.forEach((lath, index) => {
        const maxWidthKey = Object.keys(lath).find(k => k.toLowerCase().trim() === 'max width');
        const maxWidth = maxWidthKey ? parseFloat(lath[maxWidthKey]) : 0;

        if (maxWidth === 0 || curtainWidth <= maxWidth) {
            const option = document.createElement('option');
            option.value = index;
            const nameKey = Object.keys(lath).find(k => k.toLowerCase().trim() === 'name') || 'Name';
            option.textContent = lath[nameKey];
            dom.lathType.appendChild(option);
        }
    });

    let matchFound = false;
    for (let i = 0; i < dom.lathType.options.length; i++) {
        if (dom.lathType.options[i].textContent === previousSelectedName) {
            dom.lathType.selectedIndex = i;
            matchFound = true;
            break;
        }
    }

    if (!matchFound && !dom.useCustomLath.checked && dom.lathType.options.length > 1) {
        dom.lathType.selectedIndex = 1;
        const selectedLath = lathData[dom.lathType.value];
        if (selectedLath && selectedLath['Friction %'] !== undefined) {
            dom.friction.value = selectedLath['Friction %'];
        }
    }
}

function filterBottomLathDropdown(selectedLathIndex) {
    if (!dom.bottomLathType || !bottomLathData || bottomLathData.length === 0) return;
    
    // 1. Find the "Lath type" header from the selected primary lath
    let targetHeader = "";
    if (selectedLathIndex !== "" && lathData[selectedLathIndex]) {
        const lath = lathData[selectedLathIndex];
        const typeKey = Object.keys(lath).find(k => k.toLowerCase().trim() === 'lath type');
        if (typeKey) {
            targetHeader = String(lath[typeKey]).trim(); 
        }
    }

    // 2. Save the current selection NAME so we don't lose it during the refresh
    let previousSelectedName = "";
    if (dom.bottomLathType.value !== "" && bottomLathData[dom.bottomLathType.value]) {
        const oldNameKey = Object.keys(bottomLathData[dom.bottomLathType.value]).find(k => k.toLowerCase().includes('bottom lath name'));
        previousSelectedName = bottomLathData[dom.bottomLathType.value][oldNameKey];
    }
    
    // 3. Clear the dropdown
    dom.bottomLathType.innerHTML = '<option value="">-- Select an option --</option>';

    bottomLathData.forEach((bLath, index) => {
        // Robust lookup for the "Bottom lath name" column
        const nameKey = Object.keys(bLath).find(k => k.toLowerCase().trim() === 'bottom lath name');
        const bLathName = bLath[nameKey];

        // CRITICAL: Skip any row that doesn't have an actual name (prevents "Bottom Lath 13" etc)
        if (!bLathName || String(bLathName).trim() === "" || String(bLathName).includes("undefined")) {
            return; 
        }

        let isAllowed = false;
        if (targetHeader === "") {
            isAllowed = true; // Show all if no lath type filter is active
        } else {
            // Check the column matching the Lath Type (e.g., "75mm lath")
            const bLathColKey = Object.keys(bLath).find(k => k.trim().toLowerCase() === targetHeader.toLowerCase());
            if (bLathColKey) {
                const cellValue = String(bLath[bLathColKey]).toLowerCase().trim();
                if (cellValue === 'yes' || cellValue === 'y') isAllowed = true;
            }
        }

        if (isAllowed) {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = bLathName;
            dom.bottomLathType.appendChild(option);
        }
    });

    // 4. Restore selection if the name still exists in the filtered list
    if (previousSelectedName) {
        for (let i = 0; i < dom.bottomLathType.options.length; i++) {
            if (dom.bottomLathType.options[i].textContent === previousSelectedName) {
                dom.bottomLathType.selectedIndex = i;
                return;
            }
        }
    }
    
    // Fallback: If nothing is selected, default to the first valid item
    if (dom.bottomLathType.options.length > 1) {
        dom.bottomLathType.selectedIndex = 1;
    }
}

function updateAllCalculations() {
    if (lathData.length === 0) { return; };
    
    const calculatedWidths = getCalculatedWidths();
    const curtainWidth = calculatedWidths.curtainWidth;
    
    // 1. DYNAMIC FILTERS
    filterLathDropdownByWidth(curtainWidth);
    filterBottomLathDropdown(dom.lathType.value);
    
    const effectiveLath = getLathWithCustomWeight();
    
    // 2. IMAGE DISPLAY LOGIC
    const lathImageContainer = document.getElementById('lath-image-container');
    const lathImageDisplay = document.getElementById('lathImageDisplay');
    if (effectiveLath) {
        const selectedLathName = effectiveLath['Name'];
        if (lathImageMap.has(selectedLathName)) {
            lathImageDisplay.src = lathImageMap.get(selectedLathName);
            lathImageContainer.style.display = dom.useCustomLath.checked ? 'none' : 'block';
        } else { lathImageContainer.style.display = 'none'; }
    } else { lathImageContainer.style.display = 'none'; }

    const visionLathImageContainer = document.getElementById('vision-lath-image-container');
    const visionLathImageDisplay = document.getElementById('visionLathImageDisplay');
    if (dom.addVision.checked) {
        const selectedVisionLathIndex = dom.visionLathType.value;
         if (selectedVisionLathIndex && lathData[selectedVisionLathIndex]) {
            const selectedVisionLathName = lathData[selectedVisionLathIndex]['Name'];
            if (lathImageMap.has(selectedVisionLathName)) {
                visionLathImageDisplay.src = lathImageMap.get(selectedVisionLathName);
                visionLathImageContainer.style.display = 'block';
            } else { visionLathImageContainer.style.display = 'none'; }
        } else { visionLathImageContainer.style.display = 'none'; }
    } else { visionLathImageContainer.style.display = 'none'; }

    // 3. WIDTH VALIDATION WARNING
    const widthWarningDiv = dom['width-warning'];
    if (effectiveLath) {
        const maxWidthKey = Object.keys(effectiveLath).find(k => k.toLowerCase().trim() === 'max width');
        const maxWidth = maxWidthKey ? parseFloat(effectiveLath[maxWidthKey]) : 0;
        if (maxWidth > 0 && curtainWidth > maxWidth && !dom.useCustomLath.checked) {
            widthWarningDiv.textContent = `Warning: Calculated curtain width (${curtainWidth.toFixed(0)} mm) exceeds the maximum of ${maxWidth} mm for this lath type.`;
            widthWarningDiv.style.display = 'block';
        } else { widthWarningDiv.style.display = 'none'; }
    } else { widthWarningDiv.style.display = 'none'; }
    
    // 4. CORE CALCULATIONS
    if (axleData.length === 0 || safetyBrakeData.length === 0) {
        drawDeflectionGraphic(0, 0); drawAxleCrossSection(null); calculateSafetyBrakeSelection(); drawShutterGraphic(); return;
    };
    
    const selectedBottomLath = bottomLathData[dom.bottomLathType.value];
    const floorToAxleCenter = parseFloat(dom.height.value) || 0;
    const bottomLathHeight = selectedBottomLath ? (parseFloat(selectedBottomLath['BLath height']) || 0) : 0;
    const travelHeight = floorToAxleCenter - bottomLathHeight;

    // Preliminary run to get rough weight for axle selection
    const estCurtainProps = calculateCurtainProperties(effectiveLath, selectedBottomLath, null, curtainWidth);
    const { bestAxle: tempAxle } = findAndSetBestAxle(estCurtainProps.totalWeight, curtainWidth, false);

    // Final run with estimated axle for radius accuracy
    const finalCurtainProps = calculateCurtainProperties(effectiveLath, selectedBottomLath, tempAxle, curtainWidth);
    const { totalWeight, torqueWeight, fullCurtainLength, visionData, endlockOffsets } = finalCurtainProps;
    visionCalcs = visionData;

    // MOTOR & TORQUE (Sets maxCoilDiameter globally)
    calculateMotorRecommendation(torqueWeight, effectiveLath, tempAxle, travelHeight, curtainWidth);
    
    // ENDPLATE (Requires maxCoilDiameter)
    calculateEndplateRecommendation(); 
    
    // SAFETY BRAKE
    calculateSafetyBrakeSelection();

    // AXLE DEFLECTION (Visual version)
    const { deflection, totalLength, bestAxle } = findAndSetBestAxle(totalWeight, curtainWidth, true);
    drawDeflectionGraphic(totalLength, deflection);
    
    // 5. GRAPHICS & TAB UPDATES
    const selectedEndplateIndex = dom.endplateSelector.value;
    const selectedEndplate = (selectedEndplateIndex !== "" && currentFilteredEndplates[selectedEndplateIndex]) ? currentFilteredEndplates[selectedEndplateIndex] : null;
    
    const selectedGuideIndex = dom.guideType.value;
    const selectedGuide = (selectedGuideIndex !== "" && guideData[selectedGuideIndex]) ? guideData[selectedGuideIndex] : null;

    drawShutterGraphic(curtainWidth, parseFloat(dom.additionalLength.value), parseInt(dom['lath-count'].textContent), effectiveLath, selectedBottomLath, bestAxle, selectedEndplate, selectedGuide, visionData, endlockOffsets);
    drawTopDownWidthGraphic(calculatedWidths, selectedGuide, effectiveLath, parseFloat(dom.additionalLength.value));
    updateWicketCalculationsAndGraphic(endlockOffsets, curtainWidth);
    updateChainCalculations();
    updateWeldCalculations();
    
    if (dom.isSlopingBottomLath.checked) {
        drawSlopingLathGraphics();
    }

    // 6. POPULATE PDF SUMMARY & PRINT PAGE
    syncSummaryForPrint(); 
        
    const getSelText = (el) => el.selectedIndex >= 0 ? el.options[el.selectedIndex].text : "None Selected";
    if (document.getElementById('p-width')) document.getElementById('p-width').textContent = dom.width.value || "0";
    if (document.getElementById('p-width-type')) document.getElementById('p-width-type').textContent = getSelText(dom.widthType);
    if (document.getElementById('p-height')) document.getElementById('p-height').textContent = dom.height.value || "0";
    if (document.getElementById('p-lath')) document.getElementById('p-lath').textContent = getSelText(dom.lathType);
    if (document.getElementById('p-bottom-lath')) document.getElementById('p-bottom-lath').textContent = getSelText(dom.bottomLathType);
    if (document.getElementById('p-guide')) document.getElementById('p-guide').textContent = getSelText(dom.guideType);
    
    const shapeInput = document.querySelector('input[name="axleShape"]:checked');
    if (document.getElementById('p-axle-shape')) document.getElementById('p-axle-shape').textContent = shapeInput ? shapeInput.nextElementSibling.textContent : "Circular";
    if (document.getElementById('p-pc')) document.getElementById('p-pc').textContent = dom.powderCoated.checked ? "Yes" : "No";
}

    // --- SLOPING BOTTOM LATH VISUALIZATIONS ---
	
	
	// --- UPDATED SLOPING BOTTOM LATH DATA LOGIC ---
function getSlopingBottomData() {
    const slopeCheck = document.getElementById('isSlopingBottomLath');
    if (!slopeCheck || !slopeCheck.checked) {
        return { weight: 0, maxH: 0, minH: 0, leftH: 0, rightH: 0, foldL: 0, thickness: 0, type: 'C section' };
    }

    // Identify Sloping Type from the Bottom Lath Data
    const selectedBottomLath = bottomLathData[dom.bottomLathType.value];
    let slopingType = 'C section'; // Default fallback
    if (selectedBottomLath) {
        const typeKey = Object.keys(selectedBottomLath).find(k => k.toLowerCase().trim() === 'sloping type');
        if (typeKey && selectedBottomLath[typeKey]) {
            slopingType = selectedBottomLath[typeKey].toString().trim();
        }
    }

    const width = parseFloat(document.getElementById('calculated-curtain-width').textContent) || 0;
    const leftH = parseFloat(document.getElementById('slopeLeftHeight').value) || 0;
    const rightH = parseFloat(document.getElementById('slopeRightHeight').value) || 0;
    const foldL = parseFloat(document.getElementById('slopeFoldLength').value) || 0;
    const thickness = parseFloat(document.getElementById('slopeThickness').value) || 0;
    const density = parseFloat(document.getElementById('slopeMaterial').value) || 7850;

    const faceArea = width * (leftH + rightH) / 2;
    let totalAreaM2 = 0;

    // Weight Logic based on Type
    if (slopingType === 'L section') {
        // Face area + 1 bottom fold
        totalAreaM2 = (faceArea + (width * foldL)) / 1000000;
    } else if (slopingType === '2 plates') {
        // Face area doubled, no folds
        totalAreaM2 = (faceArea * 2) / 1000000;
    } else { 
        // Standard C section: Face area + 2 folds
        totalAreaM2 = (faceArea + (width * foldL * 2)) / 1000000;
    }

    const weight = totalAreaM2 * (thickness / 1000) * density;
    const maxH = Math.max(leftH, rightH);
    const minH = Math.min(leftH, rightH);

    return { weight, maxH, minH, leftH, rightH, foldL, thickness, type: slopingType };
}

// --- UPDATED SLOPING BOTTOM LATH GRAPHICS ---
function drawSlopingLathGraphics() {
    let width = parseFloat(dom['calculated-curtain-width'].textContent) || 3000;
    const slopingData = getSlopingBottomData();
    if(dom['slope-weight']) {
        dom['slope-weight'].textContent = slopingData.weight.toFixed(2);
    }
    
    let leftH = Math.max(69, Math.min(400, parseFloat(dom.slopeLeftHeight.value) || 100));
    let rightH = Math.max(69, Math.min(400, parseFloat(dom.slopeRightHeight.value) || 200));
    let foldL = Math.max(25, parseFloat(dom.slopeFoldLength.value) || 30);
    let thickness = parseFloat(dom.slopeThickness.value) || 1.5;
    const sType = slopingData.type;

    const svgNS = "http://www.w3.org/2000/svg";
    const createEl = (type, attrs) => {
        const el = document.createElementNS(svgNS, type);
        for(const key in attrs) el.setAttribute(key, attrs[key]);
        return el;
    };

    const createDim = (svg, x1, y1, x2, y2, text, color='#333', offset=0) => {
        const line = createEl('line', {x1, y1, x2, y2, stroke:color, 'stroke-width':1, 'marker-start':'url(#arrow)', 'marker-end':'url(#arrow)'});
        svg.appendChild(line);
        const midX = (x1+x2)/2; const midY = (y1+y2)/2;
        const isVertical = Math.abs(x1 - x2) < 1;
        
        const t = createEl('text', {x:midX, y:midY, 'text-anchor':'middle', 'font-family':'sans-serif', 'font-size':'11px', 'fill': color, 'font-weight': 'bold'});
        if (isVertical) {
            t.setAttribute('transform', `rotate(-90, ${midX}, ${midY})`);
            t.setAttribute('dy', offset ? String(offset) : '-5');
        } else {
            t.setAttribute('dy', '-5');
        }
        t.textContent = text;
        svg.appendChild(t);
    };

    // 1. FRONT VIEW
    const frontContainer = dom['slope-front-view']; frontContainer.innerHTML = '';
    const fSvg = createEl('svg', {viewBox:'0 0 600 300', width:'100%', height:'100%'});
    const defs = createEl('defs', {});
    const marker = createEl('marker', {id:'arrow', viewBox:'0 0 10 10', refX:5, refY:5, markerWidth:6, markerHeight:6, orient:'auto-start-reverse'});
    marker.appendChild(createEl('path', {d:'M0,0 L10,5 L0,10 z', fill:'#333'}));
    defs.appendChild(marker); fSvg.appendChild(defs);

    const pad = 50; const availW = 600 - 2*pad; const availH = 300 - 2*pad;
    const scale = Math.min(availW / width, availH / Math.max(leftH, rightH));
    const wScaled = width * scale; const lhScaled = leftH * scale; const rhScaled = rightH * scale;

    const polyPoints = `${pad},${pad} ${pad + wScaled},${pad} ${pad + wScaled},${pad + rhScaled} ${pad},${pad + lhScaled}`;
    fSvg.appendChild(createEl('polygon', {points:polyPoints, fill:'#e9ecef', stroke:'#333', 'stroke-width':(sType === '2 plates' ? 4 : 2)}));
    
    // Annotation for 2 Plates
    if (sType === '2 plates') {
        const infoText = createEl('text', {x: pad + wScaled/2, y: pad + Math.max(lhScaled, rhScaled) + 25, 'text-anchor':'middle', 'font-family':'sans-serif', 'font-size':'12px', 'fill':'#d93025', 'font-weight':'bold'});
        infoText.textContent = "STYLE: 2 x REINFORCING PLATES (MIRRORED)";
        fSvg.appendChild(infoText);
    }

    createDim(fSvg, pad, pad - 20, pad + wScaled, pad - 20, `Width: ${width} mm`);
    createDim(fSvg, pad - 20, pad, pad - 20, pad + lhScaled, `LH: ${leftH}`);
    createDim(fSvg, pad + wScaled + 20, pad, pad + wScaled + 20, pad + rhScaled, `RH: ${rightH}`);
    frontContainer.appendChild(fSvg);

    // 2. SECTION VIEW
    const sectContainer = dom['slope-section-view']; sectContainer.innerHTML = '';
    const sSvg = createEl('svg', {viewBox:'0 0 300 300', width:'100%', height:'100%'});
    sSvg.appendChild(defs.cloneNode(true));
    
    const sScale = 3; 
    const foldW = foldL * sScale;
    const faceH = 150; 
    const thick = thickness * sScale;
    const ir = 3 * sScale; 
    const er = ir + thick;
    const sCx = 150 - foldW/2; 
    const sCy = 150 - faceH/2;

    let sectionPath = "";

    if (sType === 'C section') {
        const p1 = `${sCx + foldW},${sCy}`;
        const p2 = `${sCx + er},${sCy}`;
        const arc1 = `A ${er} ${er} 0 0 0 ${sCx} ${sCy + er}`;
        const p3 = `${sCx},${sCy + faceH - er}`;
        const arc2 = `A ${er} ${er} 0 0 0 ${sCx + er} ${sCy + faceH}`;
        const p4 = `${sCx + foldW},${sCy + faceH}`;
        const p5 = `${sCx + foldW},${sCy + faceH - thick}`;
        const p6 = `${sCx + er},${sCy + faceH - thick}`;
        const arc3 = `A ${ir} ${ir} 0 0 1 ${sCx + thick} ${sCy + faceH - er}`;
        const p7 = `${sCx + thick},${sCy + er}`;
        const arc4 = `A ${ir} ${ir} 0 0 1 ${sCx + er} ${sCy + thick}`;
        const p8 = `${sCx + foldW},${sCy + thick}`;
        sectionPath = `M ${p1} L ${p2} ${arc1} L ${p3} ${arc2} L ${p4} L ${p5} L ${p6} ${arc3} L ${p7} ${arc4} L ${p8} Z`;
    } else if (sType === 'L section') {
        const p1 = `${sCx},${sCy}`;
        const p2 = `${sCx + thick},${sCy}`;
        const p3 = `${sCx + thick},${sCy + faceH - er}`;
        const arc1 = `A ${ir} ${ir} 0 0 0 ${sCx + er} ${sCy + faceH - thick}`;
        const p4 = `${sCx + foldW},${sCy + faceH - thick}`;
        const p5 = `${sCx + foldW},${sCy + faceH}`;
        const p6 = `${sCx + er},${sCy + faceH}`;
        const arc2 = `A ${er} ${er} 0 0 1 ${sCx},${sCy + faceH - er}`;
        sectionPath = `M ${p1} L ${p2} L ${p3} ${arc1} L ${p4} L ${p5} L ${p6} ${arc2} Z`;
    } else if (sType === '2 plates') {
        // Draw two parallel vertical plates
        const p1 = `${sCx},${sCy} L ${sCx + thick},${sCy} L ${sCx + thick},${sCy + faceH} L ${sCx},${sCy + faceH} Z`;
        const p2 = `${sCx + 30},${sCy} L ${sCx + 30 + thick},${sCy} L ${sCx + 30 + thick},${sCy + faceH} L ${sCx + 30},${sCy + faceH} Z`;
        sectionPath = `M ${p1} M ${p2}`;
        createDim(sSvg, sCx, sCy - 20, sCx + 30 + thick, sCy - 20, `2 x Side Plates`);
    }

    sSvg.appendChild(createEl('path', {d:sectionPath, fill:'#adb5bd', stroke:'#343a40', 'stroke-width':1}));
    
    if (sType !== '2 plates') {
        createDim(sSvg, sCx, sCy - 20, sCx + foldW, sCy - 20, `${sType === 'L section' ? 'Bottom Fold Only' : 'Top & Bottom Folds'}`);
    }
    
    sectContainer.appendChild(sSvg);

    // 3. UNFOLDED VIEW
    const planContainer = dom['slope-unfolded-view']; planContainer.innerHTML = '';
    const pSvg = createEl('svg', {viewBox:'0 0 600 350', width:'100%', height:'100%'});
    pSvg.appendChild(defs.cloneNode(true));

    // For "2 plates", we just show one template but mark it "x 2"
    let totalUnfoldedH_L = leftH;
    let totalUnfoldedH_R = rightH;
    if (sType === 'C section') {
        totalUnfoldedH_L += (2 * foldL);
        totalUnfoldedH_R += (2 * foldL);
    } else if (sType === 'L section') {
        totalUnfoldedH_L += foldL;
        totalUnfoldedH_R += foldL;
    }

    const pScale = Math.min((600 - 2*pad) / width, (350 - 2*pad) / Math.max(totalUnfoldedH_L, totalUnfoldedH_R));
    const wP = width * pScale; 
    const fP = foldL * pScale;
    const lhP = leftH * pScale; 
    const rhP = rightH * pScale;
    
    let yStart = pad;
    let points = "";

    if (sType === 'C section') {
        points = `M ${pad},${pad} L ${pad+wP},${pad} L ${pad+wP},${pad+fP+rhP+fP} L ${pad},${pad+fP+lhP+fP} Z`;
        pSvg.appendChild(createEl('path', {d:points, fill:'#fff', stroke:'#333', 'stroke-width':2}));
        pSvg.appendChild(createEl('path', {d:`M ${pad},${pad+fP} L ${pad + wP},${pad+fP}`, fill:'none', stroke:'#555', 'stroke-dasharray':'5,5'}));
        pSvg.appendChild(createEl('path', {d:`M ${pad},${pad+fP+lhP} L ${pad + wP},${pad+fP+rhP}`, fill:'none', stroke:'#555', 'stroke-dasharray':'5,5'}));
    } else if (sType === 'L section') {
        points = `M ${pad},${pad} L ${pad+wP},${pad} L ${pad+wP},${pad+rhP+fP} L ${pad},${pad+lhP+fP} Z`;
        pSvg.appendChild(createEl('path', {d:points, fill:'#fff', stroke:'#333', 'stroke-width':2}));
        pSvg.appendChild(createEl('path', {d:`M ${pad},${pad+lhP} L ${pad + wP},${pad+rhP}`, fill:'none', stroke:'#555', 'stroke-dasharray':'5,5'}));
    } else {
        points = `M ${pad},${pad} L ${pad+wP},${pad} L ${pad+wP},${pad+rhP} L ${pad},${pad+lhP} Z`;
        pSvg.appendChild(createEl('path', {d:points, fill:'#fff', stroke:'#333', 'stroke-width':2}));
        const x2Label = createEl('text', {x: pad + wP/2, y: pad + Math.max(lhP, rhP) + 35, 'text-anchor':'middle', 'font-family':'sans-serif', 'font-size':'14px', 'fill':'#000', 'font-weight':'bold'});
        x2Label.textContent = "QUANTITY: 2 OFF";
        pSvg.appendChild(x2Label);
    }

    createDim(pSvg, pad, pad - 20, pad + wP, pad - 20, `Cut Width: ${width} mm`);
    createDim(pSvg, pad - 30, pad, pad - 30, pad + (pScale * totalUnfoldedH_L), `H: ${totalUnfoldedH_L}mm`);
    createDim(pSvg, pad + wP + 30, pad, pad + wP + 30, pad + (pScale * totalUnfoldedH_R), `H: ${totalUnfoldedH_R}mm`);

    planContainer.appendChild(pSvg);
}
        
function updateChainCalculations() {
    // 1. Get required values from the DOM
    // We use the textContent from the "max-torque" result and the value from the plate wheel diameter input
    const maxTorqueBarrel = parseFloat(dom['max-torque'].textContent) || 0;
    const plateWheelDia = parseFloat(dom.plateWheelDiameter.value) || 0;
    const motorTeeth = parseInt(dom.motorTeeth.value) || 0;
    const barrelTeeth = parseInt(dom.barrelTeeth.value) || 0;
    const chainPitch = parseFloat(dom.chainPitch.value) || 12.7;

    // 2. Safety Check: If data is missing, reset displays and exit
    if (maxTorqueBarrel <= 0 || plateWheelDia <= 0 || motorTeeth <= 0 || barrelTeeth <= 0) {
        ['chain-ratio', 'chain-torque-barrel', 'chain-torque-motor', 'chain-tension-n', 'chain-tension', 'chain-breaking-load-n', 'chain-safety-factor'].forEach(id => { 
            if(dom[id]) dom[id].textContent = id.includes('ratio') ? '1 : 1.0' : (id.includes('factor') ? 'N/A' : '0.0'); 
        });
        if(dom['chain-safety-factor']) dom['chain-safety-factor'].className = "";
        drawChainGraphic(0, 0, 0, 0, 0, 0, 0);
        return;
    }

    // 3. Gear Ratio & Motor Torque
    const ratio = barrelTeeth / motorTeeth;
    const motorTorque = maxTorqueBarrel / ratio;

    dom['chain-ratio'].textContent = `1 : ${ratio.toFixed(2)}`;
    dom['chain-torque-barrel'].textContent = maxTorqueBarrel.toFixed(1);
    dom['chain-torque-motor'].textContent = motorTorque.toFixed(1);

    // 4. CALCULATE CHAIN TENSION (Newtons)
    // Formula: Tension (N) = Torque (Nm) / Radius (m)
    // Radius (m) = (Diameter (mm) / 2) / 1000
    const radiusM = (plateWheelDia / 2) / 1000;
    const tensionN = maxTorqueBarrel / radiusM;
    const tensionKg = tensionN / 9.81;

    dom['chain-tension-n'].textContent = tensionN.toFixed(1);
    dom['chain-tension'].textContent = tensionKg.toFixed(1);

    // 5. SAFETY FACTOR ANALYSIS
    let breakingStrainN = 0;
    if (dom.chainSizeDisplay.dataset.breakingStrain) {
        breakingStrainN = parseFloat(dom.chainSizeDisplay.dataset.breakingStrain);
    }

    dom['chain-breaking-load-n'].textContent = breakingStrainN > 0 ? breakingStrainN.toFixed(0) : '0';
    
    const safetyFactorEl = dom['chain-safety-factor'];
    if (breakingStrainN > 0 && tensionN > 0) {
        const safetyFactor = breakingStrainN / tensionN;
        safetyFactorEl.textContent = safetyFactor.toFixed(2);
        
        // Target is > 6.0 as requested
        if (safetyFactor < 6.0) { 
            safetyFactorEl.className = "warning-text"; // Red
            safetyFactorEl.textContent += " (FAIL < 6:1)";
        } else {
            safetyFactorEl.className = "option-pass"; // Green
            safetyFactorEl.textContent += " (PASS)";
        }
    } else {
        safetyFactorEl.textContent = 'N/A';
        safetyFactorEl.className = "";
    }

    // 6. Update Graphics
    const motorDriveshaft = parseFloat(dom['motor-driveshaft-dia'].textContent) || 0;
    const sprocketDia = parseFloat(dom.sprocketDiameter.value) || 0;
    let axleDia = 0;
    const selectedAxleIndex = dom.axleType.value;
    if (selectedAxleIndex !== "" && axleData[selectedAxleIndex]) {
         axleDia = parseFloat(axleData[selectedAxleIndex].Diameter) || 0;
    }

    drawChainGraphic(motorTeeth, barrelTeeth, chainPitch, sprocketDia, plateWheelDia, motorDriveshaft, axleDia);
}



function drawChainGraphic(motorTeeth, barrelTeeth, pitch, sprocketDia, plateWheelDia, driveshaftDia, axleDia) {
            const container = dom['chain-graphic-container']; container.innerHTML = '';
            if (!motorTeeth || !barrelTeeth || !pitch) return;

            const pdMotor = (sprocketDia > 0) ? sprocketDia : pitch / Math.sin(Math.PI / motorTeeth);
            const pdBarrel = (plateWheelDia > 0) ? plateWheelDia : pitch / Math.sin(Math.PI / barrelTeeth);

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            const width = 550; const height = 300;
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
            
            const maxDia = Math.max(pdMotor, pdBarrel);
            const padding = 50;
            const centerDist = maxDia * 1.5 + 100; 
            const totalGraphicWidth = centerDist + (pdMotor/2) + (pdBarrel/2);
            const verticalSpaceNeeded = maxDia + 100;
            const scale = Math.min((width - 2*padding) / totalGraphicWidth, (height - 100) / verticalSpaceNeeded);
            const r1 = (pdMotor / 2) * scale;
            const r2 = (pdBarrel / 2) * scale;
            const d = centerDist * scale;
            const c1x = padding + r1; const c1y = height / 2;
            const c2x = c1x + d; const c2y = height / 2;

            const defs = document.createElementNS(svgNS, 'defs');
            const marker = document.createElementNS(svgNS, 'marker'); marker.setAttribute('id', 'dim-arrow-chain'); marker.setAttribute('viewBox', '0 0 10 10'); marker.setAttribute('refX', '5'); marker.setAttribute('refY', '5'); marker.setAttribute('markerWidth', '4'); marker.setAttribute('markerHeight', '4'); marker.setAttribute('orient', 'auto-start-reverse');
            const arrowPath = document.createElementNS(svgNS, 'path'); arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); arrowPath.setAttribute('fill', '#343a40'); marker.appendChild(arrowPath); defs.appendChild(marker); svg.appendChild(defs);

            const createGearPath = (cx, cy, radius, teeth) => {
                const outerR = radius + (4 * scale); 
                const innerR = radius - (4 * scale); 
                let path = "";
                const step = (Math.PI * 2) / teeth;
                for (let i = 0; i < teeth; i++) {
                    const angle = i * step;
                    const halfStep = step / 4;
                    const a1 = angle - halfStep;
                    path += (i===0 ? "M" : "L") + (cx + Math.cos(a1)*innerR) + "," + (cy + Math.sin(a1)*innerR);
                    const a2 = angle - halfStep/2;
                    path += "L" + (cx + Math.cos(a2)*outerR) + "," + (cy + Math.sin(a2)*outerR);
                    const a3 = angle + halfStep/2;
                    path += "L" + (cx + Math.cos(a3)*outerR) + "," + (cy + Math.sin(a3)*outerR);
                    const a4 = angle + halfStep;
                    path += "L" + (cx + Math.cos(a4)*innerR) + "," + (cy + Math.sin(a4)*innerR);
                }
                path += "Z";
                return path;
            };

            const gear1 = document.createElementNS(svgNS, 'path');
            gear1.setAttribute('d', createGearPath(c1x, c1y, r1, motorTeeth));
            gear1.setAttribute('class', 'sprocket-wheel');
            svg.appendChild(gear1);

            const gear2 = document.createElementNS(svgNS, 'path');
            gear2.setAttribute('d', createGearPath(c2x, c2y, r2, barrelTeeth));
            gear2.setAttribute('class', 'sprocket-wheel');
            svg.appendChild(gear2);

            if(driveshaftDia > 0) {
                const rShaft = (driveshaftDia / 2) * scale;
                const shaft = document.createElementNS(svgNS, 'circle');
                shaft.setAttribute('cx', c1x); shaft.setAttribute('cy', c1y);
                shaft.setAttribute('r', rShaft);
                shaft.setAttribute('class', 'chain-driveshaft');
                svg.appendChild(shaft);
                
                const labelY = c1y - r1 - 35;
                const line = document.createElementNS(svgNS, 'line');
                line.setAttribute('x1', c1x); line.setAttribute('y1', c1y - rShaft);
                line.setAttribute('x2', c1x - 20); line.setAttribute('y2', labelY + 5);
                line.setAttribute('class', 'leader-line');
                svg.appendChild(line);
                
                const textDS = document.createElementNS(svgNS, 'text');
                textDS.setAttribute('x', c1x - 25); textDS.setAttribute('y', labelY);
                textDS.setAttribute('class', 'graph-data-label');
                textDS.setAttribute('text-anchor', 'end');
                textDS.textContent = `Ø${driveshaftDia} Driveshaft`;
                svg.appendChild(textDS);
            }

            // Draw Axle on Barrel (Large Gear)
            if (axleDia > 0) {
                 const rAxle = (axleDia / 2) * scale;
                 
                 // Axle Circle
                 const axleCircle = document.createElementNS(svgNS, 'circle');
                 axleCircle.setAttribute('cx', c2x); axleCircle.setAttribute('cy', c2y);
                 axleCircle.setAttribute('r', rAxle);
                 axleCircle.setAttribute('fill', '#e9ecef');
                 axleCircle.setAttribute('stroke', '#495057');
                 axleCircle.setAttribute('stroke-width', '1.5');
                 svg.appendChild(axleCircle);

                 // Axle Label
                 const labelY = c2y - r2 - 35; // Put label roughly above
                 // Leader Line
                 const line = document.createElementNS(svgNS, 'line');
                 line.setAttribute('x1', c2x); line.setAttribute('y1', c2y - rAxle);
                 line.setAttribute('x2', c2x + 20); line.setAttribute('y2', labelY + 5);
                 line.setAttribute('class', 'leader-line');
                 svg.appendChild(line);

                 const textAxle = document.createElementNS(svgNS, 'text');
                 textAxle.setAttribute('x', c2x + 25); textAxle.setAttribute('y', labelY);
                 textAxle.setAttribute('class', 'graph-data-label');
                 textAxle.setAttribute('text-anchor', 'start');
                 textAxle.textContent = `Ø${axleDia} Axle`;
                 svg.appendChild(textAxle);
            } else {
                 // Fallback center dot if no axle
                 const barrelCenter = document.createElementNS(svgNS, 'circle');
                 barrelCenter.setAttribute('cx', c2x); barrelCenter.setAttribute('cy', c2y);
                 barrelCenter.setAttribute('r', 3);
                 barrelCenter.setAttribute('fill', '#495057');
                 svg.appendChild(barrelCenter);
            }

            // Chain Logic corrected for alignment
            if (d > Math.abs(r2 - r1)) {
                const alpha = Math.asin((r2 - r1) / d);
                // Shift tangent points left by using minus for sin(alpha) when large gear is on right
                const t1x_t = c1x - r1 * Math.sin(alpha);
                const t1y_t = c1y - r1 * Math.cos(alpha);
                const t1x_b = c1x - r1 * Math.sin(alpha); 
                const t1y_b = c1y + r1 * Math.cos(alpha);
                
                const t2x_t = c2x - r2 * Math.sin(alpha);
                const t2y_t = c2y - r2 * Math.cos(alpha);
                const t2x_b = c2x - r2 * Math.sin(alpha);
                const t2y_b = c2y + r2 * Math.cos(alpha);
                
                const path = document.createElementNS(svgNS, 'path');
                const dPath = `M ${t1x_t},${t1y_t} 
                               L ${t2x_t},${t2y_t} 
                               A ${r2},${r2} 0 1 1 ${t2x_b},${t2y_b} 
                               L ${t1x_b},${t1y_b} 
                               A ${r1},${r1} 0 0 1 ${t1x_t},${t1y_t}`;
                
                const chainBg = document.createElementNS(svgNS, 'path');
                chainBg.setAttribute('d', dPath);
                chainBg.setAttribute('class', 'chain-path-bg');
                svg.appendChild(chainBg);

                path.setAttribute('d', dPath);
                path.setAttribute('class', 'chain-path');
                svg.appendChild(path);
            }

            const text1 = document.createElementNS(svgNS, 'text');
            text1.setAttribute('x', c1x); text1.setAttribute('y', c1y + r1 + 25); 
            text1.setAttribute('class', 'graph-text'); 
            text1.style.fontWeight = "bold";
            text1.textContent = "Motor Sprocket";
            svg.appendChild(text1);

            const sub1 = document.createElementNS(svgNS, 'text');
            sub1.setAttribute('x', c1x); sub1.setAttribute('y', c1y + r1 + 40); 
            sub1.setAttribute('class', 'graph-data-label'); 
            sub1.textContent = `${motorTeeth} Teeth`;
            svg.appendChild(sub1);
            
            const sub1a = document.createElementNS(svgNS, 'text');
            sub1a.setAttribute('x', c1x); sub1a.setAttribute('y', c1y + r1 + 52); 
            sub1a.setAttribute('class', 'graph-data-label'); 
            sub1a.textContent = `Ø${pdMotor.toFixed(1)} mm`;
            svg.appendChild(sub1a);

            const text2 = document.createElementNS(svgNS, 'text');
            text2.setAttribute('x', c2x); text2.setAttribute('y', c2y + r2 + 25); 
            text2.setAttribute('class', 'graph-text'); 
            text2.style.fontWeight = "bold";
            text2.textContent = "Barrel Plate Wheel";
            svg.appendChild(text2);

            const sub2 = document.createElementNS(svgNS, 'text');
            sub2.setAttribute('x', c2x); sub2.setAttribute('y', c2y + r2 + 40); 
            sub2.setAttribute('class', 'graph-data-label'); 
            sub2.textContent = `${barrelTeeth} Teeth`;
            svg.appendChild(sub2);
            
            const sub2a = document.createElementNS(svgNS, 'text');
            sub2a.setAttribute('x', c2x); sub2a.setAttribute('y', c2y + r2 + 52); 
            sub2a.setAttribute('class', 'graph-data-label'); 
            sub2a.textContent = `Ø${pdBarrel.toFixed(1)} mm`;
            svg.appendChild(sub2a);

            // Updated Dimension drawer to include text
            const drawDim = (cx, cy, r, labelText) => {
                const lineY = cy - r - 10;
                const line = document.createElementNS(svgNS, 'line');
                line.setAttribute('x1', cx - r); line.setAttribute('y1', lineY);
                line.setAttribute('x2', cx + r); line.setAttribute('y2', lineY);
                line.setAttribute('class', 'dimension-line');
                line.setAttribute('marker-start', 'url(#dim-arrow-chain)');
                line.setAttribute('marker-end', 'url(#dim-arrow-chain)');
                svg.appendChild(line);
                
                const l1 = document.createElementNS(svgNS, 'line');
                l1.setAttribute('x1', cx - r); l1.setAttribute('y1', cy);
                l1.setAttribute('x2', cx - r); l1.setAttribute('y2', lineY);
                l1.setAttribute('class', 'leader-line'); svg.appendChild(l1);
                
                const l2 = document.createElementNS(svgNS, 'line');
                l2.setAttribute('x1', cx + r); l1.setAttribute('y1', cy);
                l2.setAttribute('x2', cx + r); l2.setAttribute('y2', lineY);
                l2.setAttribute('class', 'leader-line'); svg.appendChild(l2);

                if (labelText) {
                    const txt = document.createElementNS(svgNS, 'text');
                    txt.setAttribute('x', cx); txt.setAttribute('y', lineY - 5);
                    txt.setAttribute('class', 'dim-text-force-diagram'); // Reuse style
                    txt.setAttribute('text-anchor', 'middle');
                    txt.textContent = labelText;
                    svg.appendChild(txt);
                }
            };

            drawDim(c1x, c1y, r1, `Ø${pdMotor.toFixed(1)}`);
            drawDim(c2x, c2y, r2, `Ø${pdBarrel.toFixed(1)}`);

            container.appendChild(svg);
        }

        function findAndSetBestAxle(totalWeightKgs, curtainWidth, drawGraphics = true) {
    const width = curtainWidth || 0;
    const additionalLength = parseFloat(dom.additionalLength.value) || 0;
    const totalLength = width + additionalLength;
    
    if (drawGraphics) dom['total-axle-length'].textContent = totalLength.toFixed(0);

    const selectedShape = document.querySelector('input[name="axleShape"]:checked')?.value || 'circular';
    
    // Safety check for empty data
    if (totalLength <= 0 || axleData.length === 0) {
        if (drawGraphics) {
            ['axle-deflection', 'deflection-ratio', 'axle-weight', 'moment-of-inertia', 'total-deflection-weight', 'axle-safety-factor'].forEach(id => dom[id].textContent = '0.00');
            dom['axle-material-grade'].textContent = 'N/A'; 
            dom.axleType.innerHTML = '<option>-- No data --</option>'; 
            drawAxleCrossSection(null);
        }
        return { bestAxle: null, deflection: 0, totalLength: 0 };
    }

    // 1. Filter axles by the selected shape (Circular/Octagonal)
    const axlesForShape = axleData.map((axle, index) => ({ ...axle, originalIndex: index })).filter(axle => {
        const axleShapeInSheet = (axle.Shape || 'circular').toLowerCase().trim();
        return axleShapeInSheet === selectedShape; 
    });

    if (axlesForShape.length === 0) {
        if (drawGraphics) {
            dom.axleType.innerHTML = `<option>-- No suitable ${selectedShape} axles available --</option>`;
            drawAxleCrossSection(null);
        }
        return { bestAxle: null, deflection: 0, totalLength: 0 };
    }

    // 2. Calculate required deflection ratio based on width
    let requiredRatio = 400;
    if (curtainWidth > 10000) requiredRatio = 800;
    else if (curtainWidth > 8000) requiredRatio = 600;

    // 3. Find the auto-recommended axle (first one that passes)
    let recommendedAxleOriginalIndex = -1;
    const axlePerformances = [];
    
    axlesForShape.forEach(currentAxle => {
        const perf = performDeflectionCalc(totalWeightKgs, currentAxle, totalLength, curtainWidth);
        axlePerformances.push({ ...perf, originalIndex: currentAxle.originalIndex });
        
        const passesTest = perf.ratio >= requiredRatio && perf.deflection <= 17;
        if (passesTest && recommendedAxleOriginalIndex === -1) {
            recommendedAxleOriginalIndex = currentAxle.originalIndex;
        }
    });

    // Fallback if none pass
    if (recommendedAxleOriginalIndex === -1) recommendedAxleOriginalIndex = axlesForShape[0].originalIndex;

    // 4. DECIDE WHICH AXLE TO USE: Manual Override vs Auto-Recommend
    let finalSelectedOriginalIndex;
    
    if (userSelectedAxleIndex !== null) {
        // Verify user selection still exists in the current shape filter
        const stillExists = axlesForShape.some(a => a.originalIndex == userSelectedAxleIndex);
        finalSelectedOriginalIndex = stillExists ? userSelectedAxleIndex : recommendedAxleOriginalIndex;
    } else {
        finalSelectedOriginalIndex = recommendedAxleOriginalIndex;
    }

    // 5. Update the Dropdown UI
    if (drawGraphics) {
        const select = dom.axleType; 
        select.innerHTML = '';
        axlesForShape.forEach((axle, index) => {
            const perf = axlePerformances[index];
            const option = document.createElement('option');
            option.value = axle.originalIndex;
            
            let optionText = axle['Name'];
            if (axle['Alternate name']) optionText += ` (${axle['Alternate name']})`;
            option.textContent = optionText;

            const passesTest = perf.ratio >= requiredRatio && perf.deflection <= 17;
            option.classList.toggle('option-pass', passesTest);
            option.classList.toggle('option-fail', !passesTest);
            select.appendChild(option);
        });
        
        // Lock the select to our final choice
        select.value = finalSelectedOriginalIndex;
        select.disabled = false; 
    }

    // 6. Finalize calculations for the selected axle
    const selectedAxleData = axleData[finalSelectedOriginalIndex];
    const finalPerformance = performDeflectionCalc(totalWeightKgs, selectedAxleData, totalLength, curtainWidth);
    
    if (drawGraphics) {
        dom['axle-weight'].textContent = finalPerformance.axleWeight.toFixed(2);
        const totalDeflectionWeight = totalWeightKgs + finalPerformance.axleWeight;
        dom['total-deflection-weight'].textContent = totalDeflectionWeight.toFixed(2);
        dom['axle-material-grade'].textContent = finalPerformance.materialGradeValue ? `${finalPerformance.materialGradeValue} MPa` : 'N/A';
        dom['moment-of-inertia'].textContent = finalPerformance.inertiaI.toLocaleString(undefined, { maximumFractionDigits: 2 });
        dom['axle-deflection'].textContent = finalPerformance.deflection.toFixed(2);
        dom['deflection-ratio'].textContent = (finalPerformance.ratio !== Infinity) ? `1 : ${Math.round(finalPerformance.ratio)} (Req. 1:${requiredRatio})` : 'N/A';
        dom['axle-safety-factor'].textContent = isFinite(finalPerformance.safetyFactor) ? finalPerformance.safetyFactor.toFixed(2) : 'Very High';

        // Show/Hide Warning Box
        if (finalPerformance.ratio < requiredRatio || finalPerformance.deflection > 17) {
            dom['ratio-paragraph'].classList.add('warning-text');
            dom['axle-safety-factor'].parentElement.classList.add('warning-text');
            dom['recommendation-box'].style.display = 'block';
            
            const autoPass = axlesForShape.find(axle => {
                const p = performDeflectionCalc(totalWeightKgs, axle, totalLength, curtainWidth);
                return p.ratio >= requiredRatio && p.deflection <= 17;
            });
            
            dom['recommendation-box'].innerHTML = autoPass 
                ? `⚠️ <strong>Note:</strong> Your selected axle is below the recommended limit. Consider using <strong>${autoPass['Name']}</strong>.`
                : `⚠️ <strong>Critical:</strong> No available ${selectedShape} axle meets the 17mm deflection limit for this width.`;
        } else {
            dom['ratio-paragraph'].classList.remove('warning-text');
            dom['axle-safety-factor'].parentElement.classList.remove('warning-text');
            dom['recommendation-box'].style.display = 'none';
        }

        const collarSize = parseFloat(dom.collarSize.value) || 0;
        drawAxleCrossSection(selectedAxleData, collarSize);
    }

    return { bestAxle: selectedAxleData, deflection: finalPerformance.deflection, totalLength };
}

        function performDeflectionCalc(totalWeightKgs, axle, totalLength, curtainWidth) {
            if (!axle) return { deflection: 0, ratio: Infinity, safetyFactor: Infinity, axleWeight: 0, materialGradeValue: 'N/A', inertiaI: 0 };
            
            const outerDia = parseFloat(axle['Diameter']);
            const wallThick = parseFloat(axle['Wall Thickness']);
            const shape = (axle['Shape'] || 'circular').toLowerCase();
            const lengthM = totalLength / 1000;
            const density = parseFloat(axle['Density (kg/m3)']) || 0;
            const materialGradeValue = axle['Material grade'];
            const youngsModulusE = parseFloat(materialGradeValue) || 199000;
            
            let inertiaI = 0, axleWeight = 0;

            if (shape === 'octagonal') {
                const Do = outerDia; const Di = Do - 2 * wallThick;
                inertiaI = ((11 + 8 * Math.sqrt(2)) / 192) * (Math.pow(Do, 4) - Math.pow(Di, 4));
                const outerArea = 2 * (Math.sqrt(2) - 1) * Math.pow(Do, 2);
                const innerArea = 2 * (Math.sqrt(2) - 1) * Math.pow(Di, 2);
                const hollowArea_mm2 = outerArea - innerArea;
                const volume_m3 = (hollowArea_mm2 / 1000000) * lengthM;
                axleWeight = volume_m3 * density;
            } else {
                inertiaI = (Math.PI / 64) * (Math.pow(outerDia, 4) - Math.pow(outerDia - 2 * wallThick, 4));
                const outerRadiusM = outerDia / 2 / 1000;
                const innerRadiusM = (outerDia - 2 * wallThick) / 2 / 1000;
                const volumeM3 = Math.PI * (Math.pow(outerRadiusM, 2) - Math.pow(innerRadiusM, 2)) * lengthM;
                axleWeight = volumeM3 * density;
            }
            
            const totalForceW = (totalWeightKgs + axleWeight) * 9.81;
            const fixityInput = document.getElementById('axleFixity');
            const fixityPercent = fixityInput ? (parseFloat(fixityInput.value) || 0) : 0;
            const safePercent = Math.max(0, Math.min(100, fixityPercent));
            const coefficient = 5 - (4 * (safePercent / 100));

            const deflection = (totalLength > 0 && inertiaI > 0 && youngsModulusE > 0) 
                ? (coefficient * totalForceW * Math.pow(totalLength, 3)) / (384 * youngsModulusE * inertiaI) 
                : 0;
                
            const ratio = (deflection > 0) ? totalLength / deflection : Infinity;
            
            let requiredRatio = 400;
            if (curtainWidth > 10000) requiredRatio = 800;
            else if (curtainWidth > 8000) requiredRatio = 600;

            const safetyFactor = ratio / requiredRatio;
            return { deflection, ratio, safetyFactor, axleWeight, materialGradeValue, inertiaI };
        }
        
        function getEffectiveCoilDiameter(axle) {
            if (!axle) return 0;
            const shape = (axle['Shape'] || 'circular').toLowerCase();
            const diameter = parseFloat(axle['Diameter']) || 0;
            if (shape === 'octagonal') { return diameter / Math.cos(Math.PI / 8); }
            return diameter;
        }
        
        function calculateEndplateRecommendation() {
            if (endplateData.length === 0) return;
            dom['max-coil-diameter'].textContent = maxCoilDiameter.toFixed(1);
            const axleDeflection = parseFloat(dom['axle-deflection'].textContent) || 0;
            let effectiveCoilDiameter = maxCoilDiameter;

            if (dom.includeDeflectionInSizing.checked && axleDeflection > 0) {
                effectiveCoilDiameter += axleDeflection;
                dom['effective-coil-diameter'].textContent = effectiveCoilDiameter.toFixed(1);
                dom['effective-coil-para'].style.display = 'block';
            } else { dom['effective-coil-para'].style.display = 'none'; }
            
            const selectedMaterial = dom.matSteel.checked ? 'Steel' : 'Aluminium';
            currentFilteredEndplates = endplateData.filter(plate => plate.Material.toLowerCase() === selectedMaterial.toLowerCase()).sort((a, b) => a.Size - b.Size);
            const select = dom.endplateSelector;
            select.innerHTML = '';

            if (currentFilteredEndplates.length === 0) {
                select.innerHTML = `<option value="">-- No ${selectedMaterial} plates --</option>`;
                updateSelectedEndplateInfo(); return;
            }
            let recommendedPlateIndex = -1;
            currentFilteredEndplates.forEach((plate, index) => {
                const option = document.createElement('option');
                option.value = index; option.textContent = `${plate.Name} (${plate.Size} mm)`;
                if (plate.Size >= effectiveCoilDiameter) {
                    option.classList.add('option-pass');
                    if (recommendedPlateIndex === -1) { recommendedPlateIndex = index; }
                } else {
                    option.classList.add('option-fail'); option.disabled = true;
                }
                select.appendChild(option);
            });

            if (recommendedPlateIndex !== -1) { select.value = recommendedPlateIndex; } else {
                 const noPlateOption = document.createElement('option');
                noPlateOption.value = ""; noPlateOption.textContent = "-- Coil too large for available plates --";
                noPlateOption.selected = true; noPlateOption.disabled = true;
                select.prepend(noPlateOption); drawEndplateGraphic(null, 0, null, null, 0); 
            }
            updateSelectedEndplateInfo();
        }

        function calculateMaxFloorToAxleHeight(endplateSize, lath, bottomLath, axle) {
            if (!lath || !axle || !bottomLath || endplateSize || endplateSize <= 0) return 0;
            const collarSize = parseFloat(dom.collarSize.value) || 0;
            const axleCoilDiameter = getEffectiveCoilDiameter(axle);
            const effectiveStartDiameter = Math.max(axleCoilDiameter, collarSize);
            const axleRadius = effectiveStartDiameter / 2;

            const lathThickness = parseFloat(lath['Thickness']);
            const lathCompressedHeight = parseFloat(lath['Compressed lath height']);
            const uncompressedLathHeight = parseFloat(lath['uncompressed lath height']) || lathCompressedHeight;
            const bottomLathHeight = parseFloat(bottomLath['BLath height']) || 0;

            if (lathThickness <= 0 || effectiveStartDiameter <= 0 || endplateSize <= effectiveStartDiameter || uncompressedLathHeight <= 0) return 0;
            const maxRevolutions = (endplateSize - effectiveStartDiameter) / (2 * lathThickness);
            if (maxRevolutions <= 0) return 0;
            const maxCurtainLength = Math.PI * lathThickness * Math.pow(maxRevolutions, 2) + Math.PI * effectiveStartDiameter * maxRevolutions;
            const numLaths = (maxCurtainLength - bottomLathHeight) / uncompressedLathHeight;
            const heightToCoverByLaths = numLaths * lathCompressedHeight;
            const maxFloorToAxleHeight = heightToCoverByLaths + bottomLathHeight - axleRadius;
            return maxFloorToAxleHeight > 0 ? maxFloorToAxleHeight : 0;
        }

        function updateSelectedEndplateInfo() {
            const selectedIndex = parseInt(dom.endplateSelector.value, 10);
            const selectedLath = lathData.length > 0 ? lathData[dom.lathType.value] : null;
            const selectedAxle = axleData.length > 0 ? axleData[dom.axleType.value] : null;
            const selectedBottomLath = bottomLathData.length > 0 ? bottomLathData[dom.bottomLathType.value] : null;
            const numLaths = parseInt(dom['lath-count'].textContent) || 0;

            if (isNaN(selectedIndex) || !currentFilteredEndplates[selectedIndex]) {
                ['endplate-name', 'endplate-size', 'endplate-material'].forEach(id => { dom[id].textContent = 'N/A'; });
                ['prev-endplate-name', 'prev-endplate-height', 'next-endplate-name', 'next-endplate-height'].forEach(id => { dom[id].textContent = 'N/A'; });
                drawEndplateGraphic(null, 0, null, null, 0); calculateEndplateForces(null);
                return;
            }

            const plate = currentFilteredEndplates[selectedIndex];
            dom['endplate-name'].textContent = plate.Name;
            dom['endplate-size'].textContent = plate.Size;
            dom['endplate-material'].textContent = plate.Material;

            drawEndplateGraphic(plate, maxCoilDiameter, selectedAxle, selectedLath, numLaths);
            calculateEndplateForces(plate);
            
            const prevPlate = selectedIndex > 0 ? currentFilteredEndplates[selectedIndex - 1] : null;
            if (prevPlate && selectedLath && selectedAxle && selectedBottomLath) {
                dom['prev-endplate-name'].textContent = `${prevPlate.Name} (${prevPlate.Size}mm)`;
                const maxHeight = calculateMaxFloorToAxleHeight(prevPlate.Size, selectedLath, selectedBottomLath, selectedAxle);
                dom['prev-endplate-height'].textContent = maxHeight > 0 ? maxHeight.toFixed(0) : 'Too small';
            } else { dom['prev-endplate-name'].textContent = 'N/A'; dom['prev-endplate-height'].textContent = 'N/A'; }
            
            const nextPlate = selectedIndex < currentFilteredEndplates.length - 1 ? currentFilteredEndplates[selectedIndex + 1] : null;
            if (nextPlate && selectedLath && selectedAxle && selectedBottomLath) {
                dom['next-endplate-name'].textContent = `${nextPlate.Name} (${nextPlate.Size}mm)`;
                 const maxHeight = calculateMaxFloorToAxleHeight(nextPlate.Size, selectedLath, selectedBottomLath, selectedAxle);
                dom['next-endplate-height'].textContent = maxHeight > 0 ? maxHeight.toFixed(0) : 'N/A';
            } else { dom['next-endplate-name'].textContent = 'N/A'; dom['next-endplate-height'].textContent = 'N/A'; }
        }

        function calculateEndplateForces(selectedPlate) {
            if (!selectedPlate) {
                dom['endplate-downward-force'].textContent = '0'; dom['endplate-pullout-force'].textContent = '0';
                drawEndplateForceDiagram(0, 0, 0, 0, 0); return;
            }
            const fixingHolesKey = Object.keys(selectedPlate).find(k => k.toLowerCase().trim() === 'fixing holes');
            const fixingHoleSeparation = fixingHolesKey ? parseFloat(selectedPlate[fixingHolesKey]) : 0;
            const fixingHoleSeparationM = fixingHoleSeparation / 1000;
            const curtainWeightKgs = parseFloat(dom['weight-kg'].textContent) || 0;
            const axleWeightKgs = parseFloat(dom['axle-weight'].textContent) || 0;
            const totalStaticWeightKgs = curtainWeightKgs + axleWeightKgs;
            const totalStaticWeightN = totalStaticWeightKgs * 9.81;
            const offsetDistanceM = (parseFloat(selectedPlate.Size) / 2) / 1000;
            const staticWeightOnPlateN = totalStaticWeightN / 2;
            const totalDownwardForceOnPlate = staticWeightOnPlateN;
            const moment = staticWeightOnPlateN * offsetDistanceM;
            let pulloutForce = 0;
            if (fixingHoleSeparationM > 0) { pulloutForce = moment / fixingHoleSeparationM; }
            const safetyFactor = 1.20;
            const finalDownwardForce = totalDownwardForceOnPlate * safetyFactor;
            const finalPulloutForce = pulloutForce * safetyFactor;
            dom['endplate-downward-force'].textContent = finalDownwardForce.toFixed(0);
            dom['endplate-pullout-force'].textContent = finalPulloutForce.toFixed(0);
            drawEndplateForceDiagram(finalDownwardForce, finalPulloutForce, offsetDistanceM, fixingHoleSeparation, parseFloat(selectedPlate.Size));
        }

        function calculateSafetyBrakeSelection() {
            const motorMaxTorqueText = dom['max-torque'].textContent;
            const motorMaxTorque = parseFloat(motorMaxTorqueText) || 0;
            
            if (safetyBrakeData.length === 0 || motorMaxTorque === 0) {
                dom['safety-brake-name'].textContent = 'N/A';
                dom['safety-brake-motor-torque'].textContent = 'N/A';
                dom['safety-brake-capacity'].textContent = 'N/A';
                dom['safety-brake-driveshaft'].textContent = 'N/A';
                dom['safety-brake-max-speed'].textContent = 'N/A';
                dom['actual-barrel-speed'].textContent = 'N/A';
                dom['safety-brake-speed-warning'].style.display = 'none';
                dom.safetyBrakeSelector.innerHTML = '<option value="">-- No Brake --</option>';
                dom.safetyBrakeSelector.value = "";
                return;
            }

            const suitableBrakes = safetyBrakeData.filter(brake => {
                const opTorqueKey = Object.keys(brake).find(k => k.toLowerCase().includes('operating torque'));
                const opTorque = parseFloat(brake[opTorqueKey]) || 0;
                return opTorque >= motorMaxTorque;
            }).sort((a,b) => {
                const opTorqueKey = Object.keys(a).find(k => k.toLowerCase().includes('operating torque'));
                return (parseFloat(a[opTorqueKey]) || 0) - (parseFloat(b[opTorqueKey]) || 0);
            });

            const select = dom.safetyBrakeSelector;
            select.innerHTML = '';
            
            if (suitableBrakes.length === 0) {
                const option = document.createElement('option');
                option.textContent = "-- No Suitable Safety Brake Found --";
                option.value = "";
                select.appendChild(option);
                select.value = ""; 
                
                dom['safety-brake-name'].textContent = 'NO SUITABLE BRAKE FOUND';
                dom['safety-brake-name'].classList.add('warning-text');
                dom['safety-brake-driveshaft'].textContent = 'N/A';
                dom['safety-brake-max-speed'].textContent = 'N/A';
            } else {
                suitableBrakes.forEach((brake) => {
                    const option = document.createElement('option');
                    const globalIndex = safetyBrakeData.indexOf(brake);
                    const opTorqueKey = Object.keys(brake).find(k => k.toLowerCase().includes('operating torque'));
                    const opTorque = parseFloat(brake[opTorqueKey]) || 0;
                    option.value = globalIndex;
                    option.textContent = `${brake.Name} (Op Torque: ${opTorque} Nm)`;
                    select.appendChild(option);
                });
                
                if (select.options.length > 0) {
                    select.value = select.options[0].value;
                }

                const selectedBrake = safetyBrakeData[select.value];
                dom['safety-brake-name'].textContent = selectedBrake.Name;
                dom['safety-brake-name'].classList.remove('warning-text');
                dom['safety-brake-motor-torque'].textContent = motorMaxTorque.toFixed(1);
                
                const opTorqueKey = Object.keys(selectedBrake).find(k => k.toLowerCase().includes('operating torque'));
                dom['safety-brake-capacity'].textContent = parseFloat(selectedBrake[opTorqueKey]) || 0;
                
                const dsKey = Object.keys(selectedBrake).find(k => k.toLowerCase().includes('driveshaft diameter mm'));
                dom['safety-brake-driveshaft'].textContent = selectedBrake[dsKey] || 'N/A';

                // START: NEW SAFETY BRAKE SPEED CHECK
                const maxSpeedKey = Object.keys(selectedBrake).find(k => k.toLowerCase().includes('max locking speed'));
                const maxSpeedLimit = maxSpeedKey ? (parseFloat(selectedBrake[maxSpeedKey]) || 0) : 0;
                dom['safety-brake-max-speed'].textContent = maxSpeedLimit > 0 ? `${maxSpeedLimit} RPM` : 'N/A';

                let motorRPM = parseFloat(dom['motor-rpm'].textContent) || 0;
                let barrelRPM = motorRPM;
                const motorSelectorIdx = dom.motorSelector.value;
                if (motorSelectorIdx !== "" && currentFilteredMotors[motorSelectorIdx]) {
                    const motor = currentFilteredMotors[motorSelectorIdx];
                    if (motor['Mounting type'] === 'Chain drive') {
                        const mTeeth = parseInt(dom.motorTeeth.value) || 0;
                        const bTeeth = parseInt(dom.barrelTeeth.value) || 0;
                        if (mTeeth > 0 && bTeeth > 0) {
                            barrelRPM = motorRPM * (mTeeth / bTeeth);
                        }
                    }
                }
                dom['actual-barrel-speed'].textContent = barrelRPM.toFixed(2) + " RPM";

                if (maxSpeedLimit > 0 && barrelRPM > maxSpeedLimit) {
                    dom['safety-brake-speed-warning'].style.display = 'block';
                    dom['actual-barrel-speed'].classList.add('warning-text');
                } else {
                    dom['safety-brake-speed-warning'].style.display = 'none';
                    dom['actual-barrel-speed'].classList.remove('warning-text');
                }
                // END: NEW SAFETY BRAKE SPEED CHECK
                
                const brakeName = selectedBrake.Name;
                const imageContainer = dom['safety-brake-image-container'];
                const imageDisplay = dom['safetyBrakeImageDisplay'];
                if (safetyBrakeImageMap.has(brakeName)) {
                    imageDisplay.src = safetyBrakeImageMap.get(brakeName); 
                    imageContainer.style.display = 'block';
                } else { 
                    imageContainer.style.display = 'none'; 
                }
            }
        }

        function calculateMotorRecommendation(totalWeightKgs, lath, axle, travelHeight, curtainWidth) {
    if (!lath || !axle || !travelHeight || travelHeight <= 0 || totalWeightKgs <= 0) {
        ['max-torque', 'total-revolutions', 'max-torque-inputs'].forEach(id => { dom[id].textContent = '0.0'; });
        lastTorqueProfile = []; maxCoilDiameter = 0; drawTorqueGraph(lastTorqueProfile, dom['torque-graph-container']);
        dom.motorSelector.innerHTML = '<option>-- First select a mounting type --</option>';
        dom.motorSelector.disabled = true; updateSelectedMotorInfo(); return;
    }
    
    const collarSize = parseFloat(dom.collarSize.value) || 0;
    const axleCoilDiameter = getEffectiveCoilDiameter(axle);
    const effectiveStartDiameter = Math.max(axleCoilDiameter, collarSize);
    calculatedRotations = calculateTotalRevolutions(travelHeight, effectiveStartDiameter, parseFloat(lath['Thickness']));
    dom['total-revolutions'].textContent = calculatedRotations.toFixed(1);
    
    const { profileData, finalCoilDiameter } = getTorqueProfile(totalWeightKgs, lath, travelHeight, effectiveStartDiameter, curtainWidth);
    maxCoilDiameter = finalCoilDiameter;

    let baselineFriction = parseFloat(dom.friction.value) || 0;
    let additionalFriction = 0;
    if (parseFloat(dom.height.value) >= 7000) additionalFriction += 5;

    let isHighPerformance = false;
    const usageFilterValue = dom.motorUsageFilter.value.toLowerCase();
    if (usageFilterValue.includes('high') || usageFilterValue.includes('hi ') || usageFilterValue.includes('speed')) {
        isHighPerformance = true;
    }
    if (isHighPerformance) additionalFriction += 5;
    
    const totalAppliedFriction = baselineFriction + additionalFriction;
    dom['total-applied-friction'].textContent = totalAppliedFriction;
    const frictionMultiplier = 1 + (totalAppliedFriction / 100);

    lastTorqueProfile = profileData.map(item => ({...item, torque: item.torque * frictionMultiplier}));
    drawTorqueGraph(lastTorqueProfile, dom['torque-graph-container']);
    
    const requiredTorque = lastTorqueProfile.length > 0 ? Math.max(...lastTorqueProfile.map(p => p.torque)) : 0;
    dom['max-torque'].textContent = requiredTorque.toFixed(1);
    dom['max-torque-inputs'].textContent = requiredTorque.toFixed(1);

    const selectedMountType = dom.motorMountingType.value;
    const selectedVoltage = dom.motorVoltageFilter.value;
    const selectedManufacturer = dom.motorManufacturerFilter.value;
    const selectedUsage = dom.motorUsageFilter.value;
    const selectedMO = dom.motorManualOverrideFilter.value;

    let voltageKey = '', manufacturerKey = '', usageKey = '', moKey = '';
    if (motorData.length > 0) {
        voltageKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'voltage');
        manufacturerKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'manufacturer');
        usageKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'usage type');
        moKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'manual override');
    }
    currentFilteredMotors = motorData.filter(motor => {
        const mountMatch = !selectedMountType || motor['Mounting type'] === selectedMountType;
        const motorVoltages = String(motor[voltageKey] || '').split('/').map(v => v.trim());
        const voltageMatch = !selectedVoltage || !voltageKey || motorVoltages.includes(selectedVoltage);
        const manufacturerMatch = !selectedManufacturer || !manufacturerKey || motor[manufacturerKey] === selectedManufacturer;
        const usageMatch = !selectedUsage || !usageKey || motor[usageKey] === selectedUsage;
        const moMatch = !selectedMO || !moKey || String(motor[moKey]).trim().toLowerCase() === String(selectedMO).trim().toLowerCase();
        return mountMatch && voltageMatch && manufacturerMatch && usageMatch && moMatch;
    });
    
    const select = dom.motorSelector; 
    const previousValue = select.value;
    
    select.innerHTML = ''; select.disabled = false;
    if (currentFilteredMotors.length === 0) {
        select.innerHTML = '<option value="">-- No motors for this type --</option>';
        updateSelectedMotorInfo(); return;
    }
    
    let recommendedMotorIndexInFilteredList = -1;
    currentFilteredMotors.forEach((motor, index) => {
        const option = document.createElement('option');
        option.value = index;
        const motorTorqueMin = parseFloat(motor['Torque (Nm) min']) || 0;
        const motorTorqueMax = parseFloat(motor['Torque (Nm) max']) || 0;
        
        // --- ADDED .toFixed(1) TO DROPDOWN TEXT ---
        option.textContent = `${motor['Name']} (${motorTorqueMin.toFixed(1)}-${motorTorqueMax.toFixed(1)} Nm)`;
        
        const passesTest = requiredTorque >= motorTorqueMin && requiredTorque <= motorTorqueMax;
        if (passesTest) {
            option.classList.add('option-pass');
            if (recommendedMotorIndexInFilteredList === -1) { recommendedMotorIndexInFilteredList = index; }
        } else {
            option.classList.add('option-fail'); 
        }
        select.appendChild(option);
    });

    if (previousValue !== "" && currentFilteredMotors[previousValue]) {
        select.value = previousValue;
    } else if (recommendedMotorIndexInFilteredList !== -1) { 
        select.value = recommendedMotorIndexInFilteredList; 
    } else {
        const noMotorOption = document.createElement('option');
        noMotorOption.value = ""; noMotorOption.textContent = "-- No suitable motor found --";
        noMotorOption.selected = true; noMotorOption.disabled = true;
        select.prepend(noMotorOption);
    }
    updateSelectedMotorInfo();
}
        
        function updateSelectedSafetyBrakeInfo() {
            calculateSafetyBrakeSelection();
            updateSelectedMotorInfo();
            const axleIdx = dom.axleType.value;
            if(axleIdx !== "" && axleData[axleIdx]) {
                const collarSize = parseFloat(dom.collarSize.value) || 0;
                drawAxleCrossSection(axleData[axleIdx], collarSize);
            }
        }

function updateSelectedMotorInfo() {
    const selectedMotorIndex = dom.motorSelector.value;
    const safetyBrakeTabBtn = document.querySelector('.tab-button[data-tab="safety-brake-content"]');
    
    const resetChainInfo = () => {
         dom.motorTeeth.value = "";
         dom.barrelTeeth.value = "";
         dom.sprocketDiameter.value = "";
         dom.plateWheelDiameter.value = "";
         dom.chainSizeDisplay.value = "";
         dom.chainSizeDisplay.dataset.breakingStrain = 0;
    };

    if (selectedMotorIndex === "" || !currentFilteredMotors[selectedMotorIndex]) {
         ['motor-name','motor-torque','motor-rpm','motor-driveshaft-dia','motor-cycles-per-hour','opening-time', 'power-consumed', 'motor-name-inputs', 'motor-torque-inputs'].forEach(id => { dom[id].textContent = 'N/A'; });
         dom['motor-torque-line'].classList.remove('warning-text'); dom['motor-torque-line-inputs'].classList.remove('warning-text'); 
         dom['motor-image-container'].style.display = 'none';
         dom['motor-limit-turns'].textContent = 'N/A';
         dom['motor-limit-warning'].style.display = 'none';
         resetChainInfo();
         updateChainCalculations();
         return;
    }

    const selectedMotor = currentFilteredMotors[selectedMotorIndex];
    
    // --- NEW: TOGGLE SAFETY BRAKE TAB VISIBILITY ---
    // Look for the specific column (handling the spelling "saftey")
    const brakeKey = Object.keys(selectedMotor).find(k => k.toLowerCase().includes('requires additional saftey brake'));
    const needsBrakeValue = brakeKey ? String(selectedMotor[brakeKey]).toLowerCase().trim() : "yes";
    
    if (needsBrakeValue === "no") {
        if (safetyBrakeTabBtn) safetyBrakeTabBtn.style.display = 'none';
        // If the user is currently on the Safety Brake tab, kick them back to the Motor tab
        if (document.getElementById('safety-brake-content').classList.contains('active')) {
            switchTab('motor-content');
        }
    } else {
        if (safetyBrakeTabBtn) safetyBrakeTabBtn.style.display = 'block';
    }
    // ----------------------------------------------

    const motorTorqueMin = parseFloat(selectedMotor['Torque (Nm) min']) || 0;
    const motorTorqueMax = parseFloat(selectedMotor['Torque (Nm) max']) || 0;
    const motorRPM = parseFloat(selectedMotor['RPM']) || 0;
    const motorWattage = parseFloat(selectedMotor['Wattage']);
    const dsKey = Object.keys(selectedMotor).find(k => k.toLowerCase().trim() === 'driveshaft diameter mm');
    const cyclesKey = Object.keys(selectedMotor).find(k => k.toLowerCase().trim() === 'cycles per hour');

    dom['motor-name'].textContent = selectedMotor['Name'];
    dom['motor-torque'].textContent = `${motorTorqueMin.toFixed(1)} - ${motorTorqueMax.toFixed(1)}`; 
    dom['motor-rpm'].textContent = motorRPM.toFixed(1);
    
    let displayShaft = dsKey ? selectedMotor[dsKey] : 'N/A';
    if (!isNaN(parseFloat(displayShaft)) && isFinite(displayShaft)) {
        displayShaft = parseFloat(displayShaft).toFixed(1);
    }

    const selectedBrakeIndex = dom.safetyBrakeSelector.value;
    if (selectedBrakeIndex !== "") {
        const dsVal = parseFloat(dom['safety-brake-driveshaft'].textContent);
        if (!isNaN(dsVal)) {
             const motorOptions = String(displayShaft).split('/').map(s => s.trim());
             if (motorOptions.includes(String(dsVal.toFixed(1))) || motorOptions.includes(String(dsVal))) {
                 displayShaft = `${dsVal.toFixed(1)} mm (Matched to Brake)`;
             }
        }
    }
    dom['motor-driveshaft-dia'].textContent = displayShaft;
    dom['motor-name-inputs'].textContent = selectedMotor['Name'];
    dom['motor-torque-inputs'].textContent = `${motorTorqueMin.toFixed(1)} - ${motorTorqueMax.toFixed(1)}`;
    
    const motorName = selectedMotor['Name'];
    if (motorImageMap.has(motorName)) {
        dom['motorImageDisplay'].src = motorImageMap.get(motorName);
        dom['motor-image-container'].style.display = 'block';
    } else {
        dom['motor-image-container'].style.display = 'none';
    }

    let openingTimeSec = 0;
    if (motorRPM > 0 && calculatedRotations > 0) {
        openingTimeSec = (calculatedRotations / motorRPM) * 60;
        const usageType = (selectedMotor['Usage type'] || '').toLowerCase();
        if (usageType.includes('high') || usageType.includes('hi ') || usageType.includes('speed')) {
            openingTimeSec += 2;
        }
        dom['opening-time'].textContent = openingTimeSec.toFixed(1);
    } else { dom['opening-time'].textContent = '0'; }
    
    if (motorWattage > 0 && openingTimeSec > 0) {
        const cycleTimeSec = openingTimeSec * 2;
        const wattHours = (motorWattage * cycleTimeSec) / 3600;
        dom['power-consumed'].textContent = `${(wattHours / 1000).toFixed(4)} kWh`;
    } else { dom['power-consumed'].textContent = 'N/A'; }
    
    const requiredTorque = parseFloat(dom['max-torque'].textContent);
    if (requiredTorque < motorTorqueMin || requiredTorque > motorTorqueMax) {
        dom['motor-torque-line'].classList.add('warning-text'); dom['motor-torque-line-inputs'].classList.add('warning-text');
    } else {
        dom['motor-torque-line'].classList.remove('warning-text'); dom['motor-torque-line-inputs'].classList.remove('warning-text');
    }
    
    const limitTurnKey = Object.keys(selectedMotor).find(k => k.toLowerCase().trim() === 'limit turn');
    const limitTurnVal = limitTurnKey ? parseFloat(selectedMotor[limitTurnKey]) : 0;

    if (limitTurnVal > 0) {
        const percentUsed = (calculatedRotations / limitTurnVal) * 100;
        dom['motor-limit-turns'].textContent = `${limitTurnVal.toFixed(1)} (${percentUsed.toFixed(0)}% used)`;
        if (calculatedRotations > limitTurnVal) {
            dom['motor-limit-warning'].style.display = 'block';
            dom['motor-limit-turns'].classList.add('warning-text');
        } else {
            dom['motor-limit-warning'].style.display = 'none';
            dom['motor-limit-turns'].classList.remove('warning-text');
        }
    } else {
        dom['motor-limit-turns'].textContent = 'N/A';
        dom['motor-limit-warning'].style.display = 'none';
    }

    const standardCPH = cyclesKey ? parseFloat(selectedMotor[cyclesKey]) : 0;
    let finalCPH = standardCPH;
    if (limitTurnVal > 0 && calculatedRotations > 0 && calculatedRotations < (limitTurnVal * 0.5)) {
        finalCPH = standardCPH * 2;
    }
    dom['motor-cycles-per-hour'].textContent = finalCPH > 0 ? finalCPH.toFixed(1) : 'N/A';

    if (selectedMotor['Mounting type'] === 'Chain drive' && chainDriveData.length > 0) {
        let motorNameClean = selectedMotor['Name'].replace(/\s*\(.*?\)\s*/g, '').trim().toLowerCase();
        const chainSpecs = chainDriveData.find(row => (row['Motor Description'] || '').toString().trim().toLowerCase().includes(motorNameClean));
        if (chainSpecs) {
            dom.motorTeeth.value = chainSpecs['Sprocket teeth'] || "";
            dom.barrelTeeth.value = chainSpecs['Plate wheel'] || ""; 
            dom.sprocketDiameter.value = chainSpecs['Sprocket diameter'] || "";
            dom.plateWheelDiameter.value = chainSpecs['Platewheel Diameter'] || "";
            const chainSizeKey = Object.keys(chainSpecs).find(k => k.toLowerCase().includes('chain size'));
            dom.chainSizeDisplay.value = chainSizeKey ? chainSpecs[chainSizeKey] : "Unknown";
            dom.chainSizeDisplay.dataset.breakingStrain = parseFloat(chainSpecs['Chain Breaking Strain in newtons']) || 0;
        } else { resetChainInfo(); }
    } else { resetChainInfo(); }
    updateChainCalculations();
    updateWeldCalculations();
}
        
        function updateSelectedWicketInfo() {
            const selectedIndex = dom.wicketDoorSelector.value;
            if (selectedIndex !== "" && wicketData[selectedIndex]) {
                const selectedDoor = wicketData[selectedIndex];
                dom['wicket-door-name'].textContent = selectedDoor.Name || 'N/A';
                dom['wicket-door-height'].textContent = selectedDoor.Height || '0';
                dom['wicket-door-width'].textContent = selectedDoor.Width || '0';
            } else {
                dom['wicket-door-name'].textContent = 'N/A'; dom['wicket-door-height'].textContent = '0'; dom['wicket-door-width'].textContent = '0';
            }
            const curtainWidth = parseFloat(dom['calculated-curtain-width'].textContent) || 0;
            updateWicketCalculationsAndGraphic({cast:0, wind:0}, curtainWidth);
        }

        function updateWicketCalculationsAndGraphic(endlockOffsets = {cast: 0, wind: 0}, curtainWidth) {
            const selectedWicketIndex = dom.wicketDoorSelector.value;
            const selectedLathIndex = dom.lathType.value;
            const selectedBottomLathIndex = dom.bottomLathType.value;
            const selectedWicket = (wicketData && selectedWicketIndex !== "") ? wicketData[selectedWicketIndex] : null;
            const selectedLath = (lathData && selectedLathIndex !== "") ? lathData[selectedLathIndex] : null;
            const selectedBottomLath = (bottomLathData && selectedBottomLathIndex !== "") ? bottomLathData[selectedBottomLathIndex] : null;
            const selectedAxle = (axleData && dom.axleType.value !== "") ? axleData[dom.axleType.value] : null;
            let lathsAtWicket = 0, wicketLathHeight = 0;
            if (selectedWicket && selectedLath && selectedBottomLath) {
                const wicketHeight = parseFloat(selectedWicket.Height) || 0;
                const bottomLathHeight = parseFloat(selectedBottomLath['BLath height']) || 0;
                const lathCompressedHeight = parseFloat(selectedLath['Compressed lath height']) || 0;
                if (lathCompressedHeight > 0 && wicketHeight > 0) {
                    const wicketGap = 10; 
                    const heightCoveredByWicketZone = wicketHeight + wicketGap;
                    const lathsInZone = Math.ceil(heightCoveredByWicketZone / lathCompressedHeight);
                    lathsAtWicket = lathsInZone;
                    wicketLathHeight = bottomLathHeight + (lathsInZone * lathCompressedHeight);
                }
            }
            dom['laths-at-wicket'].textContent = lathsAtWicket;
            dom['wicket-lath-height'].textContent = wicketLathHeight.toFixed(0);
            const selectedEndplateIndex = dom.endplateSelector.value;
            const selectedEndplate = (selectedEndplateIndex !== "" && currentFilteredEndplates[selectedEndplateIndex]) ? currentFilteredEndplates[selectedEndplateIndex] : null;
            drawWicketGraphic(curtainWidth, parseFloat(dom.additionalLength.value), parseInt(dom['lath-count'].textContent), selectedLath, selectedBottomLath, selectedAxle, selectedEndplate, selectedWicket, wicketLathHeight, endlockOffsets);
            calculateWicketTorque(curtainWidth);
        }

        function calculateWicketTorque(curtainWidth) {
            const selectedLath = lathData.length > 0 ? lathData[dom.lathType.value] : null;
            const selectedAxle = axleData.length > 0 ? axleData[dom.axleType.value] : null;
            const selectedWicket = wicketData.length > 0 ? wicketData[dom.wicketDoorSelector.value] : null;
            const totalWeightKgs = parseFloat(dom['torque-weight-kg'].textContent) || 0;
            if (!selectedLath || !selectedAxle || !selectedWicket || totalWeightKgs <= 0) {
                dom['wicket-max-torque'].textContent = '0.0'; drawTorqueGraph([], dom['wicket-torque-graph-container']); return;
            }
            const floorToAxleCenter = parseFloat(dom.height.value) || 0;
            const bottomLathHeight = bottomLathData.length > 0 ? (parseFloat(bottomLathData[dom.bottomLathType.value]['BLath height']) || 0) : 0;
            const travelHeight = floorToAxleCenter - bottomLathHeight;
            const collarSize = parseFloat(dom.collarSize.value) || 0;
            const axleCoilDiameter = getEffectiveCoilDiameter(selectedAxle);
            const effectiveStartDiameter = Math.max(axleCoilDiameter, collarSize);
            const { profileData } = getTorqueProfileWithWicket(totalWeightKgs, selectedLath, travelHeight, selectedWicket, effectiveStartDiameter, curtainWidth);
            
            const frictionText = dom['total-applied-friction'].textContent;
            const frictionMultiplier = 1 + (parseFloat(frictionText) || 0) / 100;
            const adjustedProfile = profileData.map(item => ({...item, torque: item.torque * frictionMultiplier}));
            const requiredTorque = adjustedProfile.length > 0 ? Math.max(...adjustedProfile.map(p => p.torque)) : 0;
            dom['wicket-max-torque'].textContent = requiredTorque.toFixed(1);
            drawTorqueGraph(adjustedProfile, dom['wicket-torque-graph-container']);
        }

        function getTorqueProfileWithWicket(totalWeightKgs, lath, travelHeight, wicket, effectiveStartDiameter, curtainWidth) {
            const profileData = []; 
            let heightLifted = 0; 
            let currentRollDiameter = effectiveStartDiameter;
            const lathThickness = parseFloat(lath['Thickness']);
            if (travelHeight <= 0 || totalWeightKgs <= 0) return { profileData: [], finalCoilDiameter: currentRollDiameter };
            const selectedBottomLath = bottomLathData[dom.bottomLathType.value];
            const widthM = (curtainWidth || 0) / 1000;
            const bottomLathHeight = parseFloat(selectedBottomLath['BLath height']) || 0;
            const slopingData = getSlopingBottomData();
			const bottomLathWeight = widthM * (parseFloat(selectedBottomLath['BLath weight / m length']) || 0) + slopingData.weight;
            const lathsWeight = totalWeightKgs - bottomLathWeight;
            const wicketWidthM = (parseFloat(wicket.Width) || 0) / 1000;
            const wicketHeightM = (parseFloat(wicket.Height) || 0) / 1000;
            let lathKgsPerM2 = parseFloat(lath['Kgs/ m2']) || 0;
            if (dom.powderCoated.checked) lathKgsPerM2 += 0.5;
            const wicketWeightReduction = wicketWidthM * wicketHeightM * lathKgsPerM2;
            const wicketStartHeightFromBottomM = (bottomLathHeight / 1000) + (10 / 1000);
            const wicketEndHeightFromBottomM = wicketStartHeightFromBottomM + wicketHeightM;

            while (heightLifted < travelHeight) {
                const percentLifted = heightLifted / travelHeight;
                const remainingLathWeight = lathsWeight * (1 - percentLifted);
                let remainingTotalWeight = remainingLathWeight + bottomLathWeight;
                const curtainHangingHeightM = (travelHeight - heightLifted) / 1000;
                let reduction = 0;
                if (curtainHangingHeightM >= wicketEndHeightFromBottomM) {
                    reduction = wicketWeightReduction;
                } else if (curtainHangingHeightM > wicketStartHeightFromBottomM) {
                    const hangingPortionHeight = curtainHangingHeightM - wicketStartHeightFromBottomM;
                    reduction = wicketWeightReduction * (hangingPortionHeight / wicketHeightM);
                }
                remainingTotalWeight -= reduction;
                remainingTotalWeight = Math.max(0, remainingTotalWeight);
                const force = remainingTotalWeight * 9.81; 
                const radiusM = ((currentRollDiameter + lathThickness) / 2) / 1000;
                profileData.push({ torque: force * radiusM, diameter: currentRollDiameter, heightLifted: heightLifted });
                const circumference = Math.PI * currentRollDiameter; 
                heightLifted += circumference / 2; 
                currentRollDiameter += lathThickness;
            } 
            return { profileData, finalCoilDiameter: currentRollDiameter };
        };

        function calculateTotalRevolutions(travelHeight, initialDiameter, lathThickness) {
            if (travelHeight <= 0 || initialDiameter <= 0 || lathThickness <= 0) return 0;
            const a = Math.PI * lathThickness;
            const b = Math.PI * initialDiameter;
            const c = -travelHeight;
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) return 0;
            return (-b + Math.sqrt(discriminant)) / (2 * a);
        }
        
		function getTorqueProfile(totalWeightKgs, lath, travelHeight, effectiveStartDiameter, curtainWidth) {
			const profileData = []; 
			let heightLifted = 0; 
			let currentRollDiameter = effectiveStartDiameter;
			const lathThickness = parseFloat(lath['Thickness']);
			if (travelHeight <= 0 || totalWeightKgs <= 0) return { profileData: [], finalCoilDiameter: currentRollDiameter };
			const selectedBottomLath = bottomLathData[dom.bottomLathType.value];
			const widthM = (curtainWidth || 0) / 1000;
			const bottomLathHeight = parseFloat(selectedBottomLath['BLath height']) || 0;
			
			// FETCH THE DATA FIRST so it doesn't crash here
			const slopingData = getSlopingBottomData();
			const bottomLathWeight = widthM * (parseFloat(selectedBottomLath['BLath weight / m length']) || 0) + slopingData.weight;
    
    const lathsWeight = totalWeightKgs - bottomLathWeight;
            while (heightLifted < travelHeight) {
                const percentLifted = heightLifted / travelHeight;
                const remainingLathWeight = lathsWeight * (1 - percentLifted);
                const remainingTotalWeight = remainingLathWeight + bottomLathWeight;
                const force = remainingTotalWeight * 9.81; 
                const radiusM = ((currentRollDiameter + lathThickness) / 2) / 1000;
                profileData.push({ torque: force * radiusM, diameter: currentRollDiameter, heightLifted: heightLifted });
                const circumference = Math.PI * currentRollDiameter; 
                heightLifted += circumference / 2; 
                currentRollDiameter += lathThickness;
            } 
            return { profileData, finalCoilDiameter: currentRollDiameter };
        };
        
        function populateDropdown(selectElement, dataArray, nameField) {
            selectElement.innerHTML = `<option value="">-- Select an option --</option>`;
            dataArray.forEach((item, index) => {
                const option = document.createElement('option');
                option.value = index;
                const header = Object.keys(item).find(k => k.toLowerCase().trim() === nameField.toLowerCase().trim());
                option.textContent = item[header];
                selectElement.appendChild(option);
            });
        };
        
        function calculateCurtainProperties(lath, bottomLath, axle, curtainWidth) {
            const visionEnabled = dom.addVision.checked;
            if (visionEnabled) { return calculateVisionCurtainProperties(lath, bottomLath, axle, curtainWidth); }
            const floorToAxleCenter = parseFloat(dom.height.value) || 0;
            if (!lath || !bottomLath || floorToAxleCenter <= 0) {
                dom['lath-count'].textContent = '0'; dom['laths-to-lift'].textContent = '0';
                dom['weight-kg'].textContent = '0.00'; dom['torque-weight-kg'].textContent = '0.00';
                dom['curtain-height-extended'].textContent = '0'; dom['curtain-height-compressed'].textContent = '0';
                dom['curtain-area'].textContent = '0.00'; dom['lifted-curtain-area'].textContent = '0.00';
                dom['vision-percentage-para'].style.display = 'none'; dom['vision-area-m2-para'].style.display = 'none';
                dom['endlock-weight'].textContent = '0.00';
                return { totalWeight: 0, torqueWeight: 0, travelHeight: 0, fullCurtainLength: 0, visionData: null, endlockOffsets: { cast: 0, wind: 0 } };
            }
            const lathCompressedHeight = parseFloat(lath['Compressed lath height']);
            const uncompressedLathHeight = parseFloat(lath['uncompressed lath height']);
            const bottomLathHeight = parseFloat(bottomLath['BLath height']) || 0;
			const slopingData = getSlopingBottomData();
            let axleRadius = 0;
            if (axle) {
                 const axleCoilDiameter = getEffectiveCoilDiameter(axle); axleRadius = axleCoilDiameter / 2;
            } else if (axleData.length > 0) { axleRadius = (getEffectiveCoilDiameter(axleData[0])) / 2; }
            let heightToCoverByLaths = (floorToAxleCenter - bottomLathHeight) + axleRadius;
			if (slopingData.maxH > 0) {
				heightToCoverByLaths -= slopingData.maxH;
				if (heightToCoverByLaths < 0) heightToCoverByLaths = 0;
			}
            let numLaths = 0;
            if (lathCompressedHeight > 0 && heightToCoverByLaths > 0) { numLaths = Math.ceil(heightToCoverByLaths / lathCompressedHeight) + 2; }
            dom['lath-count'].textContent = numLaths;
            const numLathsToLift = numLaths >= 3 ? numLaths - 3 : 0;
            dom['laths-to-lift'].textContent = numLathsToLift;
			const compressedCurtainHeight = (numLaths * lathCompressedHeight) + bottomLathHeight + slopingData.maxH;
			const fullCurtainLength = (numLaths * uncompressedLathHeight) + bottomLathHeight + slopingData.maxH;
            dom['curtain-height-extended'].textContent = fullCurtainLength.toFixed(0);
            dom['curtain-height-compressed'].textContent = compressedCurtainHeight.toFixed(0);
            const widthM = (curtainWidth || 0) / 1000;
            let kgsPerM2 = parseFloat(lath['Kgs/ m2']) || 0;
            if (dom.powderCoated.checked) { kgsPerM2 += 0.5; }
            const totalMaterialAreaM2 = widthM * (fullCurtainLength / 1000);
            dom['curtain-area'].textContent = totalMaterialAreaM2.toFixed(2);
			const liftedLathCoverageLength = (numLathsToLift * lathCompressedHeight);
			const liftedCoverageAreaM2 = widthM * (liftedLathCoverageLength / 1000);
			dom['lifted-curtain-area'].textContent = liftedCoverageAreaM2.toFixed(2);
            const lathWeightBasedOnCoverage = widthM * (numLaths * lathCompressedHeight / 1000) * kgsPerM2;
            const bottomLathWeight = widthM * (parseFloat(bottomLath['BLath weight / m length']) || 0);
            let totalEndlockWeight = 0;
            const lathName = (lath['Name'] || '').toLowerCase();
            const isWindLath = lathName.includes('wind');
            let endlockOffsets = { cast: 0, wind: 0 };
            if (numLaths > 0 && endlockData.length > 0) {
                const selectedCastEndlockIndex = dom.endlockType.value;
                let castEndlockWeightG = 0;
                if (selectedCastEndlockIndex !== "" && endlockData[selectedCastEndlockIndex]) {
                    const selectedEndlock = endlockData[selectedCastEndlockIndex];
                    const weightKey = Object.keys(selectedEndlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                    castEndlockWeightG = weightKey ? parseFloat(selectedEndlock[weightKey]) : 0;
                    const offsetKey = Object.keys(selectedEndlock).find(k => k.toLowerCase().trim() === 'end lock offset');
                    endlockOffsets.cast = offsetKey ? parseFloat(selectedEndlock[offsetKey]) : 0;
                }
                if (isWindLath) {
                    let windEndlockWeightG = 0;
                    const windEndlock = endlockData.find(el => (el['Description'] || '').toLowerCase().includes('75mm wind'));
                    if (windEndlock) {
                        const weightKey = Object.keys(windEndlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                        windEndlockWeightG = weightKey ? parseFloat(windEndlock[weightKey]) : 0;
                        const offsetKey = Object.keys(windEndlock).find(k => k.toLowerCase().trim() === 'end lock offset');
                        endlockOffsets.wind = offsetKey ? parseFloat(windEndlock[offsetKey]) : 0;
                    }
                    for (let i = 1; i <= numLaths; i++) {
                        if (i % 2 !== 0 && castEndlockWeightG > 0) { totalEndlockWeight += 2 * (castEndlockWeightG / 1000); }
                        const isWindLathPosition = (i === 2 || i === 4 || i === 6 || i === 8) || (i > 8 && i % 8 === 0);
                        if (isWindLathPosition && windEndlockWeightG > 0) { totalEndlockWeight += 2 * (windEndlockWeightG / 1000); }
                    }
                } else {
                    if (castEndlockWeightG > 0) {
                         const numEndlockPairs = Math.ceil(numLaths / 2); totalEndlockWeight = numEndlockPairs * 2 * (castEndlockWeightG / 1000);
                    }
                }
            }
            dom['endlock-weight'].textContent = totalEndlockWeight.toFixed(2);
            const totalWeight = lathWeightBasedOnCoverage + bottomLathWeight + totalEndlockWeight + slopingData.weight;
            dom['weight-kg'].textContent = totalWeight.toFixed(2);
            
            let torqueWeight;
            const customTorqueWeightValue = parseFloat(dom.customTorqueWeight.value);
            if (dom.useCustomLath.checked && !isNaN(customTorqueWeightValue) && customTorqueWeightValue > 0) {
                torqueWeight = customTorqueWeightValue;
            } else {
                torqueWeight = totalWeight;
                if (numLaths >= 3) {
                    const bufferLathWeight = 3 * (lathCompressedHeight / 1000) * widthM * kgsPerM2;
                    let bufferEndlockWeight = 0;
                    const selectedCastEndlockIndex = dom.endlockType.value;
                    if (selectedCastEndlockIndex !== "" && endlockData[selectedCastEndlockIndex]) {
                        const weightKey = Object.keys(endlockData[selectedCastEndlockIndex]).find(k => k.toLowerCase().trim() === 'weight in grams');
                        const castEndlockWeightG = weightKey ? parseFloat(endlockData[selectedCastEndlockIndex][weightKey]) : 0;
                        if (castEndlockWeightG > 0) { bufferEndlockWeight = 4 * (castEndlockWeightG / 1000); }
                    }
                    torqueWeight = totalWeight - bufferLathWeight - bufferEndlockWeight;
                }
            }
            dom['torque-weight-kg'].textContent = torqueWeight.toFixed(2);
            const travelHeight = floorToAxleCenter - bottomLathHeight;
            const mainLathVisionKey = Object.keys(lath).find(k => k.toLowerCase().trim() === 'vision percentage');
            const mainLathVisionPercent = mainLathVisionKey ? (parseFloat(lath[mainLathVisionKey]) || 0) : 0;

            if (mainLathVisionPercent > 0) {
                const visionArea = totalMaterialAreaM2 * (mainLathVisionPercent / 100);
                dom['vision-area-m2'].textContent = visionArea.toFixed(2);
                dom['vision-percentage'].textContent = mainLathVisionPercent.toFixed(2);
                dom['vision-percentage-para'].style.display = 'block'; dom['vision-area-m2-para'].style.display = 'block';
            } else {
                dom['vision-percentage-para'].style.display = 'none'; dom['vision-area-m2-para'].style.display = 'none';
            }
            return { totalWeight, torqueWeight, travelHeight, fullCurtainLength, visionData: null, endlockOffsets };
        };
        
        function calculateVisionCurtainProperties(mainLath, bottomLath, axle, curtainWidth) {
            const visionLath = lathData[dom.visionLathType.value];
            const widthM = (curtainWidth || 0) / 1000;
            const floorToAxleCenter = parseFloat(dom.height.value) || 0;
            const desiredVisionStart = parseFloat(dom.visionStartHeight.value) || 0;
            const desiredVisionPanelHeight = parseFloat(dom.visionPanelHeight.value) || 0;
            let endlockOffsets = { cast: 0, wind: 0 };
            const resetAndReturn = () => {
                dom['lath-count'].textContent = '0'; dom['laths-to-lift'].textContent = '0';
                dom['weight-kg'].textContent = '0.00'; dom['torque-weight-kg'].textContent = '0.00';
                dom['curtain-height-extended'].textContent = '0'; dom['curtain-height-compressed'].textContent = '0';
                dom['curtain-area'].textContent = '0.00'; dom['lifted-curtain-area'].textContent = '0.00';
                dom['vision-percentage-para'].style.display = 'none'; dom['vision-area-m2-para'].style.display = 'none';
                dom['endlock-weight'].textContent = '0.00';
                return { totalWeight: 0, torqueWeight: 0, travelHeight: 0, fullCurtainLength: 0, visionData: null, endlockOffsets };
            };

            if (!mainLath || !bottomLath || !visionLath || !axle || floorToAxleCenter <= 0 || widthM <= 0) { return resetAndReturn(); }
            const mainLathCompressed = parseFloat(mainLath['Compressed lath height']);
            const mainLathUncompressed = parseFloat(mainLath['uncompressed lath height']) || mainLathCompressed;
            let mainLathKgsM2 = parseFloat(mainLath['Kgs/ m2']);
            if (dom.powderCoated.checked) { mainLathKgsM2 += 0.5; }
            const visionLathCompressed = parseFloat(visionLath['Compressed lath height']);
            const visionLathUncompressed = parseFloat(visionLath['uncompressed lath height']) || visionLathCompressed;
            let visionLathKgsM2 = parseFloat(visionLath['Kgs/ m2']);
            if (dom.powderCoated.checked) { visionLathKgsM2 += 0.5; }

            if (isNaN(mainLathCompressed) || isNaN(visionLathCompressed) || mainLathCompressed <= 0 || visionLathCompressed <= 0) { return resetAndReturn(); }

			const bottomLathHeight = parseFloat(bottomLath['BLath height']) || 0;
			const bottomLathWeightPerM = parseFloat(bottomLath['BLath weight / m length']) || 0;
			const axleRadius = getEffectiveCoilDiameter(axle) / 2;
			const slopingData = getSlopingBottomData();
			
			let numLathsBelow = 0;
			if (desiredVisionStart > bottomLathHeight + slopingData.maxH) { numLathsBelow = Math.round((desiredVisionStart - bottomLathHeight - slopingData.maxH) / mainLathCompressed); }
			let numLathsVision = 0;
			if (desiredVisionPanelHeight > 0) { numLathsVision = Math.round(desiredVisionPanelHeight / visionLathCompressed); }
			const heightCoveredSoFar_compressed = bottomLathHeight + slopingData.maxH + (numLathsBelow * mainLathCompressed) + (numLathsVision * visionLathCompressed);
			let remainingHeightToCover = (floorToAxleCenter + axleRadius) - heightCoveredSoFar_compressed;
			if (remainingHeightToCover < 0) remainingHeightToCover = 0;
			
			let numLathsAbove = 0;
			if (remainingHeightToCover > 0) { numLathsAbove = Math.ceil(remainingHeightToCover / mainLathCompressed) + 2; }

            const totalNumLaths = numLathsBelow + numLathsVision + numLathsAbove;
            dom['lath-count'].textContent = totalNumLaths;
            const numLathsToLift = totalNumLaths >= 3 ? totalNumLaths - 3 : 0;
            dom['laths-to-lift'].textContent = numLathsToLift;
            const weightBelow = numLathsBelow * (mainLathCompressed / 1000) * widthM * mainLathKgsM2;
            const weightVision = numLathsVision * (visionLathCompressed / 1000) * widthM * visionLathKgsM2;
            const weightAbove = numLathsAbove * (mainLathCompressed / 1000) * widthM * mainLathKgsM2;
            const bottomLathWeight = widthM * bottomLathWeightPerM;
            let totalEndlockWeight = 0;
            const lathName = (mainLath['Name'] || '').toLowerCase();
            const isWindLath = lathName.includes('wind');

            if (totalNumLaths > 0 && endlockData.length > 0) {
                const selectedCastEndlockIndex = dom.endlockType.value;
                let castEndlockWeightG = 0;
                if (selectedCastEndlockIndex !== "" && endlockData[selectedCastEndlockIndex]) {
                    const selectedEndlock = endlockData[selectedCastEndlockIndex];
                    const weightKey = Object.keys(selectedEndlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                    castEndlockWeightG = weightKey ? parseFloat(selectedEndlock[weightKey]) : 0;
                    const offsetKey = Object.keys(selectedEndlock).find(k => k.toLowerCase().trim() === 'end lock offset');
                    endlockOffsets.cast = offsetKey ? parseFloat(selectedEndlock[offsetKey]) : 0;
                }
                if (isWindLath) {
                    let windEndlockWeightG = 0;
                    const windEndlock = endlockData.find(el => (el['Description'] || '').toLowerCase().includes('75mm wind'));
                    if (windEndlock) {
                        const weightKey = Object.keys(windEndlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                        windEndlockWeightG = weightKey ? parseFloat(windEndlock[weightKey]) : 0;
                        const offsetKey = Object.keys(windEndlock).find(k => k.toLowerCase().trim() === 'end lock offset');
                        endlockOffsets.wind = offsetKey ? parseFloat(windEndlock[offsetKey]) : 0;
                    }
                    for (let i = 1; i <= totalNumLaths; i++) {
                        if (i % 2 !== 0 && castEndlockWeightG > 0) { totalEndlockWeight += 2 * (castEndlockWeightG / 1000); }
                        const isWindLathPosition = (i === 2 || i === 4 || i === 6 || i === 8) || (i > 8 && i % 8 === 0);
                        if (isWindLathPosition && windEndlockWeightG > 0) { totalEndlockWeight += 2 * (windEndlockWeightG / 1000); }
                    }
                } else {
                    if (castEndlockWeightG > 0) { const numEndlockPairs = Math.ceil(totalNumLaths / 2); totalEndlockWeight = numEndlockPairs * 2 * (castEndlockWeightG / 1000); }
                }
            }
			dom['endlock-weight'].textContent = totalEndlockWeight.toFixed(2);
					const totalWeight = weightBelow + weightVision + weightAbove + bottomLathWeight + totalEndlockWeight + slopingData.weight;
					dom['weight-kg'].textContent = totalWeight.toFixed(2);

            let torqueWeight;
            const customTorqueWeightValue = parseFloat(dom.customTorqueWeight.value);
            if (dom.useCustomLath.checked && !isNaN(customTorqueWeightValue) && customTorqueWeightValue > 0) {
                torqueWeight = customTorqueWeightValue;
            } else {
                torqueWeight = totalWeight;
                if (numLathsAbove >= 3) {
                    const bufferLathWeight = 3 * (mainLathCompressed / 1000) * widthM * mainLathKgsM2;
                    let bufferEndlockWeight = 0;
                    const selectedCastEndlockIndex = dom.endlockType.value;
                     if (selectedCastEndlockIndex !== "" && endlockData[selectedCastEndlockIndex]) {
                        const weightKey = Object.keys(endlockData[selectedCastEndlockIndex]).find(k => k.toLowerCase().trim() === 'weight in grams');
                        const castEndlockWeightG = weightKey ? parseFloat(endlockData[selectedCastEndlockIndex][weightKey]) : 0;
                        if (castEndlockWeightG > 0) { bufferEndlockWeight = 4 * (castEndlockWeightG / 1000); }
                    }
                    torqueWeight = totalWeight - bufferLathWeight - bufferEndlockWeight;
                }
            }
            dom['torque-weight-kg'].textContent = torqueWeight.toFixed(2);
            const compressedCurtainHeight = bottomLathHeight + (numLathsBelow * mainLathCompressed) + (numLathsVision * visionLathCompressed) + (numLathsAbove * mainLathCompressed);
            const fullCurtainLength = bottomLathHeight + (numLathsBelow * mainLathUncompressed) + (numLathsVision * visionLathUncompressed) + (numLathsAbove * mainLathUncompressed);
            const areaBelowMaterial = numLathsBelow * (mainLathUncompressed / 1000) * widthM;
            const areaVisionMaterial = numLathsVision * (visionLathUncompressed / 1000) * widthM;
            const areaAboveMaterial = numLathsAbove * (mainLathUncompressed / 1000) * widthM;
            const totalMaterialArea = areaBelowMaterial + areaVisionMaterial + areaAboveMaterial;
            dom['curtain-area'].textContent = totalMaterialArea.toFixed(2);
			const areaBelowCoverage = numLathsBelow * (mainLathCompressed / 1000) * widthM;
			const areaVisionCoverage = numLathsVision * (visionLathCompressed / 1000) * widthM;
			const numLiftedLathsAbove = Math.max(0, numLathsAbove - 3);
			const liftedAreaAboveCoverage = numLiftedLathsAbove * (mainLathCompressed / 1000) * widthM;
			const liftedCoverageArea = areaBelowCoverage + areaVisionCoverage + liftedAreaAboveCoverage;
			dom['lifted-curtain-area'].textContent = liftedCoverageArea.toFixed(2);
            dom['curtain-height-extended'].textContent = fullCurtainLength.toFixed(0);
            dom['curtain-height-compressed'].textContent = compressedCurtainHeight.toFixed(0);
            const travelHeight = floorToAxleCenter - bottomLathHeight;
            const actualVisionStartHeight = bottomLathHeight + (numLathsBelow * mainLathCompressed);
            const actualVisionPanelHeight = numLathsVision * visionLathCompressed;
            const mainLathVisionKey = Object.keys(mainLath).find(k => k.toLowerCase().trim() === 'vision percentage');
            const mainLathVisionPercent = mainLathVisionKey ? (parseFloat(mainLath[mainLathVisionKey]) || 0) : 0;
            const visionLathVisionKey = Object.keys(visionLath).find(k => k.toLowerCase().trim() === 'vision percentage');
            const visionLathVisionPercent = visionLathVisionKey ? (parseFloat(visionLath[visionLathVisionKey]) || 0) : 0;
            const visionAreaFromMain = (areaBelowMaterial + areaAboveMaterial) * (mainLathVisionPercent / 100);
            const visionAreaFromVisionPanel = areaVisionMaterial * (visionLathVisionPercent / 100);
            const totalActualVisionArea = visionAreaFromMain + visionAreaFromVisionPanel;
            const overallVisionPercentage = (totalMaterialArea > 0) ? (totalActualVisionArea / totalMaterialArea) * 100 : 0;
            dom['vision-area-m2'].textContent = totalActualVisionArea.toFixed(2);
            dom['vision-percentage'].textContent = overallVisionPercentage.toFixed(2);
            dom['vision-percentage-para'].style.display = 'block'; dom['vision-area-m2-para'].style.display = 'block';
            const visionData = { visionLath, numLathsBelow, numLathsVision, numLathsAbove, actualVisionStartHeight, actualVisionPanelHeight };
            return { totalWeight, torqueWeight, travelHeight, fullCurtainLength, visionData, endlockOffsets };
        }

        function drawTorqueGraph(profileData, container) {
            container.innerHTML = '';
            if (!profileData || profileData.length === 0) return;
            const svgNS = "http://www.w3.org/2000/svg", svg = document.createElementNS(svgNS, "svg");
            let svgWidth = container.clientWidth; if (svgWidth === 0) svgWidth = 550; 
            let svgHeight = container.clientHeight; if (svgHeight === 0) svgHeight = 280;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            const padding = { top: 30, right: 20, bottom: 60, left: 40 }; 
            const graphWidth = svgWidth - padding.left - padding.right;
            const graphHeight = svgHeight - padding.top - padding.bottom;
            const maxTorque = Math.max(...profileData.map(p => p.torque)) * 1.1 || 10;
            const yAxis = document.createElementNS(svgNS, 'line');
            yAxis.setAttribute('x1', padding.left); yAxis.setAttribute('y1', padding.top);
            yAxis.setAttribute('x2', padding.left); yAxis.setAttribute('y2', padding.top + graphHeight);
            yAxis.setAttribute('class', 'axis-line');
            svg.appendChild(yAxis);
            const xLabel = document.createElementNS(svgNS, 'text');
            xLabel.setAttribute('class', 'graph-text');
            xLabel.setAttribute('transform', `translate(${svgWidth/2}, ${svgHeight - 15})`);
            xLabel.textContent = 'Coil Diameter (mm) / Revolutions';
            svg.appendChild(xLabel);
            const barWidth = Math.max(5, graphWidth / profileData.length * 0.8);
            const barSpacing = Math.max(1, graphWidth / profileData.length * 0.2);
            profileData.forEach((item, index) => {
                const barHeight = (item.torque / maxTorque) * graphHeight;
                const x = padding.left + index * (barWidth + barSpacing);
                const y = padding.top + graphHeight - barHeight;
                const revs = (index + 1) * 0.5;
                const bar = document.createElementNS(svgNS, 'rect');
                bar.setAttribute('x', x); bar.setAttribute('y', y); bar.setAttribute('width', barWidth); bar.setAttribute('height', barHeight); bar.setAttribute('class', 'torque-bar');
                const title = document.createElementNS(svgNS, 'title');
                title.textContent = `Rev ${revs.toFixed(1)}: ${item.torque.toFixed(1)} Nm | Dia: ${item.diameter.toFixed(0)} mm`;
                bar.appendChild(title); svg.appendChild(bar);
                const textX = x + barWidth / 2;
                if (barHeight > 15) {
                    const torqueText = document.createElementNS(svgNS, 'text');
                    torqueText.setAttribute('x', textX); torqueText.setAttribute('y', y - 5); torqueText.setAttribute('class', 'graph-data-label'); 
                    torqueText.textContent = `${item.torque.toFixed(1)} Nm`; svg.appendChild(torqueText);
                }
                const showAxisLabel = profileData.length < 15 || index % Math.ceil(profileData.length / 15) === 0;
                if (showAxisLabel) {
                    const diaText = document.createElementNS(svgNS, 'text');
                    diaText.setAttribute('x', textX); diaText.setAttribute('y', padding.top + graphHeight + 15); diaText.setAttribute('class', 'graph-data-label');
                    diaText.textContent = `Ø${item.diameter.toFixed(0)}`; svg.appendChild(diaText);
                    const revText = document.createElementNS(svgNS, 'text');
                    revText.setAttribute('x', textX); revText.setAttribute('y', padding.top + graphHeight + 28); revText.setAttribute('class', 'graph-data-label');
                    revText.textContent = `(${revs.toFixed(1)}r)`; svg.appendChild(revText);
                }
            });
            container.appendChild(svg);
        }
        
function drawDeflectionGraphic(length, deflection, isWarning = false) {
    const container = dom['deflection-graphic-container'];
    container.innerHTML = '';
    const svgNS = "http://www.w3.org/2000/svg", svg = document.createElementNS(svgNS, "svg");

    let svgWidth = container.clientWidth || 550;
    let svgHeight = container.clientHeight || 150;
    svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

    const padding = 40; 
    const beamY = 65; // Fixed baseline height
    const maxVisualDeflection = 35; // Max visual pixels for the bend
    const numericDeflection = parseFloat(deflection) || 0;

    // Scale visual bend: 17mm real deflection = maxVisualDeflection pixels
    const visualDeflection = Math.min(maxVisualDeflection, numericDeflection * (maxVisualDeflection / 17));

    const startX = padding;
    const endX = svgWidth - padding;
    const midX = svgWidth / 2;
    const controlY = beamY + (visualDeflection * 2); 
    // The peak of a quadratic bezier is halfway between the baseline and the control point
    const peakY = (beamY + controlY) / 2; 

    const defs = document.createElementNS(svgNS, 'defs');
    
    // Define Arrow Markers
    const createMarker = (id, color, orient) => {
        const marker = document.createElementNS(svgNS, 'marker');
        marker.setAttribute('id', id);
        marker.setAttribute('viewBox', '0 0 10 10');
        marker.setAttribute('refX', '5');
        marker.setAttribute('refY', '5');
        marker.setAttribute('markerWidth', '4');
        marker.setAttribute('markerHeight', '4');
        marker.setAttribute('orient', orient);
        const path = document.createElementNS(svgNS, 'path');
        path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
        path.setAttribute('fill', color);
        marker.appendChild(path);
        return marker;
    };

    defs.appendChild(createMarker('arrow-up', '#28a745', 'auto-start-reverse')); 
    defs.appendChild(createMarker('arrow-down', '#d93025', 'auto'));             
    defs.appendChild(createMarker('arrow-blue', '#007bff', 'auto'));             
    svg.appendChild(defs);

    // 1. Draw Support Arrows (Green Reactions)
    const supportLen = 30;
    [startX, endX].forEach(x => {
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', x);
        line.setAttribute('y1', beamY + supportLen);
        line.setAttribute('x2', x);
        line.setAttribute('y2', beamY + 2);
        line.setAttribute('stroke', '#28a745');
        line.setAttribute('stroke-width', '2');
        line.setAttribute('marker-end', 'url(#arrow-up)');
        svg.appendChild(line);
    });

    // 2. Draw Deflected Beam (The Curve)
    const deflectedPath = document.createElementNS(svgNS, 'path');
    deflectedPath.setAttribute('d', `M ${startX},${beamY} Q ${midX},${controlY} ${endX},${beamY}`);
    deflectedPath.setAttribute('fill', 'none');
    deflectedPath.setAttribute('stroke', isWarning ? '#d93025' : '#007bff');
    deflectedPath.setAttribute('stroke-width', '4');
    svg.appendChild(deflectedPath);

    // 3. Draw UDL Arrows (Downward Load)
    const udlCount = 10;
    const udlTopY = beamY - 40;
    for (let i = 0; i <= udlCount; i++) {
        const t = i / udlCount;
        const x = startX + t * (endX - startX);
        const yOnCurve = Math.pow(1 - t, 2) * beamY + 2 * (1 - t) * t * controlY + Math.pow(t, 2) * beamY;

        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', x);
        line.setAttribute('y1', udlTopY);
        line.setAttribute('x2', x);
        line.setAttribute('y2', yOnCurve - 4);
        line.setAttribute('stroke', '#d93025');
        line.setAttribute('stroke-width', '1.5');
        line.setAttribute('marker-end', 'url(#arrow-down)');
        svg.appendChild(line);
    }

    // UDL Top Horizontal Line
    const udlLine = document.createElementNS(svgNS, 'line');
    udlLine.setAttribute('x1', startX); udlLine.setAttribute('y1', udlTopY);
    udlLine.setAttribute('x2', endX); udlLine.setAttribute('y2', udlTopY);
    udlLine.setAttribute('stroke', '#d93025');
    svg.appendChild(udlLine);

    // 4. ADDED: Deflection Dimension and Text
    if (numericDeflection > 0) {
        // Vertical indicator line at center
        const dimLine = document.createElementNS(svgNS, 'line');
        dimLine.setAttribute('x1', midX);
        dimLine.setAttribute('y1', beamY);
        dimLine.setAttribute('x2', midX);
        dimLine.setAttribute('y2', peakY - 2);
        dimLine.setAttribute('stroke', '#007bff');
        dimLine.setAttribute('stroke-width', '1');
        dimLine.setAttribute('marker-end', 'url(#arrow-blue)');
        svg.appendChild(dimLine);

        // Numerical Text Label
        const defText = document.createElementNS(svgNS, 'text');
        defText.setAttribute('x', midX);
        defText.setAttribute('y', peakY + 18); // Position below the peak
        defText.setAttribute('text-anchor', 'middle');
        defText.setAttribute('font-family', 'sans-serif');
        defText.setAttribute('font-size', '14px');
        defText.setAttribute('font-weight', 'bold');
        defText.style.fill = isWarning ? '#d93025' : '#007bff';
        defText.textContent = numericDeflection.toFixed(2) + " mm Deflection";
        svg.appendChild(defText);
    }

    // UDL Label
    const label = document.createElementNS(svgNS, 'text');
    label.setAttribute('x', midX);
    label.setAttribute('y', udlTopY - 8);
    label.setAttribute('text-anchor', 'middle');
    label.setAttribute('font-family', 'sans-serif');
    label.setAttribute('font-size', '11px');
    label.style.fill = '#d93025';
    label.style.fontWeight = 'bold';
    label.textContent = "Uniformly Distributed Load";
    svg.appendChild(label);

    container.appendChild(svg);
}

function drawEndplateForceDiagram(downwardForce, pulloutForce, offsetM, fixingSeparation, endplateSize) {
    const container = dom['endplate-force-diagram-container']; 
    container.innerHTML = '';
    
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    const svgWidth = 450; 
    const svgHeight = 550; 
    svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
	
	    // --- NEW LINES ADDED HERE TO CONTROL SIZE AND ALIGNMENT ---
    svg.style.width = "100%";       // Responsive width
    svg.style.maxWidth = "600px";   // Stop expanding at 400px (Roughly half scale of the page)
    svg.style.height = "auto";      // Maintain aspect ratio
    svg.style.display = "block";    // Block display to allow centering
    svg.style.margin = "0 auto";    // Center horizontally
    // ----------------------------------------------------------

    const defs = document.createElementNS(svgNS, 'defs');
    
    // Wall Hatching Pattern
    const pattern = document.createElementNS(svgNS, 'pattern');
    pattern.setAttribute('id', 'wall-hatch');
    pattern.setAttribute('patternUnits', 'userSpaceOnUse');
    pattern.setAttribute('width', '10');
    pattern.setAttribute('height', '10');
    const hatchPath = document.createElementNS(svgNS, 'path');
    hatchPath.setAttribute('d', 'M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2');
    hatchPath.setAttribute('stroke', '#adb5bd');
    hatchPath.setAttribute('stroke-width', '1');
    pattern.appendChild(hatchPath);
    defs.appendChild(pattern);

    // Markers
    const createMarker = (id, color) => {
        const marker = document.createElementNS(svgNS, 'marker');
        marker.setAttribute('id', id); marker.setAttribute('viewBox', '0 0 10 10');
        marker.setAttribute('refX', '5'); marker.setAttribute('refY', '5');
        marker.setAttribute('markerWidth', '5'); marker.setAttribute('markerHeight', '5');
        marker.setAttribute('orient', 'auto-start-reverse');
        const arrowPath = document.createElementNS(svgNS, 'path');
        arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); arrowPath.setAttribute('fill', color);
        marker.appendChild(arrowPath); return marker;
    };
    defs.appendChild(createMarker('arrow-force-red', '#d93025'));
    defs.appendChild(createMarker('arrow-force-blue', '#007bff'));
    defs.appendChild(createMarker('arrow-dim', '#343a40'));
    svg.appendChild(defs);

    const createElem = (type, attrs) => {
        const el = document.createElementNS(svgNS, type);
        for (const key in attrs) el.setAttribute(key, attrs[key]); return el;
    };

    const wallX = 120; 
    const plateWidth = 20; 
    const plateHeight = 160;
    const plateY = 50; 
    const plateCenterX = wallX + plateWidth / 2; 
    const plateCenterY = plateY + plateHeight / 2;

    // Determine Wall Height dynamically
    // Stop it 80px below the plate, which covers the text area
    const wallBottomY = plateY + plateHeight + 80;

    // 1. Draw Wall
    svg.appendChild(createElem('rect', { x: wallX - 40, y: 10, width: 40, height: wallBottomY - 70, fill: 'url(#wall-hatch)' }));
    svg.appendChild(createElem('line', { x1: wallX, y1: 10, x2: wallX, y2: wallBottomY -60 , stroke: '#343a40', 'stroke-width': '2' }));
    
    // 2. Draw Endplate
    svg.appendChild(createElem('rect', { x: wallX, y: plateY, width: plateWidth, height: plateHeight, fill: '#adb5bd', stroke: '#495057'}));

    // Fixings
    const scaledFixingSep = Math.min(plateHeight * 0.7, fixingSeparation * 0.5); 
    const topFixingY = plateCenterY - scaledFixingSep / 2; 
    const bottomFixingY = plateCenterY + scaledFixingSep / 2;
    svg.appendChild(createElem('circle', { cx: plateCenterX, cy: topFixingY, r: 4, fill: '#495057' }));
    svg.appendChild(createElem('circle', { cx: plateCenterX, cy: bottomFixingY, r: 4, fill: '#495057' }));

    // Coil Center
    const coilCenterX = wallX + plateWidth + (offsetM * 1000 * 0.5);
    svg.appendChild(createElem('circle', { cx: coilCenterX, cy: plateCenterY, r: 40, fill: '#e9ecef', stroke: '#adb5bd', 'stroke-dasharray': '4,2' }));
    svg.appendChild(createElem('circle', { cx: coilCenterX, cy: plateCenterY, r: 5, fill: '#6c757d' }));

    const arrowStyleRed = { stroke: '#d93025', 'stroke-width': '2', 'marker-end': 'url(#arrow-force-red)' };
    const arrowStyleBlue = { stroke: '#007bff', 'stroke-width': '2', 'marker-start': 'url(#arrow-force-blue)' };

    // --- FORCES ---

    // 1. Total Shear Force (Under Coil)
    const totalShearArrowStart = plateCenterY + 50;
    const totalShearArrowEnd = totalShearArrowStart + 40;
    svg.appendChild(createElem('line', { x1: coilCenterX, y1: totalShearArrowStart, x2: coilCenterX, y2: totalShearArrowEnd, ...arrowStyleRed }));
    
    // Text moved to the RIGHT of the arrow tip to avoid overlap with left text
    const mainForceText = createElem('text', { x: coilCenterX + 50, y: totalShearArrowEnd + 5, class: 'force-text red', 'text-anchor': 'start', 'dominant-baseline': 'middle' });
    mainForceText.textContent = `Total Shear: ${downwardForce.toFixed(0)} N`;
    svg.appendChild(mainForceText);

    // 2. Pull-out Force (Top Fixing) 
    // Extended arrow tail to -60, moved text to -65
    svg.appendChild(createElem('line', { x1: wallX, y1: topFixingY, x2: wallX - 40, y2: topFixingY, ...arrowStyleRed }));
    const pulloutText = createElem('text', { x: wallX - 65, y: topFixingY, class: 'force-text red', 'text-anchor': 'end', 'dominant-baseline': 'middle' });
    pulloutText.textContent = `${pulloutForce.toFixed(0)} N`; 
    svg.appendChild(pulloutText);

    // 3. Compression Force (Bottom Fixing)
    // Extended arrow tail to -60, moved text to -65
    svg.appendChild(createElem('line', { x1: wallX - 40, y1: bottomFixingY, x2: wallX, y2: bottomFixingY, ...arrowStyleBlue }));
    const compText = createElem('text', { x: wallX - 65, y: bottomFixingY, class: 'force-text blue', 'text-anchor': 'end', 'dominant-baseline': 'middle' });
    compText.textContent = `${pulloutForce.toFixed(0)} N`; 
    svg.appendChild(compText);

    // 4. Shear Force per Bolt (Vertical)
    const shearForcePerBolt = downwardForce / 2;
    
    svg.appendChild(createElem('line', { x1: plateCenterX, y1: topFixingY, x2: plateCenterX, y2: topFixingY + 50, ...arrowStyleRed }));
    svg.appendChild(createElem('line', { x1: plateCenterX, y1: bottomFixingY, x2: plateCenterX, y2: bottomFixingY + 30, ...arrowStyleRed }));
    
    // Shear Text: Smaller font, centered under plate
    const shearTextY = bottomFixingY + 60;
    const shearText = createElem('text', { x: plateCenterX, y: shearTextY, fill: '#d93025', 'font-family': 'sans-serif', 'font-size': '10px', 'font-weight': 'bold', 'text-anchor': 'middle' });
    shearText.textContent = `Shear: ${shearForcePerBolt.toFixed(0)} N (each)`; 
    svg.appendChild(shearText);

    // --- DIMENSIONS ---

    const dimStyle = { class: 'dimension-line', 'marker-start': 'url(#arrow-dim)', 'marker-end': 'url(#arrow-dim)' };
    const leaderStyle = { class: 'leader-line' };

    // 1. Fixing Separation
    const fixDimX = wallX + plateWidth + 25; 
    svg.appendChild(createElem('line', { x1: fixDimX, y1: topFixingY, x2: fixDimX, y2: bottomFixingY, ...dimStyle }));
    svg.appendChild(createElem('line', { x1: plateCenterX, y1: topFixingY, x2: fixDimX, y2: topFixingY, ...leaderStyle}));
    svg.appendChild(createElem('line', { x1: plateCenterX, y1: bottomFixingY, x2: fixDimX, y2: bottomFixingY, ...leaderStyle}));
    
    const fixText = createElem('text', { x: fixDimX, y: plateCenterY, class: 'dim-text-force-diagram', 'text-anchor':'middle', 'dominant-baseline':'auto', transform:`rotate(-90, ${fixDimX}, ${plateCenterY})`, dy: '-4' });
    fixText.textContent = `${fixingSeparation.toFixed(0)} mm`; 
    svg.appendChild(fixText);

    // 2. Offset Dimension
    const offsetDimY = 15; 
    svg.appendChild(createElem('line', { x1: wallX, y1: offsetDimY, x2: coilCenterX, y2: offsetDimY, ...dimStyle }));
    svg.appendChild(createElem('line', { x1: wallX, y1: offsetDimY, x2: wallX, y2: plateY, ...leaderStyle })); 
    svg.appendChild(createElem('line', { x1: coilCenterX, y1: offsetDimY, x2: coilCenterX, y2: plateCenterY - 45, ...leaderStyle })); 
    
    const offsetText = createElem('text', { x: wallX + (coilCenterX - wallX)/2, y: offsetDimY - 4, class: 'dim-text-force-diagram' });
    offsetText.textContent = `Offset: ${(offsetM * 1000).toFixed(0)} mm`; 
    svg.appendChild(offsetText);

    container.appendChild(svg);
}

        function drawEndplateGraphic(endplate, coilDiameter, axle, lath, numLaths) {
            const container = dom['endplate-graphic-container']; container.innerHTML = '';
            if (!endplate || !coilDiameter || !axle || !lath || !numLaths || coilDiameter <= 0) { return; }
            const endplateSize = parseFloat(endplate.Size);
            const lathThickness = parseFloat(lath['Thickness']);
            if (isNaN(endplateSize) || isNaN(lathThickness) || endplateSize <= 0) return;
            const svgNS = "http://www.w3.org/2000/svg"; const svg = document.createElementNS(svgNS, "svg");
            const svgWidth = 550; const svgHeight = 250;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            const defs = document.createElementNS(svgNS, 'defs');
            const marker = document.createElementNS(svgNS, 'marker'); marker.setAttribute('id', 'arrow-endplate'); marker.setAttribute('viewBox', '0 0 10 10'); marker.setAttribute('refX', '1'); marker.setAttribute('refY', '5'); marker.setAttribute('markerWidth', '5'); marker.setAttribute('markerHeight', '5'); marker.setAttribute('orient', 'auto-start-reverse');
            const arrowPath = document.createElementNS(svgNS, 'path'); arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); arrowPath.setAttribute('fill', '#343a40');
            marker.appendChild(arrowPath); defs.appendChild(marker); svg.appendChild(defs);
            const padding = { top: 20, right: 120, bottom: 40, left: 10 };
            const graphHeight = svgHeight - padding.top - padding.bottom;
            const scale = graphHeight / endplateSize;
            const scaledBoxSize = endplateSize * scale;
            const boxX = padding.left; const boxY = padding.top + (graphHeight - scaledBoxSize) / 2;
            const centerX = boxX + scaledBoxSize / 2; const centerY = boxY + scaledBoxSize / 2;
            const createElem = (type, attrs) => {
                const el = document.createElementNS(svgNS, type); for (const key in attrs) el.setAttribute(key, attrs[key]); return el;
            };
            svg.appendChild(createElem('rect', { x: boxX, y: boxY, width: scaledBoxSize, height: scaledBoxSize, fill: '#f8f9fa', stroke: '#ced4da', 'stroke-width': '1' }));
            const axleDiameter = getEffectiveCoilDiameter(axle); const scaledAxleRadius = (axleDiameter / 2) * scale;
            svg.appendChild(createElem('circle', { cx: centerX, cy: centerY, r: scaledAxleRadius, class: 'shutter-axle-graphic' }));
            for (let i = 1; i <= numLaths; i++) {
                const currentRadius = (axleDiameter / 2) + (i * lathThickness);
                if (currentRadius * 2 > coilDiameter) break; 
                svg.appendChild(createElem('circle', { cx: centerX, cy: centerY, r: currentRadius * scale, class: 'coil-wrap-graphic' }));
            }
            const scaledCoilRadius = (coilDiameter / 2) * scale;
            svg.appendChild(createElem('circle', { cx: centerX, cy: centerY, r: scaledCoilRadius, fill: 'none', stroke: '#007bff', 'stroke-width': '2' }));
            const dimLineX = boxX + scaledBoxSize + 25;
            svg.appendChild(createElem('line', { x1: boxX, y1: boxY, x2: dimLineX, y2: boxY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: boxX, y1: boxY + scaledBoxSize, x2: dimLineX, y2: boxY + scaledBoxSize, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: dimLineX, y1: boxY, x2: dimLineX, y2: boxY + scaledBoxSize, class: 'dimension-line', 'marker-start': 'url(#arrow-endplate)', 'marker-end': 'url(#arrow-endplate)' }));
            const boxSizeTextX = dimLineX + 12;
            const boxSizeText = createElem('text', { x: boxSizeTextX, y: centerY, class: 'large-dimension-text', 'text-anchor': 'middle', transform: `rotate(-90, ${boxSizeTextX}, ${centerY})` });
            boxSizeText.textContent = `${endplateSize.toFixed(0)} mm`; svg.appendChild(boxSizeText);
            const coilDimY = boxY + scaledBoxSize + 20;
            svg.appendChild(createElem('line', { x1: centerX - scaledCoilRadius, y1: centerY, x2: centerX - scaledCoilRadius, y2: coilDimY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: centerX + scaledCoilRadius, y1: centerY, x2: centerX + scaledCoilRadius, y2: coilDimY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: centerX - scaledCoilRadius, y1: coilDimY, x2: centerX + scaledCoilRadius, y2: coilDimY, class: 'dimension-line', 'marker-start': 'url(#arrow-endplate)', 'marker-end': 'url(#arrow-endplate)' }));
            const coilDimText = createElem('text', { x: centerX, y: coilDimY + 15, class: 'large-dimension-text' });
            coilDimText.textContent = `Ø ${coilDiameter.toFixed(1)} mm`; svg.appendChild(coilDimText);
            const clearance = (endplateSize - coilDiameter) / 2;
            if (clearance > 1) {
                const clearanceDimX = dimLineX + 40; const topY = boxY; const coilTopY = centerY - scaledCoilRadius;
                svg.appendChild(createElem('line', { x1: centerX, y1: topY, x2: clearanceDimX, y2: topY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
                svg.appendChild(createElem('line', { x1: centerX, y1: coilTopY, x2: clearanceDimX, y2: coilTopY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
                svg.appendChild(createElem('line', { x1: clearanceDimX, y1: topY, x2: clearanceDimX, y2: coilTopY, class: 'dimension-line', 'marker-start': 'url(#arrow-endplate)', 'marker-end': 'url(#arrow-endplate)' }));
                const clearanceTextX = clearanceDimX + 12;
                const clearanceText = createElem('text', { x: clearanceTextX, y: topY + (coilTopY - topY) / 2, class: 'large-dimension-text', 'text-anchor': 'middle', transform: `rotate(-90, ${clearanceTextX}, ${topY + (coilTopY - topY) / 2})` });
                clearanceText.textContent = `${clearance.toFixed(1)} mm`; svg.appendChild(clearanceText);
            }
            container.appendChild(svg);
        }

        function drawAxleCrossSection(axle, collarSize = 0) {
            const container = dom['axle-cross-section-container']; 
            container.innerHTML = '';
            dom['bearing-name'].textContent = 'N/A';
            dom['bearing-capacity'].textContent = 'N/A';
            dom['bearing-warning'].style.display = 'none';

            if (!axle) return;
            const outerDia = parseFloat(axle['Diameter']); 
            const wallThick = parseFloat(axle['Wall Thickness']); 
            const shape = (axle['Shape'] || 'circular').toLowerCase();
            if (isNaN(outerDia) || isNaN(wallThick) || outerDia <= 0 || wallThick <= 0) return;
            const innerDia = outerDia - (2 * wallThick);

            const mountType = (dom.motorMountingType.value || '').toLowerCase();
            const isTubular = mountType.includes('tubular');
            const isChainDrive = mountType.includes('chain');

            let motorShaftRaw = parseFloat(dom['motor-driveshaft-dia'].textContent);
            if (isNaN(motorShaftRaw)) motorShaftRaw = 40; 
            
            let brakeShaftValue = 0;
            const sbIndex = dom.safetyBrakeSelector.value;
            if (sbIndex !== "" && safetyBrakeData[sbIndex]) {
                const sb = safetyBrakeData[sbIndex];
                const dsKey = Object.keys(sb).find(k => k.toLowerCase().includes('driveshaft diameter'));
                if (dsKey) brakeShaftValue = parseFloat(sb[dsKey]);
            }
            if (!brakeShaftValue || isNaN(brakeShaftValue)) {
                brakeShaftValue = parseFloat(dom['safety-brake-driveshaft'].textContent);
            }
            if (isNaN(brakeShaftValue) || brakeShaftValue === 0) brakeShaftValue = 40;

            const lookupBearing = (minSize) => {
                if (!bearingData || bearingData.length === 0) return { name: "No Data", cap: 0, size: minSize };
                const first = bearingData[0];
                const sizeKey = Object.keys(first).find(k => k.toLowerCase().trim() === 'shaft size in mm');
                const nameKey = Object.keys(first).find(k => k.toLowerCase().trim() === 'bearing name');
                const capKey = Object.keys(first).find(k => k.toLowerCase().trim() === 'load capacity in kgs');
                if (!sizeKey) return { name: "Col Error", cap: 0, size: minSize };
                const sorted = [...bearingData].sort((a,b) => (parseFloat(a[sizeKey]) || 0) - (parseFloat(b[sizeKey]) || 0));
                const match = sorted.find(b => (parseFloat(b[sizeKey]) || 0) >= minSize);
                if (match) {
                    return { 
                        name: match[nameKey] || "Unknown", 
                        cap: parseFloat(match[capKey]) || 0,
                        size: parseFloat(match[sizeKey]) 
                    };
                } else {
                    return { name: "Not Listed", cap: 0, size: minSize };
                }
            };

            let leftShaftDia = 40;
            let rightShaftDia = 40;
            let leftLabel = "Motor Shaft";
            let rightLabel = "Bearing Shaft";
            let showLeftShaft = true;
            let activeBearing = null;

            if (isTubular) {
                showLeftShaft = false; 
                rightShaftDia = brakeShaftValue;
                rightLabel = "Safety Brake Shaft";
                dom['bearing-name'].textContent = "Integrated / Safety Brake";
                dom['bearing-capacity'].textContent = "Check Brake Specs";
            } else if (isChainDrive) {
                rightShaftDia = brakeShaftValue;
                rightLabel = "Safety Brake Shaft";
                const minLeft = (brakeShaftValue < 30) ? 30 : brakeShaftValue;
                activeBearing = lookupBearing(minLeft);
                leftShaftDia = activeBearing.size; 
                leftLabel = "Bearing Shaft";
            } else {
                leftShaftDia = motorShaftRaw;
                leftLabel = "Motor Shaft";
                const minRight = (motorShaftRaw < 30) ? 30 : motorShaftRaw;
                activeBearing = lookupBearing(minRight);
                rightShaftDia = activeBearing.size; 
                rightLabel = "Bearing Shaft";
            }

            if (activeBearing) {
                dom['bearing-name'].textContent = activeBearing.name;
                dom['bearing-capacity'].textContent = activeBearing.cap > 0 ? `${activeBearing.cap} kgs` : "N/A";
                const totalLoad = parseFloat(dom['total-deflection-weight'].textContent) || 0;
                const capacity = activeBearing.cap;
                if (capacity > 0 && totalLoad > capacity) {
                    dom['bearing-warning'].style.display = 'block';
                    dom['bearing-capacity'].classList.add('warning-text');
                    dom['bearing-name'].classList.add('warning-text');
                    dom['bearing-warning'].textContent = `⚠️ Warning: Load (${totalLoad.toFixed(1)}kg) exceeds capacity (${capacity}kg)`;
                } else {
                    dom['bearing-warning'].style.display = 'none';
                    dom['bearing-capacity'].classList.remove('warning-text');
                    dom['bearing-name'].classList.remove('warning-text');
                }
            }

            const svgNS = "http://www.w3.org/2000/svg"; 
            const svg = document.createElementNS(svgNS, "svg");
            const svgWidth = 900; 
            const svgHeight = 350; 
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            const maxRefDia = Math.max(outerDia, collarSize, 120); 
            const scale = 140 / maxRefDia; 
            const stdFont = { 'font-family': 'Arial, sans-serif', 'font-size': '14px', 'fill': '#212529', 'font-weight': '500' };
            const stdFontBold = { ...stdFont, 'font-weight': 'bold' };
            const createElem = (type, attrs) => { 
                const el = document.createElementNS(svgNS, type); 
                for (const key in attrs) el.setAttribute(key, attrs[key]); return el; 
            };
            const defs = document.createElementNS(svgNS, 'defs');
            const marker = document.createElementNS(svgNS, 'marker'); 
            marker.setAttribute('id', 'axle-arrow'); marker.setAttribute('viewBox', '0 0 10 10'); 
            marker.setAttribute('refX', '0'); marker.setAttribute('refY', '5'); 
            marker.setAttribute('markerWidth', '6'); marker.setAttribute('markerHeight', '6'); marker.setAttribute('orient', 'auto-start-reverse');
            const arrowPath = document.createElementNS(svgNS, 'path'); 
            arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); arrowPath.setAttribute('fill', '#343a40'); 
            marker.appendChild(arrowPath); defs.appendChild(marker); svg.appendChild(defs);
            const cx = 150; 
            const cy = 175; 

            if (shape === 'octagonal') {
                const createOctagon = (flatToFlat, style) => {
                    const circumRadius = (flatToFlat / 2) / Math.cos(Math.PI / 8);
                    const points = [];
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI / 8) + i * (Math.PI / 4);
                        points.push(`${cx + (circumRadius * scale) * Math.cos(angle)},${cy - (circumRadius * scale) * Math.sin(angle)}`);
                    }
                    return createElem('polygon', { points: points.join(' '), ...style });
                };
                svg.appendChild(createOctagon(outerDia, { stroke: '#343a40', 'stroke-width': '2', fill: '#adb5bd' }));
                svg.appendChild(createOctagon(innerDia, { stroke: '#343a40', 'stroke-width': '1.5', fill: '#f8f9fa' }));
            } else { 
                svg.appendChild(createElem('circle', { cx: cx, cy: cy, r: (outerDia/2)*scale, stroke: '#343a40', 'stroke-width': '2', fill: '#adb5bd' }));
                svg.appendChild(createElem('circle', { cx: cx, cy: cy, r: (innerDia/2)*scale, stroke: '#343a40', 'stroke-width': '1.5', fill: '#f8f9fa' }));
            }

            if (collarSize > outerDia) {
                svg.appendChild(createElem('circle', { cx: cx, cy: cy, r: (collarSize/2)*scale, stroke: '#555', 'stroke-width': '1', 'stroke-dasharray': '4,2', fill: 'none' }));
                const txtCollar = createElem('text', { x: cx, y: cy - (collarSize/2)*scale - 10, 'text-anchor': 'middle', ...stdFont });
                txtCollar.textContent = `Collar: Ø${collarSize}`; svg.appendChild(txtCollar);
            }

            const odRadius = (outerDia/2) * scale;
            const dimLineY = cy - odRadius - 25;
            svg.appendChild(createElem('line', { x1: cx - odRadius, y1: cy - odRadius, x2: cx - odRadius, y2: dimLineY, stroke: '#adb5bd', 'stroke-dasharray':'2,2' }));
            svg.appendChild(createElem('line', { x1: cx + odRadius, y1: cy - odRadius, x2: cx + odRadius, y2: dimLineY, stroke: '#adb5bd', 'stroke-dasharray':'2,2' }));
            svg.appendChild(createElem('line', { x1: cx - odRadius, y1: dimLineY + 10, x2: cx + odRadius, y2: dimLineY + 10, stroke: '#212529', 'marker-start': 'url(#axle-arrow)', 'marker-end': 'url(#axle-arrow)' }));
            const textOD = createElem('text', { x: cx, y: dimLineY, 'text-anchor': 'middle', ...stdFontBold });
            textOD.textContent = `Ø${outerDia.toFixed(1)} OD`; svg.appendChild(textOD);

            if (innerDia > 40) {
                const idRadius = (innerDia/2) * scale;
                const dimIDY = cy + odRadius + 25;
                svg.appendChild(createElem('line', { x1: cx - idRadius, y1: cy + (innerDia/2)*scale, x2: cx - idRadius, y2: dimIDY, stroke: '#adb5bd', 'stroke-dasharray':'2,2' }));
                svg.appendChild(createElem('line', { x1: cx + idRadius, y1: cy + (innerDia/2)*scale, x2: cx + idRadius, y2: dimIDY, stroke: '#adb5bd', 'stroke-dasharray':'2,2' }));
                svg.appendChild(createElem('line', { x1: cx - idRadius, y1: dimIDY - 10, x2: cx + idRadius, y2: dimIDY - 10, stroke: '#212529', 'marker-start': 'url(#axle-arrow)', 'marker-end': 'url(#axle-arrow)' }));
                const textID = createElem('text', { x: cx, y: dimIDY + 5, 'text-anchor': 'middle', ...stdFont });
                textID.textContent = `Ø${innerDia.toFixed(1)} ID`; svg.appendChild(textID);
            }

            const angle45 = -Math.PI / 4; 
            const distOuter = odRadius + 60;
            const distInner = odRadius - (wallThick * scale) / 2;
            const startX = cx + distOuter * Math.cos(angle45);
            const startY = cy + distOuter * Math.sin(angle45);
            const endX = cx + distInner * Math.cos(angle45);
            const endY = cy + distInner * Math.sin(angle45);
            svg.appendChild(createElem('line', { x1: startX, y1: startY, x2: endX, y2: endY, stroke: '#212529', 'marker-end': 'url(#axle-arrow)' }));
            const textWall = createElem('text', { x: startX + 5, y: startY - 5, 'text-anchor': 'start', ...stdFont });
            textWall.textContent = `${wallThick.toFixed(1)}mm Wall`; svg.appendChild(textWall);

            const fvX = 500; 
            const fvW = 250; 
            const axleH = outerDia * scale;
            const fvY = cy - (axleH / 2);
            const leftShaftH = leftShaftDia * scale;
            const rightShaftH = rightShaftDia * scale;
            const shaftW = 50; 
            svg.appendChild(createElem('rect', { x: fvX, y: fvY, width: fvW, height: axleH, fill: '#adb5bd', stroke: '#343a40', 'stroke-width': '2' }));
            const scaledWall = wallThick * scale;
            const topWallY = fvY + scaledWall;
            const bottomWallY = fvY + axleH - scaledWall;
            svg.appendChild(createElem('line', { x1: fvX, y1: topWallY, x2: fvX + fvW, y2: topWallY, stroke: '#495057', 'stroke-width': '1', 'stroke-dasharray': '5,3' }));
            svg.appendChild(createElem('line', { x1: fvX, y1: bottomWallY, x2: fvX + fvW, y2: bottomWallY, stroke: '#495057', 'stroke-width': '1', 'stroke-dasharray': '5,3' }));
            const textFV = createElem('text', { x: fvX + fvW/2, y: cy + (outerDia/2)*scale + 30, 'text-anchor': 'middle', ...stdFontBold });
            textFV.textContent = "Axle Front View"; svg.appendChild(textFV);

            if (showLeftShaft) {
                svg.appendChild(createElem('rect', { x: fvX - shaftW, y: cy - (leftShaftH / 2), width: shaftW, height: leftShaftH, fill: '#6c757d', stroke: '#343a40', 'stroke-width': '1' }));
                const lDimX = fvX - shaftW - 15;
                svg.appendChild(createElem('line', { x1: lDimX, y1: cy - leftShaftH/2, x2: lDimX, y2: cy + leftShaftH/2, stroke: '#212529', 'marker-start': 'url(#axle-arrow)', 'marker-end': 'url(#axle-arrow)' }));
                svg.appendChild(createElem('line', { x1: lDimX, y1: cy - leftShaftH/2, x2: fvX - shaftW, y2: cy - leftShaftH/2, stroke: '#ccc', 'stroke-dasharray':'2,2' }));
                svg.appendChild(createElem('line', { x1: lDimX, y1: cy + leftShaftH/2, x2: fvX - shaftW, y2: cy + leftShaftH/2, stroke: '#ccc', 'stroke-dasharray':'2,2' }));
                const txtL = createElem('text', { x: lDimX - 5, y: cy, 'text-anchor': 'end', 'dominant-baseline':'middle', ...stdFontBold });
                txtL.textContent = `Ø${leftShaftDia.toFixed(1)}`; svg.appendChild(txtL);
                const lblL = createElem('text', { x: fvX - shaftW - 20, y: cy - (leftShaftH/2) - 15, 'text-anchor': 'end', ...stdFont });
                lblL.textContent = leftLabel; svg.appendChild(lblL);
            } else {
                svg.appendChild(createElem('line', { x1: fvX, y1: fvY, x2: fvX, y2: fvY+axleH, stroke:'#343a40', 'stroke-width': '4' }));
                const txtTub = createElem('text', { x: fvX + 10, y: cy, 'text-anchor': 'start', 'dominant-baseline': 'middle', 'fill': '#fff', 'font-family': 'Arial', 'font-size':'14px' });
                txtTub.textContent = "Tubular Motor"; svg.appendChild(txtTub);
            }

            svg.appendChild(createElem('rect', { x: fvX + fvW, y: cy - (rightShaftH / 2), width: shaftW, height: rightShaftH, fill: '#6c757d', stroke: '#343a40', 'stroke-width': '1' }));
            const rDimX = fvX + fvW + shaftW + 15;
            svg.appendChild(createElem('line', { x1: rDimX, y1: cy - rightShaftH/2, x2: rDimX, y2: cy + rightShaftH/2, stroke: '#212529', 'marker-start': 'url(#axle-arrow)', 'marker-end': 'url(#axle-arrow)' }));
            svg.appendChild(createElem('line', { x1: fvX + fvW + shaftW, y1: cy - rightShaftH/2, x2: rDimX, y2: cy - rightShaftH/2, stroke: '#ccc', 'stroke-dasharray':'2,2' }));
            svg.appendChild(createElem('line', { x1: fvX + fvW + shaftW, y1: cy + rightShaftH/2, x2: rDimX, y2: cy + rightShaftH/2, stroke: '#ccc', 'stroke-dasharray':'2,2' }));
            const txtR = createElem('text', { x: rDimX + 5, y: cy, 'text-anchor': 'start', 'dominant-baseline':'middle', ...stdFontBold });
            txtR.textContent = `Ø${rightShaftDia.toFixed(1)}`; svg.appendChild(txtR);
            const lblR = createElem('text', { x: fvX + fvW + shaftW + 20, y: cy - (rightShaftH/2) - 15, 'text-anchor': 'start', ...stdFont });
            lblR.textContent = rightLabel; svg.appendChild(lblR);
            container.appendChild(svg);
        }

function drawShutterGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, selectedGuide, visionData = null, endlockOffsets = {cast: 0, wind: 0}) {
            const container = dom['shutter-graphic-container']; container.innerHTML = '';
            // Pass guide to createBaseShutterGraphic
            const graphic = createBaseShutterGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, { visionOptions: visionData, endlockOffsets: endlockOffsets, guide: selectedGuide }, 'shutter');
            if(graphic) container.appendChild(graphic);
        }
        
        function drawWicketGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, wicket, wicketLathHeight, endlockOffsets = {cast: 0, wind: 0}) {
            const container = dom['wicket-graphic-container']; container.innerHTML = '';
            const graphic = createBaseShutterGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, { wicket: wicket, endlockOffsets: endlockOffsets }, 'wicket');
            if(graphic) container.appendChild(graphic);
        }

function drawTopDownWidthGraphic(calculatedWidths, guide, lath, additionalLength) {
    const container = dom['width-graphic-container']; 
    container.innerHTML = '';
    const { curtainWidth, clearOpening, overallWidth, epOffset, epSize } = calculatedWidths;
    if (!guide || !lath || !curtainWidth || curtainWidth <= 0) { return; }
    
    const guideWidthVal = parseFloat(guide[Object.keys(guide).find(k => k.toLowerCase().trim() === 'width')]) || 50; 
    const lathThickness = parseFloat(lath['Thickness']) || 14;

    const svgNS = "http://www.w3.org/2000/svg"; 
    const svg = document.createElementNS(svgNS, "svg");
    const svgWidth = 850; 
    const svgHeight = 400; 
    svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

    const defs = document.createElementNS(svgNS, 'defs');
    const marker = document.createElementNS(svgNS, 'marker'); 
    marker.setAttribute('id', 'dim-arrow-width-graphic'); 
    marker.setAttribute('viewBox', '0 0 10 10'); 
    marker.setAttribute('refX', '5'); marker.setAttribute('refY', '5'); 
    marker.setAttribute('markerWidth', '4'); marker.setAttribute('markerHeight', '4'); 
    marker.setAttribute('orient', 'auto-start-reverse');
    const arrowPath = document.createElementNS(svgNS, 'path'); 
    arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); 
    arrowPath.setAttribute('fill', '#343a40'); 
    marker.appendChild(arrowPath); 
    defs.appendChild(marker); 
    svg.appendChild(defs);

    const padding = { left: 130, right: 130, top: 40 };
    const availableWidth = svgWidth - padding.left - padding.right; 
    const scale = availableWidth / overallWidth;

    const scaledShutterWidth = curtainWidth * scale;
    const scaledOffset = epOffset * scale;
    const scaledEpSize = epSize * scale;
    const scaledGuideWidth = guideWidthVal * scale; 
    const scaledLathThick = lathThickness * scale;
    const scaledCO = clearOpening * scale;

    const centerX = svgWidth / 2;
    const topY = padding.top;
    const bottomY = topY + scaledEpSize; 
    
    const ovStartX = centerX - (availableWidth / 2);
    const ovEndX = centerX + (availableWidth / 2);
    const leftBackOfGuideX = ovStartX + scaledOffset;
    const rightBackOfGuideX = ovEndX - scaledOffset;
    const lathStartX = centerX - (scaledShutterWidth / 2);

    // --- 1. DRAW GUIDES (At the Top) ---
    const guideOpeningSize = scaledLathThick + (6 * scale); 

    const leftGuide = document.createElementNS(svgNS, 'path'); 
    leftGuide.setAttribute('d', `M ${leftBackOfGuideX + scaledGuideWidth},${topY} L ${leftBackOfGuideX},${topY} L ${leftBackOfGuideX},${topY + guideOpeningSize} L ${leftBackOfGuideX + scaledGuideWidth},${topY + guideOpeningSize}`); 
    leftGuide.setAttribute('fill', 'none');
    leftGuide.setAttribute('stroke', '#6c757d');
    leftGuide.setAttribute('stroke-width', '2');
    svg.appendChild(leftGuide);

    const rightGuide = document.createElementNS(svgNS, 'path'); 
    rightGuide.setAttribute('d', `M ${rightBackOfGuideX - scaledGuideWidth},${topY} L ${rightBackOfGuideX},${topY} L ${rightBackOfGuideX},${topY + guideOpeningSize} L ${rightBackOfGuideX - scaledGuideWidth},${topY + guideOpeningSize}`); 
    rightGuide.setAttribute('fill', 'none');
    rightGuide.setAttribute('stroke', '#6c757d');
    rightGuide.setAttribute('stroke-width', '2');
    svg.appendChild(rightGuide);

    // --- 2. DRAW CURTAIN (Aligned centrally in the Guide opening at the Top) ---
    const curtainY = topY + (guideOpeningSize / 2) - (scaledLathThick / 2);
    const curtain = document.createElementNS(svgNS, 'rect'); 
    curtain.setAttribute('x', lathStartX); 
    curtain.setAttribute('y', curtainY); 
    curtain.setAttribute('width', scaledShutterWidth); 
    curtain.setAttribute('height', scaledLathThick); 
    curtain.setAttribute('fill', '#ced4da');
    curtain.setAttribute('stroke', '#adb5bd');
    svg.appendChild(curtain);

    // --- 3. DRAW ENDPLATES (Yellow) ---
    const leftEp = document.createElementNS(svgNS, 'rect');
    leftEp.setAttribute('x', ovStartX);
    leftEp.setAttribute('y', topY);
    leftEp.setAttribute('width', scaledOffset);
    leftEp.setAttribute('height', scaledEpSize);
    leftEp.setAttribute('fill', '#ffc107');
    leftEp.setAttribute('stroke', '#d39e00');
    svg.appendChild(leftEp);

    const rightEp = document.createElementNS(svgNS, 'rect');
    rightEp.setAttribute('x', rightBackOfGuideX);
    rightEp.setAttribute('y', topY);
    rightEp.setAttribute('width', scaledOffset);
    rightEp.setAttribute('height', scaledEpSize);
    rightEp.setAttribute('fill', '#ffc107');
    rightEp.setAttribute('stroke', '#d39e00');
    svg.appendChild(rightEp);

    // --- 4. DIMENSION HELPER (Updated for Solid Lines and Offset labels) ---
    const drawDim = (yOffset, startX, endX, label, value, textPos = 'center') => {
        const lineY = bottomY + yOffset; 
        
        // Leader Lines (Changed to Solid)
        const lead1 = document.createElementNS(svgNS, 'line');
        lead1.setAttribute('x1', startX); lead1.setAttribute('y1', bottomY);
        lead1.setAttribute('x2', startX); lead1.setAttribute('y2', lineY + 5);
        lead1.setAttribute('stroke', '#343a40'); lead1.setAttribute('stroke-width', '0.8');
        svg.appendChild(lead1);

        const lead2 = document.createElementNS(svgNS, 'line');
        lead2.setAttribute('x1', endX); lead2.setAttribute('y1', bottomY);
        lead2.setAttribute('x2', endX); lead2.setAttribute('y2', lineY + 5);
        lead2.setAttribute('stroke', '#343a40'); lead2.setAttribute('stroke-width', '0.8');
        svg.appendChild(lead2);

        // Dimension Line
        const line = document.createElementNS(svgNS, 'line'); 
        line.setAttribute('x1', startX); line.setAttribute('y1', lineY); 
        line.setAttribute('x2', endX); line.setAttribute('y2', lineY); 
        line.setAttribute('stroke', '#343a40');
        line.setAttribute('marker-start', 'url(#dim-arrow-width-graphic)'); 
        line.setAttribute('marker-end', 'url(#dim-arrow-width-graphic)'); 
        svg.appendChild(line);

        // Text Label (Moved UP above the line)
        const labelText = document.createElementNS(svgNS, 'text'); 
        labelText.textContent = label + ` (${value.toFixed(0)} mm)`; 
        labelText.setAttribute('class', 'width-graphic-value'); 
        labelText.setAttribute('font-weight', 'bold');
        labelText.setAttribute('font-family', 'sans-serif');
        labelText.setAttribute('font-size', '13px');
        
        if (textPos === 'left') {
            labelText.setAttribute('x', startX - 45); // Increased distance
            labelText.setAttribute('text-anchor', 'end');
            labelText.setAttribute('y', lineY + 4); // Keep side labels centered to line
        } else if (textPos === 'right') {
            labelText.setAttribute('x', endX + 45); // Increased distance
            labelText.setAttribute('text-anchor', 'start');
            labelText.setAttribute('y', lineY + 4); // Keep side labels centered to line
        } else {
            labelText.setAttribute('x', startX + (endX - startX) / 2); 
            labelText.setAttribute('text-anchor', 'middle');
            labelText.setAttribute('y', lineY - 8); // Moved UP above line
        }
        svg.appendChild(labelText);
    };

    // --- 5. RENDER DIMENSIONS ---
    
    // OFFSETS
    if (epOffset > 0) {
        drawDim(25, ovStartX, leftBackOfGuideX, 'Offset', epOffset, 'left');
        drawDim(25, rightBackOfGuideX, ovEndX, 'Offset', epOffset, 'right');
    }

    // DIMENSION STACK
    drawDim(60, centerX - (scaledCO / 2), centerX + (scaledCO / 2), 'Clear Opening', clearOpening);
    drawDim(95, lathStartX, lathStartX + scaledShutterWidth, 'Curtain Width', curtainWidth);
    drawDim(130, ovStartX, ovEndX, 'Overall Width (Reveal)', overallWidth);
    
    container.appendChild(svg);
}


function createBaseShutterGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, options = {}, idSuffix = 'default') {
            const svgNS = "http://www.w3.org/2000/svg";
            if (!realWidth || !lath || !bottomLath || !axle) { return null; }
            
            // Dynamic Hangdown Logic
            let hangdownValue = 50; 
            const hangdownKey = Object.keys(bottomLath).find(k => k.toLowerCase().trim() === 'hangdown');
            if (hangdownKey) {
                const val = parseFloat(bottomLath[hangdownKey]);
                if (!isNaN(val)) hangdownValue = val;
            }

            const { wicket = null, visionOptions = null, endlockOffsets = { cast: 0, wind: 0 }, guide = null } = options;
            const selectedEndlockIndex = dom.endlockType.value; 
            const endlocksSelected = selectedEndlockIndex !== "" && endlockData[selectedEndlockIndex];
            
            const svg = document.createElementNS(svgNS, "svg");
            const svgWidth = 850; 
            
            // Padding (Left 130 to allow for staggered dimensions)
            const basePadding = { top: 25, right: 300, bottom: 60, left: 130 }; 
            const topDimClearance = 10; 
            const totalTopPadding = basePadding.top + topDimClearance;
            
            // Dimensions
            const mainLathHeight = parseFloat(lath['Compressed lath height']);
            const mainLathThickness = parseFloat(lath['Thickness']) || 14;
            const bottomLathHeight = parseFloat(bottomLath['BLath height'] || mainLathHeight);
            const axleDiameter = parseFloat(axle['Diameter']);
            let totalRealCompressedHeight = parseFloat(dom['curtain-height-compressed'].textContent) + axleDiameter;
            const totalRealAxleWidth = realWidth + (additionalLength || 0);
            
            if (totalRealCompressedHeight <= 0 || totalRealAxleWidth <= 0) return null;
            
            const graphWidth = svgWidth - basePadding.left - basePadding.right; 
            const scale = graphWidth / totalRealAxleWidth;
            const graphHeight = totalRealCompressedHeight * scale; 
            const svgHeight = graphHeight + totalTopPadding + basePadding.bottom;
            
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            
            const style = document.createElementNS(svgNS, "style");
            style.textContent = `
                .dimension-text { font-family: sans-serif; font-size: 12px; fill: #343a40; }
                .dimension-text.bold { font-weight: bold; font-size: 14px; }
                .leader-line { stroke: #343a40; stroke-width: 0.5; stroke-dasharray: 2,2; }
                .dimension-line { stroke: #343a40; stroke-width: 1; }
            `;
            svg.appendChild(style);

            const defs = document.createElementNS(svgNS, 'defs');
            const marker = document.createElementNS(svgNS, 'marker'); 
            marker.setAttribute('id', `dim-arrow-${idSuffix}`); 
            marker.setAttribute('viewBox', '0 0 10 10'); marker.setAttribute('refX', '5'); marker.setAttribute('refY', '5'); marker.setAttribute('markerWidth', '6'); marker.setAttribute('markerHeight', '6'); marker.setAttribute('orient', 'auto-start-reverse');
            const arrowPath = document.createElementNS(svgNS, 'path'); 
            arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); arrowPath.setAttribute('fill', '#343a40'); 
            marker.appendChild(arrowPath); defs.appendChild(marker); svg.appendChild(defs);
            
            const createElem = (type, attrs) => {
                const el = document.createElementNS(svgNS, type); 
                for (const key in attrs) el.setAttribute(key, attrs[key]); 
                return el;
            };

            const scaledTotalAxleWidth = totalRealAxleWidth * scale; 
            const scaledShutterWidth = realWidth * scale;
            const startX = basePadding.left; 
            const lathStartX = startX + (scaledTotalAxleWidth - scaledShutterWidth) / 2;
            const scaledCastOffset = endlockOffsets.cast * scale; 
            const scaledWindOffset = endlockOffsets.wind * scale;
            
            const createLeaderLine = (x1, y1, x2, y2) => {
                svg.appendChild(createElem('line', { x1:x1, y1:y1, x2:x2, y2:y2, class:'leader-line' }));
            };

            const drawDimensionLine = (x1, y1, x2, y2, label, orientation = 'horizontal', textSide = 'right') => {
                svg.appendChild(createElem('line', { x1:x1, y1:y1, x2:x2, y2:y2, class:'dimension-line', 'marker-start':`url(#dim-arrow-${idSuffix})`, 'marker-end':`url(#dim-arrow-${idSuffix})` }));
                const text = createElem('text', { class:'dimension-text' });
                text.textContent = label;
                if (orientation === 'horizontal') { 
                    text.setAttribute('x', x1 + (x2 - x1) / 2); text.setAttribute('y', y1 - 6); 
                    text.setAttribute('text-anchor', 'middle');
                } else {
                    const textY = y1 + (y2 - y1) / 2; let textX; 
                    if (textSide === 'left') { 
                        textX = x1 - 6; 
                        text.setAttribute('dy', '-0.5em'); 
                    } else { 
                        textX = x1 + 6; 
                        text.setAttribute('dy', '1em'); 
                    }
                    text.setAttribute('x', textX); text.setAttribute('y', textY); 
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('transform', `rotate(-90, ${textX}, ${textY})`);
                } 
                svg.appendChild(text);
            };

            // --- UPDATED ANNOTATION HELPER WITH WORD WRAPPING ---
            const drawAnnotation = (startY, endY, label, offset = 25) => {
                const lineX = basePadding.left - offset; 
                const textX = lineX - 12;
                
                // Draw Dimension Line & Leaders
                svg.appendChild(createElem('line', { x1:lineX, y1:startY, x2:lineX, y2:endY, class:'dimension-line', 'marker-start':`url(#dim-arrow-${idSuffix})`, 'marker-end':`url(#dim-arrow-${idSuffix})` }));
                createLeaderLine(lineX, startY, lathStartX, startY);
                createLeaderLine(lineX, endY, lathStartX, endY);

                const textEl = createElem('text', { class:'dimension-text' });
                const middleY = startY + (endY - startY) / 2;
                
                // Apply rotation
                textEl.setAttribute('transform', `rotate(-90, ${textX}, ${middleY})`);
                textEl.setAttribute('x', textX); 
                textEl.setAttribute('y', middleY);
                textEl.setAttribute('text-anchor', 'middle');

                // Wrapping Logic
                const segmentHeight = Math.abs(endY - startY);
                const charLimit = Math.floor(segmentHeight / 6.5); // Approx 6.5px per char for 12px font
                
                if (label.length <= charLimit) {
                    // Fits on one line
                    textEl.textContent = label;
                    textEl.setAttribute('dy', '0.35em'); // Center vertically relative to baseline
                } else {
                    // Needs wrapping
                    const words = label.split(' ');
                    let lines = [];
                    let currentLine = words[0];

                    for (let i = 1; i < words.length; i++) {
                        if ((currentLine + " " + words[i]).length < charLimit) {
                            currentLine += " " + words[i];
                        } else {
                            lines.push(currentLine);
                            currentLine = words[i];
                        }
                    }
                    lines.push(currentLine);

                    // Render lines as tspans
                    // Calculate centering offset. Line height ~1.1em.
                    const lineHeight = 1.1; 
                    const totalHeightEm = lines.length * lineHeight;
                    // Start dy shifts the first line up so the block is centered
                    const startDy = -((totalHeightEm - lineHeight) / 2) + 0.35; 

                    lines.forEach((lineStr, idx) => {
                        const tspan = document.createElementNS(svgNS, 'tspan');
                        tspan.textContent = lineStr;
                        tspan.setAttribute('x', textX); // Must reset X inside rotated context
                        if (idx === 0) {
                            tspan.setAttribute('dy', `${startDy}em`);
                        } else {
                            tspan.setAttribute('dy', `${lineHeight}em`);
                        }
                        textEl.appendChild(tspan);
                    });
                }
                
                svg.appendChild(textEl);
            };
            
            const scaledAxleHeight = axleDiameter * scale; 
            const axleY = totalTopPadding; 
            const axleCenterlineY = axleY + scaledAxleHeight / 2; 
            const bottomY = totalTopPadding + graphHeight; 
            let currentY = bottomY;
            let endplateTopY = axleY; 
            let endplateSize = 0;
            
            if (selectedEndplate) { 
                endplateSize = parseFloat(selectedEndplate.Size) || 0; 
                if (endplateSize > 0) { 
                    const scaledEndplateHeight = endplateSize * scale; 
                    endplateTopY = axleCenterlineY - (scaledEndplateHeight / 2); 
                } 
            }
            
// Inside createBaseShutterGraphic()
// Right before drawing the bottom lath:

// FETCH SLOPING DATA
            const slopingData = dom.isSlopingBottomLath && dom.isSlopingBottomLath.checked ? getSlopingBottomData() : { maxH: 0, leftH: 0, rightH: 0 };
            
            // Track the absolute lowest points for dimensioning
            let absoluteLeftBottomY = bottomY;
            let absoluteRightBottomY = bottomY;

            // 1. Draw the Sloping Section Graphic First (sitting at the bottom-most coordinate)
            if (slopingData.maxH > 0) {
                const scaledLeftH = slopingData.leftH * scale;
                const scaledRightH = slopingData.rightH * scale;
                const scaledMaxH = slopingData.maxH * scale;
                const slopingTopY = currentY - scaledMaxH;
                
                absoluteLeftBottomY = slopingTopY + scaledLeftH;
                absoluteRightBottomY = slopingTopY + scaledRightH;
                
                const points = `
                    ${lathStartX},${slopingTopY}
                    ${lathStartX + scaledShutterWidth},${slopingTopY}
                    ${lathStartX + scaledShutterWidth},${slopingTopY + scaledRightH}
                    ${lathStartX},${slopingTopY + scaledLeftH}
                `;
                svg.appendChild(createElem('polygon', { points: points, fill: '#dee2e6', stroke: '#495057', 'stroke-width': '1' }));
                
                // Step up to draw the rest of the shutter properly
                currentY = slopingTopY;
            }

            // 2. Draw Bottom Lath
            const scaledBottomLathHeight = bottomLathHeight * scale; 
            currentY -= scaledBottomLathHeight;
            svg.appendChild(createElem('rect', { x:lathStartX, y:currentY, width:scaledShutterWidth, height:scaledBottomLathHeight, class:'shutter-bottomlath-graphic' }));
            const bottomLathTopY = currentY;

            const drawEndlocks = (lathY, lathH, leftOffset = 0, style='endlock-graphic') => {
                const endlockSide = lathH * 0.8; const endlockY = lathY + (lathH - endlockSide) / 2;
                svg.appendChild(createElem('rect', { x: lathStartX + leftOffset - (style.includes('wind')?scaledWindOffset:scaledCastOffset), y:endlockY, width:(style.includes('wind')?endlockSide*2.5:endlockSide), height:endlockSide, class:style }));
                svg.appendChild(createElem('rect', { x: lathStartX + scaledShutterWidth + (style.includes('wind')?scaledWindOffset:scaledCastOffset) - (style.includes('wind')?endlockSide*2.5:endlockSide), y:endlockY, width:(style.includes('wind')?endlockSide*2.5:endlockSide), height:endlockSide, class:style }));
            };

            let lathVisualCounter = 1; 
            const isWindLath = (lath['Name'] || '').toLowerCase().includes('wind');
            const wicketRealHeight = wicket ? (parseFloat(wicket.Height) || 0) : 0; 
            const scaledWicketHeight = wicketRealHeight * scale;
            const wicketGap = 10; const scaledWicketGap = wicketGap * scale; 
            const wicketTopY = bottomLathTopY - scaledWicketGap - scaledWicketHeight; 
            const scaledWicketWidth = wicket ? (parseFloat(wicket.Width) || 0) * scale : 0;

            const drawLathBlock = (count, cssClass) => {
                 const scaledH = (cssClass.includes('vision')) ? 
                                  parseFloat(visionOptions.visionLath['Compressed lath height']) * scale : 
                                  mainLathHeight * scale;

                 for (let i = 0; i < count; i++) {
                    currentY -= scaledH; 
                    svg.appendChild(createElem('rect', { x:lathStartX, y:currentY, width:scaledShutterWidth, height:scaledH, class:cssClass }));
                    const leftOffset = (wicket && (currentY + scaledH) > wicketTopY) ? scaledWicketWidth : 0;
                    if (isWindLath) {
                        const isWindPos = (lathVisualCounter === 2 || lathVisualCounter === 4 || lathVisualCounter === 6 || lathVisualCounter === 8) || (lathVisualCounter > 8 && lathVisualCounter % 8 === 0);
                        if (lathVisualCounter % 2 !== 0 && !isWindPos) drawEndlocks(currentY, scaledH, leftOffset);
                        if (isWindPos) drawEndlocks(currentY, scaledH, leftOffset, 'wind-endlock-graphic');
                    } else if (endlocksSelected && lathVisualCounter % 2 !== 0) { 
                        drawEndlocks(currentY, scaledH, leftOffset); 
                    }
                    lathVisualCounter++;
                 }
                 return currentY;
            };

            if (visionOptions && visionOptions.visionLath) {
                const vo = visionOptions; 
                
                const sectionBottom1 = currentY;
                drawLathBlock(vo.numLathsBelow, 'shutter-lath-graphic');
                if (vo.numLathsBelow > 0) drawAnnotation(currentY, sectionBottom1, `${lath['Name']} (x${vo.numLathsBelow})`, 25);
                
                const sectionBottom2 = currentY;
                drawLathBlock(vo.numLathsVision, 'shutter-vision-lath-graphic');
                if (vo.numLathsVision > 0) drawAnnotation(currentY, sectionBottom2, `${vo.visionLath['Name']} (x${vo.numLathsVision})`, 65);
                
                const sectionBottom3 = currentY;
                drawLathBlock(vo.numLathsAbove, 'shutter-lath-graphic');
                if (vo.numLathsAbove > 0) drawAnnotation(currentY, sectionBottom3, `${lath['Name']} (x${vo.numLathsAbove})`, 25);

                drawAnnotation(currentY, bottomLathTopY, `Total Laths: ${numLaths}`, 105);

            } else if (numLaths > 0) {
                 drawLathBlock(numLaths, 'shutter-lath-graphic');
                 drawAnnotation(currentY, bottomLathTopY, `${lath['Name']} (x${numLaths})`, 25);
            }

            if (endplateSize > 0) {
                const scaledEndplateHeight = endplateSize * scale;
                svg.appendChild(createElem('rect', { x:startX, y:endplateTopY, width:scaledTotalAxleWidth, height:scaledEndplateHeight, class:'endplate-box-graphic' }));
            }
            svg.appendChild(createElem('rect', { x:startX, y:axleY, width:scaledTotalAxleWidth, height:scaledAxleHeight, class:'shutter-axle-graphic' }));
            svg.appendChild(createElem('line', { x1:startX, y1:axleCenterlineY, x2:startX+scaledTotalAxleWidth, y2:axleCenterlineY, class:'axle-centerline-graphic' }));
            if (wicket) {
                svg.appendChild(createElem('rect', { x:lathStartX, y:wicketTopY, width:scaledWicketWidth, height:scaledWicketHeight, class:'wicket-door-graphic' }));
            }

            // FRONT VIEW DIMENSIONS
            // Shift overall height dimension further right if sloping lath is active to make room
            const rightDimX = startX + scaledTotalAxleWidth + (slopingData.maxH > 0 ? 55 : 20);
            drawDimensionLine(rightDimX, axleCenterlineY, rightDimX, bottomY, `${parseFloat(dom.height.value).toFixed(0)} mm to Center of Axle`, 'vertical', 'left');
            createLeaderLine(rightDimX, axleCenterlineY, startX + scaledTotalAxleWidth, axleCenterlineY);
            createLeaderLine(rightDimX, bottomY, startX + scaledTotalAxleWidth, bottomY);

            // Bottom Lath & Slope Dimensions
            const leftDimX_Aligned = basePadding.left - 25; 

            if (slopingData.maxH > 0) {
                // If Sloping Lath is active, calculate totals and draw on BOTH sides
                const totalLeftH = bottomLathHeight + slopingData.leftH;
                const totalRightH = bottomLathHeight + slopingData.rightH;
                
                // Left Side Dimension
                drawDimensionLine(leftDimX_Aligned, bottomLathTopY, leftDimX_Aligned, absoluteLeftBottomY, `${totalLeftH.toFixed(0)} mm`, 'vertical', 'left');
                createLeaderLine(leftDimX_Aligned, bottomLathTopY, lathStartX, bottomLathTopY); 
                createLeaderLine(leftDimX_Aligned, absoluteLeftBottomY, lathStartX, absoluteLeftBottomY);

                // Right Side Dimension (Inner Dimension)
                const rightInnerDimX = startX + scaledTotalAxleWidth + 20;
                drawDimensionLine(rightInnerDimX, bottomLathTopY, rightInnerDimX, absoluteRightBottomY, `${totalRightH.toFixed(0)} mm`, 'vertical', 'right');
                createLeaderLine(lathStartX + scaledShutterWidth, bottomLathTopY, rightInnerDimX, bottomLathTopY); 
                createLeaderLine(lathStartX + scaledShutterWidth, absoluteRightBottomY, rightInnerDimX, absoluteRightBottomY);

            } else if (bottomLathHeight > 0) {
                // Standard non-sloping display (Left Side Only)
                drawDimensionLine(leftDimX_Aligned, bottomLathTopY, leftDimX_Aligned, bottomY, `${bottomLathHeight.toFixed(0)} mm`, 'vertical', 'left');
                createLeaderLine(leftDimX_Aligned, bottomLathTopY, lathStartX, bottomLathTopY); 
                createLeaderLine(leftDimX_Aligned, bottomY, lathStartX, bottomY);
            }

            // --- SECTION VIEW (SIDE VIEW) ---
            const sectionX = startX + scaledTotalAxleWidth + 130; 
            const scaledBoxSize = (endplateSize > 0 ? endplateSize : (axleDiameter + 50)) * scale;
            const boxLeft = sectionX;
            const boxTop = endplateTopY;
            const boxBottomY = boxTop + scaledBoxSize;
            
            // Wall Line
            svg.appendChild(createElem('line', { x1: boxLeft, y1: boxTop, x2: boxLeft, y2: bottomY, stroke: '#343a40', 'stroke-width': 2 }));
            
            // Draw Box
            svg.appendChild(createElem('rect', { x: boxLeft, y: boxTop, width: scaledBoxSize, height: scaledBoxSize, fill: 'none', stroke: '#343a40', 'stroke-width': 1 }));

            // Draw Axle (Section)
            const sectionAxleRadius = (axleDiameter / 2) * scale;
            svg.appendChild(createElem('circle', { cx: boxLeft + (scaledBoxSize/2), cy: axleCenterlineY, r: sectionAxleRadius, class: 'shutter-axle-graphic' }));

            // Draw Guide
            let guideWidth = 50; 
            if (guide) {
                const wKey = Object.keys(guide).find(k => k.toLowerCase() === 'width');
                if (wKey) guideWidth = parseFloat(guide[wKey]);
            }
            const scaledGuideWidth = guideWidth * scale;
            const guideX = boxLeft; 
            
            svg.appendChild(createElem('rect', { x: guideX, y: boxBottomY, width: scaledGuideWidth, height: (bottomY - boxBottomY), fill: 'none', stroke: '#6c757d', 'stroke-width': 1 }));
            
            // Draw Grey Laths (Down)
            const scaledLathThickness = mainLathThickness * scale;
            const lathX = guideX + (scaledGuideWidth - scaledLathThickness) / 2;
            let downLathY = bottomY;
            let safetyCounter = 0;
            while(downLathY > boxBottomY && safetyCounter < 200) {
                 const h = mainLathHeight * scale;
                 downLathY -= h;
                 if(downLathY < boxBottomY) break; 
                 svg.appendChild(createElem('rect', { x: lathX, y: downLathY, width: scaledLathThickness, height: h, fill: '#adb5bd', stroke: '#6c757d', 'stroke-width': 0.5 }));
                 safetyCounter++;
            }

            // --- SPIRAL LATH LOGIC (Yellow with Black Outline) ---
            const coilCenterX = boxLeft + (scaledBoxSize/2);
            const coilCenterY = axleCenterlineY;
            const maxCoilDia = parseFloat(dom['max-coil-diameter'].textContent) || axleDiameter;
            const scaledMaxCoilRadius = (maxCoilDia / 2) * scale;
            
            const pStartAngle = Math.PI / 6; // 4 o'clock
            const thicknessScale = scaledLathThickness;
            const radialGrowth = scaledMaxCoilRadius - sectionAxleRadius;
            
            if (radialGrowth > 0) {
                let currentAngle = pStartAngle; 
                let currentR = sectionAxleRadius;
                const step = -0.1; // CCW
                let points = [];
                points.push(`M ${coilCenterX + currentR * Math.cos(currentAngle)} ${coilCenterY + currentR * Math.sin(currentAngle)}`);
                
                while(true) {
                    currentAngle += step;
                    currentR += (Math.abs(step) / (2*Math.PI)) * thicknessScale;
                    const x = coilCenterX + currentR * Math.cos(currentAngle);
                    const y = coilCenterY + currentR * Math.sin(currentAngle);
                    points.push(`L ${x} ${y}`);
                    if (currentR >= scaledMaxCoilRadius) {
                        const dx = x - coilCenterX;
                        const dy = y - coilCenterY;
                        if (dx < 0 && Math.abs(dy) < 2) break; // 9 o'clock
                    }
                    if (points.length > 5000) break; 
                }
                
                const lastPoint = points[points.length-1].split(' ');
                const lx = parseFloat(lastPoint[1]);
                const ly = parseFloat(lastPoint[2]);
                const dangleDist = hangdownValue * scale;
                const dangleTopY = boxBottomY;

                const pathD = points.join(" ");
                svg.appendChild(createElem('path', { d: pathD, fill: 'none', stroke: '#343a40', 'stroke-width': scaledLathThickness + 1, 'stroke-linecap': 'butt' }));
                svg.appendChild(createElem('line', { x1: lx, y1: ly, x2: lx, y2: dangleTopY, stroke: '#343a40', 'stroke-width': scaledLathThickness + 1 }));
                svg.appendChild(createElem('rect', { x: lx - (scaledLathThickness/2) - 0.5, y: dangleTopY, width: scaledLathThickness + 1, height: dangleDist + 0.5, fill: '#343a40' }));

                svg.appendChild(createElem('path', { d: pathD, fill: 'none', stroke: '#ffc107', 'stroke-width': scaledLathThickness - 0.5, 'stroke-linecap': 'butt' }));
                svg.appendChild(createElem('line', { x1: lx, y1: ly, x2: lx, y2: dangleTopY, stroke: '#ffc107', 'stroke-width': scaledLathThickness - 0.5 }));
                svg.appendChild(createElem('rect', { x: lx - (scaledLathThickness/2), y: dangleTopY, width: scaledLathThickness - 0.5, height: dangleDist, fill: '#ffc107' }));
            }
            
            // --- SECTION DIMENSIONS ---
            const rightSharedLineX = boxLeft + scaledBoxSize + 20;

            drawDimensionLine(rightSharedLineX, boxTop, rightSharedLineX, boxBottomY, `${endplateSize.toFixed(0)} mm`, 'vertical', 'right');
            createLeaderLine(boxLeft + scaledBoxSize, boxTop, rightSharedLineX, boxTop);
            
            const heightToUnder = parseFloat(dom.height.value) - (endplateSize/2);
            drawDimensionLine(rightSharedLineX, boxBottomY, rightSharedLineX, bottomY, `${heightToUnder.toFixed(0)} mm to Underside`, 'vertical', 'right');
            createLeaderLine(boxLeft + scaledBoxSize, boxBottomY, rightSharedLineX, boxBottomY);
            createLeaderLine(boxLeft + scaledBoxSize, bottomY, rightSharedLineX, bottomY);

            const farRightDimX = rightSharedLineX + 30;
            const heightToTop = parseFloat(dom.height.value) + (endplateSize/2);
            drawDimensionLine(farRightDimX, boxTop, farRightDimX, bottomY, `${heightToTop.toFixed(0)} mm to Top`, 'vertical', 'right');
            createLeaderLine(rightSharedLineX, boxTop, farRightDimX, boxTop);
            createLeaderLine(rightSharedLineX, bottomY, farRightDimX, bottomY);

            const dangleDist = hangdownValue * scale;
            const clearOpeningY = boxBottomY + dangleDist;
            const coDimX = boxLeft - 20; 
            const calculatedCO = parseFloat(dom.height.value) - (endplateSize/2) - hangdownValue;

            // --- ADDED HANG DOWN DIMENSION ---
            if (hangdownValue > 0) {
                drawDimensionLine(coDimX, boxBottomY, coDimX, clearOpeningY, `${hangdownValue.toFixed(0)} mm Hang Down`, 'vertical', 'left');
                createLeaderLine(coDimX, boxBottomY, boxLeft, boxBottomY);
            }
            // ---------------------------------

            drawDimensionLine(coDimX, clearOpeningY, coDimX, bottomY, `${calculatedCO.toFixed(0)} mm Clear Opening`, 'vertical', 'left');
            createLeaderLine(coDimX, clearOpeningY, sectionX + 10, clearOpeningY); 
            createLeaderLine(coDimX, bottomY, guideX, bottomY);

            return svg;
        }


		function switchTab(targetTabId) {
        document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
        tabButtons.forEach(b => b.classList.remove('active'));
        document.getElementById(targetTabId).classList.add('active');
        document.querySelector(`.tab-button[data-tab="${targetTabId}"]`).classList.add('active');
        if (targetTabId === 'axle-content') {
            const length = parseFloat(dom['total-axle-length'].textContent) || 0;
            const deflection = parseFloat(dom['axle-deflection'].textContent) || 0;
            drawDeflectionGraphic(length, deflection);
            const selectedAxleIndex = dom.axleType.value;
            if(selectedAxleIndex !== "" && axleData[selectedAxleIndex]) {
                const collarSize = parseFloat(dom.collarSize.value) || 0;
                drawAxleCrossSection(axleData[selectedAxleIndex], collarSize);
            } else { drawAxleCrossSection(null); }
        } else if (targetTabId === 'motor-content') { drawTorqueGraph(lastTorqueProfile, dom['torque-graph-container']);
        } else if(targetTabId === 'wicket-content') {
             const curtainWidth = parseFloat(dom['calculated-curtain-width'].textContent) || 0; updateWicketCalculationsAndGraphic({cast:0, wind:0}, curtainWidth);
        } else if (targetTabId === 'endplate-content') {
            const selectedIndex = parseInt(dom.endplateSelector.value, 10);
            const selectedLath = lathData.length > 0 ? lathData[dom.lathType.value] : null;
            const selectedAxle = axleData.length > 0 ? axleData[dom.axleType.value] : null;
            const numLaths = parseInt(dom['lath-count'].textContent) || 0;
            if (!isNaN(selectedIndex) && currentFilteredEndplates[selectedIndex]) {
                const plate = currentFilteredEndplates[selectedIndex]; drawEndplateGraphic(plate, maxCoilDiameter, selectedAxle, selectedLath, numLaths); calculateEndplateForces(plate);
            } else { drawEndplateGraphic(null, 0, null, null, 0); calculateEndplateForces(null); }
        } else if (targetTabId === 'chain-content') {
            updateChainCalculations();
        } else if (targetTabId === 'safety-brake-content') {
            calculateSafetyBrakeSelection();
        } else if (targetTabId === 'slope-content') {
            drawSlopingLathGraphics();
        }
    };
    
    updateAllCalculations();
</script>

<script>
    window.addEventListener('load', () => {
        initializeAdminControls(); 
        const excelFileUrl = 'https://raw.githubusercontent.com/rob-hyrons/LT-Calculateur-de-volet-roulant/main/Calculation%20Data.xlsx';
        const statusDiv = document.getElementById('import-status');
        statusDiv.textContent = 'Loading data from repository...'; statusDiv.style.color = '#555';
        fetch(excelFileUrl).then(response => {
            if (!response.ok) { throw new Error(`Network response was not ok: ${response.statusText}`); }
            return response.arrayBuffer();
        }).then(fileData => { processExcelFile(fileData); }).catch(error => {
            statusDiv.textContent = 'Failed to fetch the Excel file from the repository. Please check the console for details.'; statusDiv.style.color = 'red'; console.error('There has been a problem with the fetch operation:', error);});
    });
</script>

<script>
    function setupReportFilters() {
        const lathSelect = document.getElementById('reportLathType');
        populateDropdown(lathSelect, lathData, 'Name');

        const lathSelect2 = document.getElementById('reportLathType2');
        lathSelect2.innerHTML = `<option value="">-- None (Use Primary) --</option>`;
        lathData.forEach((item, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = item.Name;
            lathSelect2.appendChild(option);
        });

        const endlockSelect = document.getElementById('reportEndlockType');
        populateDropdown(endlockSelect, endlockData, 'Description');
        const bottomLathSelect = document.getElementById('reportBottomLathType');
        populateDropdown(bottomLathSelect, bottomLathData, 'Bottom lath name');
        
        let manufacturerKey = '', voltageKey = '', mountingKey = '', usageKey = '';
        if (motorData.length > 0) {
            const firstMotor = motorData[0];
            manufacturerKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'manufacturer');
            voltageKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'voltage');
            mountingKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'mounting type');
            usageKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'usage type');
        }
        
        const setupFilterGroup = (containerId, key, data, className) => {
            const container = document.getElementById(containerId); container.innerHTML = '';
            if (key) {
                const uniqueValues = [...new Set(data.map(item => item[key]).filter(val => val))];
                uniqueValues.sort().forEach(value => {
                    const controlItem = document.createElement('div'); controlItem.className = 'admin-control-item';
                    controlItem.innerHTML = `<label><input type="checkbox" class="${className}" value="${value}" checked> ${value}</label>`;
                    container.appendChild(controlItem);
                });
            } else { container.innerHTML = `<p><em>Column not found in data.</em></p>`; }
        };
        
        setupFilterGroup('report-motor-filter-container', manufacturerKey, motorData, 'report-motor-checkbox');
        setupFilterGroup('report-motor-voltage-filter-container', voltageKey, motorData, 'report-voltage-checkbox');
        setupFilterGroup('report-motor-mounting-filter-container', mountingKey, motorData, 'report-mounting-checkbox');
        setupFilterGroup('report-motor-usage-filter-container', usageKey, motorData, 'report-usage-checkbox');

        document.getElementById('reportMotorSelectAll').addEventListener('click', () => document.querySelectorAll('.report-motor-checkbox').forEach(cb => cb.checked = true));
        document.getElementById('reportMotorDeselectAll').addEventListener('click', () => document.querySelectorAll('.report-motor-checkbox').forEach(cb => cb.checked = false));
        document.getElementById('reportVoltageSelectAll').addEventListener('click', () => document.querySelectorAll('.report-voltage-checkbox').forEach(cb => cb.checked = true));
        document.getElementById('reportVoltageDeselectAll').addEventListener('click', () => document.querySelectorAll('.report-voltage-checkbox').forEach(cb => cb.checked = false));
        document.getElementById('reportMountingSelectAll').addEventListener('click', () => document.querySelectorAll('.report-mounting-checkbox').forEach(cb => cb.checked = true));
        document.getElementById('reportMountingDeselectAll').addEventListener('click', () => document.querySelectorAll('.report-mounting-checkbox').forEach(cb => cb.checked = false));
        document.getElementById('reportUsageSelectAll').addEventListener('click', () => document.querySelectorAll('.report-usage-checkbox').forEach(cb => cb.checked = true));
        document.getElementById('reportUsageDeselectAll').addEventListener('click', () => document.querySelectorAll('.report-usage-checkbox').forEach(cb => cb.checked = false));
        
        const genBtn = document.getElementById('generateCsvButton');
        const newBtn = genBtn.cloneNode(true);
        genBtn.parentNode.replaceChild(newBtn, genBtn);
        newBtn.addEventListener('click', generateCsvReport);
    }

    function calculateCurtainPropertiesHeadless(lath, bottomLath, endlock, width_mm, height_mm, isPowderCoated) {
        if (!lath || !bottomLath || height_mm <= 0) { return { totalWeight: 0, torqueWeight: 0, travelHeight: 0 }; }
        const axleRadius = 60; 
        const lathCompressedHeight = parseFloat(lath['Compressed lath height']);
        const bottomLathHeight = parseFloat(bottomLath['BLath height']) || 0;
        const heightToCoverByLaths = (height_mm - bottomLathHeight) + axleRadius;
        let numLaths = (lathCompressedHeight > 0 && heightToCoverByLaths > 0) ? Math.ceil(heightToCoverByLaths / lathCompressedHeight) + 2 : 0;
        const widthM = width_mm / 1000;
        
        let kgsPerM2 = parseFloat(lath['Kgs/ m2']) || 0;
        if (isPowderCoated) { kgsPerM2 += 0.5; }

        const lathWeightBasedOnCoverage = widthM * (numLaths * lathCompressedHeight / 1000) * kgsPerM2;
        const bottomLathWeight = widthM * (parseFloat(bottomLath['BLath weight / m length']) || 0);
        let totalEndlockWeight = 0;
        let bufferEndlockWeight = 0; 
        const lathName = (lath['Name'] || '').toLowerCase();
        const isWindLath = lathName.includes('wind');
        if (isWindLath) {
            const castEndlockObj = endlockData.find(el => (el['Description'] || '').toLowerCase().includes('75mm cast'));
            let castWeightG = 0;
            if (castEndlockObj) {
                const wKey = Object.keys(castEndlockObj).find(k => k.toLowerCase().trim() === 'weight in grams');
                castWeightG = wKey ? parseFloat(castEndlockObj[wKey]) : 0;
            }
            const windEndlockObj = endlockData.find(el => (el['Description'] || '').toLowerCase().includes('75mm wind'));
            let windWeightG = 0;
            if (windEndlockObj) {
                const wKey = Object.keys(windEndlockObj).find(k => k.toLowerCase().trim() === 'weight in grams');
                windWeightG = wKey ? parseFloat(windEndlockObj[wKey]) : 0;
            }
            for (let i = 1; i <= numLaths; i++) {
                if (i % 2 !== 0 && castWeightG > 0) { totalEndlockWeight += 2 * (castWeightG / 1000); }
                const isWindLathPosition = (i === 2 || i === 4 || i === 6 || i === 8) || (i > 8 && i % 8 === 0);
                if (isWindLathPosition && windWeightG > 0) { totalEndlockWeight += 2 * (windWeightG / 1000); }
            }
            if (castWeightG > 0) { bufferEndlockWeight = 4 * (castWeightG / 1000); }
        } else {
            let endlockWeightG = 0;
            if (endlock) {
                const weightKey = Object.keys(endlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                endlockWeightG = weightKey ? parseFloat(endlock[weightKey]) : 0;
                if (endlockWeightG > 0 && numLaths > 0) {
                    const numEndlockPairs = Math.ceil(numLaths / 2); 
                    totalEndlockWeight = numEndlockPairs * 2 * (endlockWeightG / 1000);
                }
            }
            if (endlockWeightG > 0) { bufferEndlockWeight = 4 * (endlockWeightG / 1000); }
        }
        const totalWeight = lathWeightBasedOnCoverage + bottomLathWeight + totalEndlockWeight;
        let torqueWeight = totalWeight;
        if (numLaths >= 3) {
            const bufferLathWeight = 3 * (lathCompressedHeight / 1000) * widthM * kgsPerM2;
            torqueWeight = totalWeight - bufferLathWeight - bufferEndlockWeight;
        }
        const travelHeight = height_mm - bottomLathHeight;
        return { totalWeight, torqueWeight, travelHeight };
    }

    function findBestAxleHeadless(totalWeightKgs, totalLength, lath, width_mm) {
         if (totalLength <= 0 || axleData.length === 0) { return { name: 'null', deflection: 0, axleObj: null }; }
        const axlesForShape = axleData.filter(axle => (axle.Shape || 'circular').toLowerCase().trim() === 'circular');
        if (axlesForShape.length === 0) return { name: 'null', deflection: 0, axleObj: null };
        let bestAxle = null;
        let bestDeflection = 0;
        let requiredRatio = 400;
        if (width_mm > 10000) requiredRatio = 800;
        else if (width_mm > 8000) requiredRatio = 600;
        for (const axle of axlesForShape) {
            const perf = performDeflectionCalc(totalWeightKgs, axle, totalLength, width_mm);
            if (perf.ratio >= requiredRatio && perf.deflection <= 17) { 
                bestAxle = axle; 
                bestDeflection = perf.deflection;
                break; 
            }
        }
        if (bestAxle) { 
            return { name: bestAxle.Name, deflection: bestDeflection, axleObj: bestAxle }; 
        } else { 
            let bestFailAxle = axlesForShape[0];
            let minDeflection = Infinity;
            axlesForShape.forEach(axle => {
                 const perf = performDeflectionCalc(totalWeightKgs, axle, totalLength, width_mm);
                 if(perf.deflection < minDeflection) {
                     minDeflection = perf.deflection;
                     bestFailAxle = axle;
                 }
            });
            return { name: bestFailAxle.Name, deflection: minDeflection, axleObj: bestFailAxle }; 
        }
    }

    function calculateTorqueHeadless(torqueWeight, lath, travelHeight, axle, width_mm, bottomLath, baseline_friction, matchAxleDia, overrideCollarDia, height_mm, motorObj) {
        if (!lath || !axle || !bottomLath || travelHeight <= 0 || torqueWeight <= 0) return 0;
        const lathThickness = parseFloat(lath['Thickness']) || 0;
        let effectiveStartDiameter = getEffectiveCoilDiameter(axle);
        if (matchAxleDia > 0 && overrideCollarDia > 0) {
            const currentAxleDia = parseFloat(axle['Diameter']) || 0;
            if (Math.abs(currentAxleDia - matchAxleDia) < 2.0) {
                effectiveStartDiameter = Math.max(effectiveStartDiameter, overrideCollarDia);
            }
        }
        const bottomLathWeightActual = (width_mm / 1000) * (parseFloat(bottomLath['BLath weight / m length']) || 0);
        const lathsWeight = torqueWeight - bottomLathWeightActual;
        let heightLifted = 0;
        let currentRollDiameter = effectiveStartDiameter;
        let maxTorqueFound = 0;
        while (heightLifted < travelHeight) {
            const force = ( (lathsWeight * (1 - heightLifted/travelHeight)) + bottomLathWeightActual) * 9.81;
            const radiusM = ((currentRollDiameter + lathThickness) / 2) / 1000
            maxTorqueFound = Math.max(maxTorqueFound, force * radiusM);
            heightLifted += (Math.PI * currentRollDiameter) / 2; 
            currentRollDiameter += lathThickness;
        }
        let totalFriction = baseline_friction;
        if (height_mm >= 7000) totalFriction += 5;
        if (motorObj) {
            const usageKey = Object.keys(motorObj).find(k => k.toLowerCase().trim() === 'usage type');
            const usage = usageKey ? (motorObj[usageKey] || '').toLowerCase() : '';
            if (usage.includes('high') || usage.includes('hi ') || usage.includes('speed')) {
                totalFriction += 5;
            }
        }
        return maxTorqueFound * (1 + totalFriction / 100);
    }

    async function generateCsvReport() {
        const statusDiv = document.getElementById('csv-generation-status');
        statusDiv.textContent = 'Starting report generation...'; statusDiv.style.color = 'blue';
        await new Promise(resolve => setTimeout(resolve, 50));
        const minWidth = parseInt(document.getElementById('reportMinWidth').value);
        const maxWidth = parseInt(document.getElementById('reportMaxWidth').value);
        const minHeight = parseInt(document.getElementById('reportMinHeight').value);
        const maxHeight = parseInt(document.getElementById('reportMaxHeight').value);
        const interval = parseInt(document.getElementById('reportInterval').value);
        const reportAxleMatch = parseFloat(document.getElementById('reportAxleMatch').value) || 0;
        const reportCollarOverride = parseFloat(document.getElementById('reportCollarOverride').value) || 0;
        
        const isReportPowderCoated = document.getElementById('reportPowderCoated').checked;

        const lathIndex1 = document.getElementById('reportLathType').value;
        const lathIndex2 = document.getElementById('reportLathType2').value;
        const switchLimit = document.getElementById('reportLathLimit').value ? parseInt(document.getElementById('reportLathLimit').value) : Infinity; 
        const endlockIndex = document.getElementById('reportEndlockType').value;
        const bottomLathIndex = document.getElementById('reportBottomLathType').value;
        if (lathIndex1 === "" || endlockIndex === "" || bottomLathIndex === "") {
            statusDiv.textContent = 'Error: Missing selections.'; statusDiv.style.color = 'red'; return;
        }
        const primaryLath = lathData[lathIndex1];
        const secondaryLath = (lathIndex2 !== "") ? lathData[lathIndex2] : primaryLath; 
        const selectedEndlock = endlockData[endlockIndex];
        const selectedBottomLath = bottomLathData[bottomLathIndex];
        const getSelectedValues = (className) => Array.from(document.querySelectorAll(`.${className}:checked`)).map(cb => cb.value);
        const selectedManufacturers = getSelectedValues('report-motor-checkbox');
        const selectedVoltages = getSelectedValues('report-voltage-checkbox');
        const selectedMountings = getSelectedValues('report-mounting-checkbox');
        const selectedUsageTypes = getSelectedValues('report-usage-checkbox');
        
        let manufacturerKey = '', voltageKey = '', mountingKey = '', usageKey = '';
        if (motorData.length > 0) {
            const firstMotor = motorData[0];
            manufacturerKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'manufacturer');
            voltageKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'voltage');
            mountingKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'mounting type');
            usageKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'usage type');
        }
        const calculationCache = {};
        const defaultAdditionalLength = 20; 

        for (let width = minWidth; width <= maxWidth; width += interval) {
            calculationCache[width] = {};
            const currentLath = (width > switchLimit) ? secondaryLath : primaryLath;
            for (let height = minHeight; height <= maxHeight; height += interval) {
                const props = calculateCurtainPropertiesHeadless(currentLath, selectedBottomLath, selectedEndlock, width, height, isReportPowderCoated);
                const axleResult = findBestAxleHeadless(props.totalWeight, width + defaultAdditionalLength, currentLath, width);
                const defaultFriction = parseFloat(currentLath['Friction %']) || 10;
                
                const result = {
                    'Lath Type Used': currentLath.Name, 
                    'Total Weight (kg)': props.totalWeight.toFixed(2),
                    'Required Axle Name': axleResult.name,
                    'Axle Deflection (mm)': axleResult.deflection.toFixed(2)
                };

                for (const usage of selectedUsageTypes) {
                    for (const man of selectedManufacturers) {
                        for (const vol of selectedVoltages) {
                            for (const mou of selectedMountings) {
                                const scenarioName = `${usage} - ${man} (${vol}, ${mou})`;
                                const sampleMotor = motorData.find(m => {
                                    const motorVoltages = String(m[voltageKey] || '').split('/').map(v => v.trim());
                                    const volMatch = motorVoltages.includes(String(vol));
                                    return m[usageKey] == usage && m[manufacturerKey] == man && volMatch && m[mountingKey] == mou;
                                });
                                
                                const reqTorque = calculateTorqueHeadless(props.torqueWeight, currentLath, props.travelHeight, axleResult.axleObj, width, selectedBottomLath, defaultFriction, reportAxleMatch, reportCollarOverride, height, sampleMotor);

                                const suitableMotors = motorData.filter(m => {
                                    const motorVoltages = String(m[voltageKey] || '').split('/').map(v => v.trim());
                                    const volMatch = motorVoltages.includes(String(vol));
                                    return m[usageKey] == usage && m[manufacturerKey] == man && volMatch && m[mountingKey] == mou && reqTorque > 0 && reqTorque >= parseFloat(m['Torque (Nm) min']) && reqTorque <= parseFloat(m['Torque (Nm) max']);
                                }).sort((a,b) => parseFloat(a['Torque (Nm) max']) - parseFloat(b['Torque (Nm) max']));
                                
                                result[`Motor: ${scenarioName}`] = suitableMotors.length > 0 ? suitableMotors[0].Name : 'null';
                            }
                        }
                    }
                }
                calculationCache[width][height] = result;
            }
        }

        const csvData = [];
        const widthHeaders = ['Height \\ Width'];
        for (let w = minWidth; w <= maxWidth; w += interval) { widthHeaders.push(w); }
        const tableTypes = Object.keys(calculationCache[minWidth][minHeight]);
        
        for (const tableType of tableTypes) {
            csvData.push([`Data: ${tableType}`]);
            csvData.push(widthHeaders);
            for (let height = minHeight; height <= maxHeight; height += interval) {
                const row = [height];
                for (let width = minWidth; width <= maxWidth; width += interval) {
                    row.push(calculationCache[width]?.[height]?.[tableType] || 'N/A');
                }
                csvData.push(row);
            }
            csvData.push([]); 
        }

        downloadCsv(csvData);
        statusDiv.textContent = 'Report generated and downloaded.'; 
        statusDiv.style.color = 'green';
    }

    function downloadCsv(data) {
        let csvContent = "data:text/csv;charset=utf-8,";
        data.forEach(function(rowArray) {
            let row = rowArray.map(item => `"${String(item).replace(/"/g, '""')}"`).join(",");
            csvContent += row + "\r\n";
        });
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "shutter_report.csv");
        document.body.appendChild(link);
        link.click();
    }
    
    // --- DXF GENERATION HELPER FUNCTIONS ---

// --- DXF GENERATION HELPER FUNCTIONS ---

    // We start at hex 200 to avoid conflicts with standard reserved handles
    let handleCounter = 0x200; 
    function getHandle() {
        handleCounter++;
        return handleCounter.toString(16).toUpperCase();
    }

    // Generate Standard DXF Header with Extents and calculated HANDSEED
    function getDxfHeader(minX, minY, maxX, maxY, nextHandleSeed) {
        return [
            "0", "SECTION", "2", "HEADER",
            "9", "$ACADVER", "1", "AC1032",      
            "9", "$ACADMAINTVER", "90", "377",   
            "9", "$DWGCODEPAGE", "3", "ANSI_1252", 
            "9", "$INSUNITS", "70", "4",         
            "9", "$MEASUREMENT", "70", "1",      
            "9", "$LTSCALE", "40", "1.0",        
            "9", "$EXTMIN", "10", minX.toFixed(3), "20", minY.toFixed(3), "30", "0.0",
            "9", "$EXTMAX", "10", maxX.toFixed(3), "20", maxY.toFixed(3), "30", "0.0",
            "9", "$HANDSEED", "5", nextHandleSeed, 
            "0", "ENDSEC"
        ];
    }

    function getDxfClasses() {
        return ["0", "SECTION", "2", "CLASSES", "0", "ENDSEC"];
    }

    // Includes all mandatory layout tables based on the text file
    function getDxfTables() {
        return [
            "0", "SECTION", "2", "TABLES",
            
            "0", "TABLE", "2", "VPORT", "5", "8", "330", "0", "100", "AcDbSymbolTable", "70", "1",
            "0", "VPORT", "5", getHandle(), "330", "8", "100", "AcDbSymbolTableRecord", "100", "AcDbViewportTableRecord", "2", "*Active", "70", "0",
            "0", "ENDTAB",

            "0", "TABLE", "2", "LTYPE", "5", "5", "330", "0", "100", "AcDbSymbolTable", "70", "1",
            "0", "LTYPE", "5", getHandle(), "330", "5", "100", "AcDbSymbolTableRecord", "100", "AcDbLinetypeTableRecord", "2", "CONTINUOUS", "70", "0", "3", "Solid line", "72", "65", "73", "0", "40", "0.0",
            "0", "ENDTAB",

            "0", "TABLE", "2", "LAYER", "5", "2", "330", "0", "100", "AcDbSymbolTable", "70", "6",
            "0", "LAYER", "5", getHandle(), "330", "2", "100", "AcDbSymbolTableRecord", "100", "AcDbLayerTableRecord", "2", "0", "70", "0", "62", "7", "6", "CONTINUOUS",
            "0", "LAYER", "5", getHandle(), "330", "2", "100", "AcDbSymbolTableRecord", "100", "AcDbLayerTableRecord", "2", "OUTLINE", "70", "0", "62", "7", "6", "CONTINUOUS",
            "0", "LAYER", "5", getHandle(), "330", "2", "100", "AcDbSymbolTableRecord", "100", "AcDbLayerTableRecord", "2", "AXLE", "70", "0", "62", "1", "6", "CONTINUOUS",
            "0", "LAYER", "5", getHandle(), "330", "2", "100", "AcDbSymbolTableRecord", "100", "AcDbLayerTableRecord", "2", "GUIDES", "70", "0", "62", "4", "6", "CONTINUOUS",
            "0", "LAYER", "5", getHandle(), "330", "2", "100", "AcDbSymbolTableRecord", "100", "AcDbLayerTableRecord", "2", "LATHS", "70", "0", "62", "251", "6", "CONTINUOUS",
            "0", "LAYER", "5", getHandle(), "330", "2", "100", "AcDbSymbolTableRecord", "100", "AcDbLayerTableRecord", "2", "DIMENSIONS", "70", "0", "62", "3", "6", "CONTINUOUS",
            "0", "ENDTAB",

            "0", "TABLE", "2", "STYLE", "5", "3", "330", "0", "100", "AcDbSymbolTable", "70", "1",
            "0", "STYLE", "5", getHandle(), "330", "3", "100", "AcDbSymbolTableRecord", "100", "AcDbTextStyleTableRecord", "2", "Standard", "70", "0", "40", "0.0", "41", "1.0", "50", "0.0", "71", "0", "42", "2.5", "3", "txt", "4", "",
            "0", "ENDTAB",

            "0", "TABLE", "2", "APPID", "5", "9", "330", "0", "100", "AcDbSymbolTable", "70", "1",
            "0", "APPID", "5", getHandle(), "330", "9", "100", "AcDbSymbolTableRecord", "100", "AcDbRegAppTableRecord", "2", "ACAD", "70", "0",
            "0", "ENDTAB",

            "0", "TABLE", "2", "DIMSTYLE", "5", "A", "330", "0", "100", "AcDbSymbolTable", "100", "AcDbDimStyleTable", "70", "1",
            "0", "DIMSTYLE", "105", getHandle(), "330", "A", "100", "AcDbSymbolTableRecord", "100", "AcDbDimStyleTableRecord", "2", "Standard", "70", "0",
            "0", "ENDTAB",

            "0", "TABLE", "2", "BLOCK_RECORD", "5", "1", "330", "0", "100", "AcDbSymbolTable", "70", "2",
            "0", "BLOCK_RECORD", "5", "1F", "330", "1", "100", "AcDbSymbolTableRecord", "100", "AcDbBlockTableRecord", "2", "*Model_Space", "340", "22", "70", "0", "280", "1", "281", "0",
            "0", "BLOCK_RECORD", "5", "D2", "330", "1", "100", "AcDbSymbolTableRecord", "100", "AcDbBlockTableRecord", "2", "*Paper_Space", "340", "D3", "70", "0", "280", "1", "281", "0",
            "0", "ENDTAB",
            
            "0", "ENDSEC"
        ];
    }

    // Required block openings
    function getDxfBlocks() {
        return [
            "0", "SECTION", "2", "BLOCKS",
            "0", "BLOCK", "5", "20", "330", "1F", "100", "AcDbEntity", "8", "0", "100", "AcDbBlockBegin", "2", "*Model_Space", "70", "0", "10", "0.0", "20", "0.0", "30", "0.0", "3", "*Model_Space", "1", "",
            "0", "ENDBLK", "5", "21", "330", "1F", "100", "AcDbEntity", "8", "0", "100", "AcDbBlockEnd",
            "0", "BLOCK", "5", "D4", "330", "D2", "100", "AcDbEntity", "67", "1", "8", "0", "100", "AcDbBlockBegin", "2", "*Paper_Space", "70", "0", "10", "0.0", "20", "0.0", "30", "0.0", "3", "*Paper_Space", "1", "",
            "0", "ENDBLK", "5", "D5", "330", "D2", "100", "AcDbEntity", "67", "1", "8", "0", "100", "AcDbBlockEnd",
            "0", "ENDSEC"
        ];
    }

    // Entity Object Pointers (Added "330", "1F" mapping to model space)
    function addDxfRect(arr, x, y, w, h, layer) {
        arr.push(
            "0", "LWPOLYLINE", "5", getHandle(),
            "330", "1F", "8", layer,
            "100", "AcDbEntity", "100", "AcDbPolyline",
            "90", "4", "70", "1", "43", "0.0",
            "10", x.toFixed(3), "20", y.toFixed(3),
            "10", (x + w).toFixed(3), "20", y.toFixed(3),
            "10", (x + w).toFixed(3), "20", (y + h).toFixed(3),
            "10", x.toFixed(3), "20", (y + h).toFixed(3)
        );
    }

    function addDxfCircle(arr, cx, cy, r, layer) {
        arr.push(
            "0", "CIRCLE", "5", getHandle(),
            "330", "1F", "8", layer,
            "100", "AcDbEntity", "100", "AcDbCircle",
            "10", cx.toFixed(3), "20", cy.toFixed(3), "30", "0.0", 
            "40", r.toFixed(3)
        );
    }

    function addDxfLine(arr, x1, y1, x2, y2, layer) {
        arr.push(
            "0", "LINE", "5", getHandle(),
            "330", "1F", "8", layer,
            "100", "AcDbEntity", "100", "AcDbLine",
            "10", x1.toFixed(3), "20", y1.toFixed(3), "30", "0.0",
            "11", x2.toFixed(3), "21", y2.toFixed(3), "31", "0.0"
        );
    }

    function addDxfText(arr, x, y, text, height, layer) {
        arr.push(
            "0", "TEXT", "5", getHandle(),
            "330", "1F", "8", layer,
            "100", "AcDbEntity", "100", "AcDbText",
            "10", x.toFixed(3), "20", y.toFixed(3), "30", "0.0",
            "40", height.toFixed(3),
            "1", text,
            "100", "AcDbText"
        );
    }

    // Required root dictionary
    function getDxfObjects() {
        return [
            "0", "SECTION", "2", "OBJECTS",
            "0", "DICTIONARY", "5", getHandle(), "330", "0", "100", "AcDbDictionary", "281", "1",
            "0", "ENDSEC"
        ];
    }

    // --- MAIN EXPORT FUNCTION ---
    function downloadDXF() {
        try {
            // 1. Gather Data
            const width = parseFloat(dom['calculated-curtain-width'].textContent) || 0;
            const height = parseFloat(dom.height.value) || 0;
            const additionalAxle = parseFloat(dom.additionalLength.value) || 0;
            
            const lathIndex = dom.lathType.value;
            const bLathIndex = dom.bottomLathType.value;
            const axleIndex = dom.axleType.value;
            const guideIndex = dom.guideType.value;
            const endplateIndex = dom.endplateSelector.value;

            if (width === 0 || lathIndex === "" || axleIndex === "") {
                alert("Please ensure Width, Lath, and Axle are selected before exporting.");
                return;
            }

            const lath = lathData[lathIndex];
            const axle = axleData[axleIndex];
            const bLath = bottomLathData[bLathIndex];
            
            const lathH = parseFloat(lath['Compressed lath height']);
            const lathThick = parseFloat(lath['Thickness']) || 14;
            const bLathH = parseFloat(bLath['BLath height']) || 50;
            const numLaths = parseInt(dom['lath-count'].textContent) || 0;
            const axleDia = parseFloat(axle['Diameter']);
            
            let guideWidth = 50; 
            let guidePenetration = 0;
            if (guideIndex !== "" && guideData[guideIndex]) {
                guideWidth = parseFloat(guideData[guideIndex]['Width']) || 50;
                guidePenetration = parseFloat(guideData[guideIndex]['Penetration']) || 0;
            }

            let endplateSize = 300; 
            if (endplateIndex !== "" && currentFilteredEndplates[endplateIndex]) {
                endplateSize = parseFloat(currentFilteredEndplates[endplateIndex].Size);
            }

            // Reset Handle Counter so it's fresh each time we click export
            handleCounter = 0x200;

            // Generate structural components that use handles BEFORE the header
            const dxfClasses = getDxfClasses(); 
            const dxfTables = getDxfTables();
            const dxfBlocks = getDxfBlocks();

            // 2. Initialize DXF Entity Structure
            let dxfBody = [];
            dxfBody.push("0", "SECTION", "2", "ENTITIES");

            // --- DRAWING LOGIC ---
            const axleY = height;
            const totalAxleWidth = width + additionalAxle;
            const axleXStart = -(totalAxleWidth / 2);
            const curtainLeftX = -(width / 2);
            const curtainRightX = (width / 2);

            // A. FRONT VIEW
            const epY = axleY - (endplateSize / 2);
            // Endplates
            addDxfRect(dxfBody, axleXStart, epY, 5, endplateSize, "AXLE"); 
            addDxfRect(dxfBody, (axleXStart + totalAxleWidth) - 5, epY, 5, endplateSize, "AXLE");
            // Axle
            addDxfRect(dxfBody, axleXStart, axleY - (axleDia/2), totalAxleWidth, axleDia, "AXLE");
            // Centerline
            addDxfLine(dxfBody, axleXStart - 50, axleY, axleXStart + totalAxleWidth + 50, axleY, "DIMENSIONS");
            
            // Guides
            addDxfRect(dxfBody, curtainLeftX - (guideWidth - guidePenetration), 0, guideWidth, height, "GUIDES");
            addDxfRect(dxfBody, curtainRightX - guidePenetration, 0, guideWidth, height, "GUIDES");
            
            // Curtain
            addDxfRect(dxfBody, curtainLeftX, 0, width, bLathH, "LATHS");
            let currentY = bLathH;
            for(let i=0; i<numLaths; i++) {
                if (currentY + lathH > axleY - (axleDia/2)) break;
                addDxfRect(dxfBody, curtainLeftX, currentY, width, lathH, "LATHS");
                currentY += lathH;
            }
            addDxfText(dxfBody, 0, -200, "FRONT VIEW", 50, "OUTLINE");

            // B. PLAN VIEW (Below)
            const planY = -600; 
            const lgX = curtainLeftX - (guideWidth - guidePenetration);
            const rgX = curtainRightX - guidePenetration;
            const curtainPlanY = planY + (60 - lathThick)/2; // Assume 60mm guide depth
            
            addDxfRect(dxfBody, lgX, planY, guideWidth, 60, "GUIDES"); 
            addDxfRect(dxfBody, rgX, planY, guideWidth, 60, "GUIDES");
            addDxfRect(dxfBody, curtainLeftX, curtainPlanY, width, lathThick, "LATHS");
            addDxfText(dxfBody, 0, planY - 200, "PLAN VIEW", 50, "OUTLINE");

            // C. SECTION VIEW (Right)
            const sectX = (width/2) + 800; 
            const epSectLeft = sectX;
            const epSectTop = axleY + (endplateSize/2);
            const maxCoil = parseFloat(dom['max-coil-diameter'].textContent) || (axleDia + 100);

            // Wall/Guide Line
            addDxfLine(dxfBody, sectX, 0, sectX, height + 500, "OUTLINE");
            // Endplate Box
            addDxfRect(dxfBody, epSectLeft, epSectTop - endplateSize, endplateSize, endplateSize, "AXLE");
            // Axle/Coil
            addDxfCircle(dxfBody, epSectLeft + (endplateSize/2), axleY, axleDia/2, "AXLE");
            addDxfCircle(dxfBody, epSectLeft + (endplateSize/2), axleY, maxCoil/2, "LATHS");
            // Guide Side
            addDxfRect(dxfBody, sectX, 0, 60, height, "GUIDES"); 
            addDxfText(dxfBody, sectX + (endplateSize/2), -200, "SECTION VIEW", 50, "OUTLINE");

            dxfBody.push("0", "ENDSEC"); // End ENTITIES
            
            const dxfObjects = getDxfObjects();

            // 3. Calculate Extents for Header
            const minX = curtainLeftX - 500;
            const maxX = sectX + 500;
            const minY = planY - 500;
            const maxY = height + 500;

            // Generate the next seed AFTER all shapes and objects are built
            const nextHandleSeed = (handleCounter + 1).toString(16).toUpperCase();

            // Assemble Full DXF in Strict AC1032 Order
            let fullDxf = [];
            fullDxf = fullDxf.concat(getDxfHeader(minX, minY, maxX, maxY, nextHandleSeed));
            fullDxf = fullDxf.concat(dxfClasses); 
            fullDxf = fullDxf.concat(dxfTables);
            fullDxf = fullDxf.concat(dxfBlocks); 
            fullDxf = fullDxf.concat(dxfBody);        
            fullDxf = fullDxf.concat(dxfObjects);     
            fullDxf.push("0", "EOF");

            // 5. Create Blob and Download
            const blob = new Blob([fullDxf.join('\r\n')], { type: 'application/dxf' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `Shutter_Layout_${width.toFixed(0)}x${height.toFixed(0)}.dxf`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

        } catch (err) {
            console.error("DXF Generation Error:", err);
            alert("An error occurred while generating the DXF file. Please check console.");
        }
    }
 
function getSmallestShaftDiameter() {
    // 1. Get Motor Shaft Raw exactly as the Axle Graphic does
    let motorShaftRaw = parseFloat(dom['motor-driveshaft-dia'].textContent);
    if (isNaN(motorShaftRaw)) motorShaftRaw = 40; 
    
    // 2. Get Safety Brake Shaft exactly as the Axle Graphic does
    let brakeShaftValue = 0;
    const sbIndex = dom.safetyBrakeSelector ? dom.safetyBrakeSelector.value : "";
    if (sbIndex !== "" && typeof safetyBrakeData !== 'undefined' && safetyBrakeData[sbIndex]) {
        const sb = safetyBrakeData[sbIndex];
        const dsKey = Object.keys(sb).find(k => k.toLowerCase().includes('driveshaft diameter'));
        if (dsKey) brakeShaftValue = parseFloat(sb[dsKey]);
    }
    if (!brakeShaftValue || isNaN(brakeShaftValue)) {
        if (dom['safety-brake-driveshaft'] && dom['safety-brake-driveshaft'].textContent !== 'N/A') {
            brakeShaftValue = parseFloat(dom['safety-brake-driveshaft'].textContent);
        }
    }
    if (isNaN(brakeShaftValue) || brakeShaftValue === 0) brakeShaftValue = 40;

    // Helper to lookup bearing size to match the cross-section logic
    const lookupBearingSize = (minSize) => {
        if (typeof bearingData === 'undefined' || bearingData.length === 0) return minSize;
        const first = bearingData[0];
        const sizeKey = Object.keys(first).find(k => k.toLowerCase().trim() === 'shaft size in mm');
        if (!sizeKey) return minSize;
        const sorted = [...bearingData].sort((a,b) => (parseFloat(a[sizeKey]) || 0) - (parseFloat(b[sizeKey]) || 0));
        const match = sorted.find(b => (parseFloat(b[sizeKey]) || 0) >= minSize);
        return match ? parseFloat(match[sizeKey]) : minSize;
    };

    const mountType = (dom.motorMountingType && dom.motorMountingType.value) ? dom.motorMountingType.value.toLowerCase() : '';
    const isTubular = mountType.includes('tubular');
    const isChainDrive = mountType.includes('chain');
    
    let leftShaftDia = 40;
    let rightShaftDia = 40;
    let weldedShafts = [];

    // Evaluate configurations to find which shafts are ACTUALLY welded to the barrel
    if (isTubular) {
        // Tubular: Left is internal motor (not welded to disc). Right is dummy end / safety brake (welded).
        rightShaftDia = brakeShaftValue;
        weldedShafts.push(rightShaftDia);
    } else if (isChainDrive) {
        // Chain Drive: Both ends are dummy shafts welded to barrel discs.
        rightShaftDia = brakeShaftValue;
        const minLeft = (brakeShaftValue < 30) ? 30 : brakeShaftValue;
        leftShaftDia = lookupBearingSize(minLeft);
        weldedShafts.push(leftShaftDia, rightShaftDia);
    } else {
        // Direct Drive (Flange/Foot): Both ends are welded to discs.
        leftShaftDia = motorShaftRaw;
        const minRight = (motorShaftRaw < 30) ? 30 : motorShaftRaw;
        rightShaftDia = lookupBearingSize(minRight);
        weldedShafts.push(leftShaftDia, rightShaftDia);
    }

    // Filter out invalid numbers and find the absolute minimum welded shaft size
    const valid = weldedShafts.filter(n => !isNaN(n) && n > 0 && n < 9999);
    return valid.length > 0 ? Math.min(...valid) : 40;
}

function updateWeldCalculations() {
    const axleIdx = dom.axleType ? dom.axleType.value : "";
    const container = document.getElementById('weld-check-container');
    
    if (axleIdx === "" || typeof axleData === 'undefined' || !axleData[axleIdx]) {
        if(container) container.style.display = 'none';
        return;
    }
    if(container) container.style.display = 'block';

    const axle = axleData[axleIdx];
    const axleDia = parseFloat(axle['Diameter']) || 0;
    
    // 1. Determine Plate Thickness (5mm if <= 139mm (5.5"), 8mm if > 139mm)
    const plateThickness = (axleDia <= 139) ? 5 : 8;
    if(dom['weld-plate-thickness']) dom['weld-plate-thickness'].value = `${plateThickness} mm`;

    // 2. Determine Smallest Welded Shaft (Worst Case)
    const shaftDia = getSmallestShaftDiameter();
    if(dom['weld-shaft-dia']) dom['weld-shaft-dia'].value = `${shaftDia} mm`;

    // 3. Get Applied Torque
    const appliedTorque = dom['max-torque'] ? (parseFloat(dom['max-torque'].textContent) || 0) : 0;
    if(dom['weld-applied-torque']) dom['weld-applied-torque'].value = `${appliedTorque.toFixed(1)} Nm`;

    // 4. Calculate Capacity
    // Shear Stress Allowable (mild steel weld) approx 100 N/mm^2 (MPa)
    const allowableShearStress = 100; 
    const weldTorqueCapacityNm = (allowableShearStress * Math.PI * Math.pow(shaftDia, 2) * plateThickness) / (2 * 1000);
    
    if(dom['weld-capacity-torque']) dom['weld-capacity-torque'].value = `${weldTorqueCapacityNm.toFixed(0)} Nm`;

    // 5. Calculate Geometric Details
    const perimeter = Math.PI * shaftDia;
    if(dom['weld-perimeter']) dom['weld-perimeter'].textContent = perimeter.toFixed(1);

    const radiusM = (shaftDia / 2) / 1000;
    const shearForceN = (radiusM > 0) ? appliedTorque / radiusM : 0;
    if(dom['weld-max-force']) dom['weld-max-force'].textContent = shearForceN.toFixed(0);

    // 6. Status Check
    const statusEl = dom['weld-status'];
    if(statusEl) {
        if (appliedTorque > weldTorqueCapacityNm) {
            statusEl.textContent = "FAIL (Weld too weak)";
            statusEl.className = "warning-text";
            if(dom['weld-capacity-torque']) {
                dom['weld-capacity-torque'].style.color = "#d93025";
                dom['weld-capacity-torque'].style.fontWeight = "bold";
            }
        } else {
            const safetyMargin = weldTorqueCapacityNm > 0 ? ((weldTorqueCapacityNm - appliedTorque) / weldTorqueCapacityNm) * 100 : 0;
            statusEl.textContent = `PASS (${safetyMargin.toFixed(0)}% safety margin)`;
            statusEl.className = "option-pass";
            statusEl.style.color = "#1e8e3e";
            if(dom['weld-capacity-torque']) {
                dom['weld-capacity-torque'].style.color = "#1e8e3e";
                dom['weld-capacity-torque'].style.fontWeight = "normal";
            }
        }
    }

    drawWeldGraphic(shaftDia, plateThickness, appliedTorque, weldTorqueCapacityNm);
}

function drawWeldGraphic(shaftDia, plateThickness, appliedTorque, capacity) {
    const container = dom['weld-graphic-container'];
    if(!container) return;
    container.innerHTML = '';
    
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    
    const width = 500;
    const height = 500;
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    
    // --- SCALING STYLES ---
    svg.style.width = "100%";       
    svg.style.maxWidth = "450px";   // Limits width to 450px (approx half scale)
    svg.style.height = "auto";      // Maintains aspect ratio
    svg.style.display = "block";    
    svg.style.margin = "0 auto";    // Centers the graphic
    
    const cx = 150;
    const cy = 150;
    const scale = 2.5; // Visual scale

    const defs = document.createElementNS(svgNS, 'defs');
    const marker = document.createElementNS(svgNS, 'marker');
    marker.setAttribute('id', 'weld-arrow');
    marker.setAttribute('viewBox', '0 0 10 10');
    marker.setAttribute('refX', '9');
    marker.setAttribute('refY', '5');
    marker.setAttribute('markerWidth', '6');
    marker.setAttribute('markerHeight', '6');
    marker.setAttribute('orient', 'auto');
    const path = document.createElementNS(svgNS, 'path');
    path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
    path.setAttribute('fill', '#e67e22');
    marker.appendChild(path);
    defs.appendChild(marker);
    svg.appendChild(defs);

    // 1. Plate (Outer Circle)
    const discRadius = (shaftDia/2 + 20) * scale;
    const plate = document.createElementNS(svgNS, 'circle');
    plate.setAttribute('cx', cx); plate.setAttribute('cy', cy);
    plate.setAttribute('r', discRadius);
    plate.setAttribute('fill', '#e9ecef');
    plate.setAttribute('stroke', '#adb5bd');
    svg.appendChild(plate);

    // 2. Shaft (Inner Circle)
    const shaftRadius = (shaftDia/2) * scale;
    const shaft = document.createElementNS(svgNS, 'circle');
    shaft.setAttribute('cx', cx); shaft.setAttribute('cy', cy);
    shaft.setAttribute('r', shaftRadius);
    shaft.setAttribute('fill', '#95a5a6');
    shaft.setAttribute('stroke', '#343a40');
    svg.appendChild(shaft);

    // 3. Weld (Dashed Ring around shaft)
    const weld = document.createElementNS(svgNS, 'circle');
    weld.setAttribute('cx', cx); weld.setAttribute('cy', cy);
    weld.setAttribute('r', shaftRadius + 2);
    weld.setAttribute('fill', 'none');
    weld.setAttribute('stroke', '#e67e22'); // Orange for weld
    weld.setAttribute('stroke-width', '4');
    weld.setAttribute('stroke-dasharray', '5,3');
    svg.appendChild(weld);

    // 4. Force Arrows (Tangential)
    const arrowPath = document.createElementNS(svgNS, 'path');
    const arcR = shaftRadius + 15;
    const d = `M ${cx - arcR} ${cy} A ${arcR} ${arcR} 0 0 1 ${cx} ${cy - arcR}`;
    arrowPath.setAttribute('d', d);
    arrowPath.setAttribute('fill', 'none');
    arrowPath.setAttribute('stroke', '#e67e22');
    arrowPath.setAttribute('stroke-width', '3');
    arrowPath.setAttribute('marker-end', 'url(#weld-arrow)');
    svg.appendChild(arrowPath);

    // 5. Labels
    const createText = (x, y, text, color='#333', size='12px', weight='normal') => {
        const t = document.createElementNS(svgNS, 'text');
        t.setAttribute('x', x); t.setAttribute('y', y);
        t.setAttribute('fill', color);
        t.setAttribute('font-family', 'sans-serif');
        t.setAttribute('font-size', size);
        t.setAttribute('font-weight', weight);
        t.textContent = text;
        svg.appendChild(t);
    };

    // Right Side Info Panel
    const infoX = 300;
    createText(infoX, 60, "Weld Stress Analysis", "#c92a7a", "16px", "bold");
    
    createText(infoX, 90, `Shaft: Ø${shaftDia} mm`);
    createText(infoX, 110, `Disc Thickness: ${plateThickness} mm`);
    
    const resultColor = (appliedTorque > capacity) ? "#d93025" : "#1e8e3e";
    
    createText(infoX, 150, "Capacity:", "#555", "12px");
    createText(infoX + 70, 150, `${capacity.toFixed(0)} Nm`, "#333", "12px", "bold");
    
    createText(infoX, 170, "Load:", "#555", "12px");
    createText(infoX + 70, 170, `${appliedTorque.toFixed(1)} Nm`, resultColor, "12px", "bold");

    createText(cx, cy - arcR - 10, "Rotational Force", "#e67e22", "10px", "bold");
    createText(cx, cy + discRadius + 20, "TOP VIEW (Shaft/Disc Weld)", "#555", "10px", "normal");
    
    if (shaftDia < 30) {
        createText(infoX, 230, "⚠️ Using sub-30mm shaft size", "#e67e22", "11px", "italic");
    }

    container.appendChild(svg);
}

// Ensure the weld calculation recalculates when Motor or Brake manually changed
if (dom.motorSelector) {
    dom.motorSelector.addEventListener('change', () => {
        if (typeof updateSelectedMotorInfo === 'function') updateSelectedMotorInfo();
        updateWeldCalculations();
    });
}
if (dom.safetyBrakeSelector) {
    dom.safetyBrakeSelector.addEventListener('change', () => {
        if (typeof updateSelectedSafetyBrakeInfo === 'function') updateSelectedSafetyBrakeInfo();
        updateWeldCalculations();
    });
}

</script>
</body>
</html>
